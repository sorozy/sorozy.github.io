[{"title":"DataStructure & Algorithm - Algorithm","url":"/2020/12/03/DataStructure-Algorithm-Algorithm/","content":"\n# LinearSearch\n\n```java\npublic class LinearSearch {\n\n    private LinearSearch(){}\n\n    public static <E> int search (E [] data,E target) {\n        for (int i = 0; i < data.length; i++) {\n            if (data[i].equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n# SelectionSort\n\n```java\npublic class SelectionSort {\n\n    private SelectionSort() {}\n\n    public static <E extends Comparable<E>> void sort(E [] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            // 选择 arr [0..n)中最小值的索引\n            int minIndex = i;\n            for (int j = i; j < arr.length ; j++) {\n                if (arr[j].compareTo(arr[minIndex]) < 0) {\n                    minIndex = j;\n                }\n            }\n            swap(arr,i,minIndex);\n        }\n    }\n\n    private static <E> void swap(E[] arr, int i, int j) {\n        E tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n}\n```\n\n# InsertioSort\n\n```java\npublic class InsertionSort {\n\n    private InsertionSort(){}\n\n    public static <E extends Comparable<E>> void sort (E [] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = i; j-1 >= 0 && arr[j].compareTo(arr[j-1])<0 ;j--) {\n                swap(arr,j,j-1);\n            }\n        }\n    }\n\n    private static <E> void swap(E[] arr, int i, int j) {\n        E tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n","tags":["algorithm"],"categories":["algorithm"]},{"title":"DataStructure & Algorithm - Introduction","url":"/2020/12/02/DataStructure-Algorithm-Introduction/","content":"\n# 数据结构、算法是什么\n\n- 从广义上讲，**数据结构**就是指一组数据的存储结构。**算法**就是操作数据的一组方法\n- 数据结构和算法是相辅相成的。**数据结构是为算法服务的，算法要作用在特定的数据结构之上**\n\n- 数据结构是静态的，它只是组织数据的一种方式\n\n# 为什么要学习数据结构和算法\n\n- 通关大厂面试，别让数据结构和算法拖了后腿\n- 基础框架中，一般都揉和了很多基础数据结构和算法的设计思想，掌握数据结构和算法，利于阅读框架源码，理解其背后的设计思想\n- 基础架构研发工程师，写出达到开源水平的框架才是你的目标（细节：算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等）\n- 编码能力强？性能好坏是其中一个非常重要的评判标准\n- 掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样\n\n> 我们学任何知识都是为了“用”的，是为了解决实际工作问题的\n\n> 我们学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生\n\n# 学习重点\n\n（1）掌握复<font color=red>**杂度分析**</font>\n\n（2）攻克常用的数据结构、算法\n\n> 10 个数据结构：<font color=red>**数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树**</font>\n>\n> 10 个算法：<font color=red>**递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法**</font>\n\n（3）要学习它的<font color=red> **来历、自身的特点、实际的应用场景**</font>\n\n- 数据结构与算法脑图\n\n<img src=\"913e0ababe43a2d57267df5c5f0832a7.jpg\" />\n\n# 学习技巧\n\n（1）**边学边练习，适度刷题（学习内容中涉及的数据结构和算法，全都自己写出来，用代码实现一遍。适度刷题）**\n\n（2）多问、多思考、多互动（找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑）\n\n（3）打怪升级学习法（学习的过程中，我们碰到最大的问题就是，坚持不下来。给自己设立一个切实可行的目标，就像打怪升级一样）\n\n（3）知识需要沉淀，不要想试图一下子掌握所有（学习知识的过程是反复迭代、不断沉淀的过程）\n\n# goals & flag\n\n（1）学习各个数据结构对应的知识（来历、自身特点、实际的应用场景）（常用操作、时间空间复杂度、相关算法题）\n\n（2）对知识点做好笔记写进blog\n\n（3）动手实现相关数据结构。对知识点进行总结\n\n（4）刷一下相关的题目、面试题。（理解其时间空间复杂度）总结经典代码\n\n（5）对算法题分门别类整理\n\n（6）每周学习 2个左右数据结构，以及相关算法题（起步阶段）\n\n","tags":["data-structure","algorithm"],"categories":["data-structure","algorithm"]},{"title":"《MySQL实战45讲》study notes","url":"/2020/11/30/《MySQL实战45讲》study-notes/","content":"\n# MySQL整体架构\n\n<img width=\"800px\" src=\"0d2070e8f84c4801adbfa03bda1f98d9.png\" />\n\n## Server层\n\n- Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等\n\n### 连接器\n\n- 连接器负责跟客户端建立连接、获取权限、维持和管理连接\n\n  ```sql\n  mysql -h$ip -P$port -u$user -p\n  ```\n\n- 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限\n\n- 长连接占用资源和内存比较大，如何解决？\n\n  > 1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。\n  > 2. 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\n\n### 查询缓存\n\n- MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。\n- **但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**\n- 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。\n- MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。\n\n### 分析器\n\n词法分析 -> 语法分析\n\n### 优化器\n\n- 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。\n\n### 执行器\n\n- 开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误\n- \n\n\n\n## 存储引擎层\n\n- 存储引擎层负责数据的存储和提取","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"《阿里新零售数据库设计与实战》 study notes ","url":"/2020/11/27/《阿里新零售数据库设计与实战》-study-notes/","content":"\n# 备注\n\n> linux的目录结构需要了解一下\n>\n> linux常用命令\n>\n> 理解常用的mysql引擎\n\n# 前置知识与环境准备\n\n* 常用命令\n\n  ```shell\n  touch\n  vi/vim\n  \n  mkdir\n  \n  clear\n  \n  rm -rf\n  \n  ps aux\n  \n  kill -9 [8088]\n  ```\n\n* 关闭SELinux\n\n  ```shell\n  vi /etc/selinux/config\n  \n  SELINUX=disabled\n  ```\n\n* 配置yum源\n\n  ```shell\n  curl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo\n  ```\n\n  ```shell\n  yum clean all\n  \n  yum makecache\n  ```\n\n# 安装配置MySQL\n\n## yum源安装mysql\n\n* 下载rpm文件\n\n  ```shell\n  yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm\n  ```\n\n* 安装MySQL数据库\n\n  ```shell\n  yum install mysql-community-server -y\n  ```\n\n## 本地安装MySQL数据库\n\n- [官网下载MySQL的tar包](https://downloads.mysql.com/archives/community/) 然后上传到Linux主机的/root/mysql目录\n\n  ```shell\n  scp -r 22 /Users/sorozy/Documents/study/database/阿里新零售数据库设计与实战/document/MySQL本地安装包/mysql-8.0.11-1.el7.x86_64.rpm-bundle.tar root@192.168.0.113:/root/mysql/\n  ```\n\n  \n\n- 执行解压缩\n\n  ```shell\n  tar xvf mysql-8.0.11-1.el7.x86_64.rpm-bundle.tar\n  ```\n\n- 安装依赖的程序包\n\n  ```shell\n  yum install perl -y\n  yum install net-tools -y\n  ```\n\n- 卸载mariadb程序包\n\n  ```shell\n  rpm -qa|grep mariadb\n  rpm -e mariadb-libs-5.5.56-2.el7.x86_64 --nodeps\n  ```\n\n- 安装MySQL程序包\n\n  ```shell\n  rpm -ivh mysql-community-common-8.0.11-1.el7.x86_64.rpm\n  rpm -ivh mysql-community-libs-8.0.11-1.el7.x86_64.rpm\n  rpm -ivh mysql-community-client-8.0.11-1.el7.x86_64.rpm\n  rpm -ivh mysql-community-server-8.0.11-1.el7.x86_64.rpm\n  ```\n\n- 修改MySQL目录权限\n\n  ```shell\n  chmod -R 777 /var/lib/mysql/\n  ```\n\n- 初始化MySQL\n\n  ```shell\n  mysqld --initialize\n  chmod -R 777 /var/lib/mysql/*\n  ```\n\n  \n\n- 启动MySQL\n\n  ```shell\n  service mysqld start\n  ```\n\n- 查看初始密码\n\n  ```shell\n  grep 'temporary password' /var/log/mysqld.log\n  ```\n\n- 登陆数据库之后，修改默认密码\n\n  ```mysql\n  alter user user() identified by \"111111\"; \n  ```\n\n- 允许远程使用root帐户\n\n  ```mysql\n  UPDATE user SET host = '%' WHERE user ='root';\n  FLUSH PRIVILEGES;\n  ```\n\n- 允许远程访问MySQL数据库（/etc/my.cnf）\n\n  ```ini\n  character_set_server = utf8\n  bind-address = 0.0.0.0\n  ```\n\n- 开启防火墙3360端口\n\n  ```shell\n  firewall-cmd --zone=public --add-port=3306/tcp --permanent\n  firewall-cmd --reload\n  ```\n\n# ER图\n\n## 业务数据库设计流程\n\n<img width=\"800px\" src=\"WechatIMG225.png\" />\n\n\n\n## E-R图概念\n\n- E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述[现实世界](https://baike.baidu.com/item/现实世界/688877)的[概念模型](https://baike.baidu.com/item/概念模型/3187025)。\n\n- 它是描述现实世界关系概念模型的有效方法。是表示概念关系模型的一种方式。用“矩形框”表示[实体型](https://baike.baidu.com/item/实体型/3187353)，矩形框内写明实体名称；用“椭圆图框”或圆角矩形表示实体的属性，并用“实心线段”将其与相应关系的“实体型”连接起来；\n- 瀑布模型\n- 螺旋模型\n\n# CRUD\n\n```sql\ninsert ignore into \n```\n\n\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"Java - OOP","url":"/2020/11/18/Java-OOP/","content":"\n# java类成员\n\n## 属性（成员变量） vs 局部变量\n\n### 不同点\n\n（1）声明位置\n\n​\t\t成员变量：声明在类的一对{}中\n\n​\t\t局部变量：声明在方法内、方法形参、代码块内、构造器内、构造器形参\n\n（2）权限修饰符\n\n​\t\t成员变量：可以在声明属性时，使用权限修饰符（`private protect default public`）\n\n​\t\t局部变量：不可以使用权限修饰符。（仅可以使用final修饰）\n\n（3）默认初始化值的情况\n\n成员变量：都有默认初始化值\n\n```java\n整型（byte、short、int、long）：0\n浮点型（float、double）：0.0\n字符型（char）：0  （或'\\u0000'）\n布尔型（boolean）：false\n引用数据类型（类、数组、接口）：null\n```\n\n局部变量：**没有默认初始化值。意味着我们在使用局部变量前一定要显示初始化（赋值）**。特别的，形参，我们在调用时赋值即可。\n\n（4）在内存中加载的位置\n\n成员变量：加载到堆空间（非static）\n\n局部变量：加载到栈空间\n\n## 方法\n\n### return\n\n- 终止方法\n- 返回数据\n\n## overload\n\n- `两同一不同`\n\n> 同一个类、相同的方法名。不同的形参列表\n\n- 判断是否重载\n\n> 跟方法的权限修饰、返回值、形参变量名、方法体都没关系\n\n## 可变个数的形参\n\n1. jdk 5.0新增的内容\n\n2. 具体使用：\n\n   > 2.1 可变个数形参的格式：数据类型 ... 变量名<br>\n   >\n   > 2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，...<br>\n   >\n   > 2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载<br>\n   >\n   > 2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。<br>\n   >\n   >  2.5 可变个数形参在方法的形参中，必须声明在末尾<br>\n   >\n   >  2.6  可变个数形参在方法的形参中,最多只能声明一个可变形参<br>\n\n   \n\n","tags":["java","oop"],"categories":["java","oop"]},{"title":"Java - 基础类库","url":"/2020/11/18/Java-基础类库/","content":"\n# Scanner\n\n```java\n  Scanner sc = new Scanner(System.in);\nsc.hasNext();\nsc.next();\nsc.nextLong();\n```\n\n# System\n\n```java\n//标准输入\nSystem.in\nSystem.nanoTime();\n```\n\n# Object\n\n<br>\n\n# String、StringBuffer、StringBuilder\n\n- String类是不可变类\n- StringBuffer是线程安全的。StringBuilder是线程不安全的，但高效\n- `Java9` 改进了字符串（包括 `String、StringBuffer、StringBuilder`）的实现，在`Java9`以前字符串采用`char []` 数组来保存字符，因此字符串的每个字符占2字节；而`Java9`的字符串采用`byte [] `数组再加一个 encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。所以`Java9`的字符串更加节省空间，但字符串的功能方法没有受到任何影响\n\n# Java 7 的ThreadLocalRandom与Random\n\n- ThreadLocalRandom是Java 7 新增的一个类，是Random的增强版，在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，最终保证系统具有更好的线程安全性\n\n```java\nRandom random = new Random(System.currentTimeMillis());\nThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n```\n\n# BigDecimal\n\n","tags":["java","api"],"categories":["java","api"]},{"title":"Java - Reflection","url":"/2020/11/17/Java-Reflection/","content":"\n# 概述\n\n- Reflection(反射)是被视为动态语言的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法\n- 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个 类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。**这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为:反射**\n\n\n\n# 补充:动态语言 vs 静态语言\n\n## 动态语言\n\n- 是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运 行时代码可以根据某些条件改变自身结构。 \n\n- 主要动态语言:Object-C、C#、JavaScript、PHP、Python、Erlang\n\n## 静态语言\n\n- 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++\n- Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动 态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。 Java的动态性让编程的时候更加灵活\n\n# Java反射机制研究及应用\n\n## Java反射机制提供的功能\n\n> 在运行时判断任意一个对象所属的类\n>\n> 在运行时构造任意一个类的对象\n>\n> 在运行时判断任意一个类所具有的成员变量和方法\n>\n> 在运行时获取泛型信息\n>\n> 在运行时调用任意一个对象的成员变量和方法\n>\n> 在运行时处理注解\n>\n> 生成动态代理\n\n## 反射相关的主要API\n\n```java\njava.lang.Class:代表一个类\n  \njava.lang.reflect.Method:代表类的方法\n  \njava.lang.reflect.Field:代表类的成员变量\n  \njava.lang.reflect.Constructor:代表类的构造器\n```\n\n## 相关问题\n\n1. 通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个？\n\n> 建议：直接new的方式\n>\n> 什么时候使用反射的方式？\n>\n> 编译时候能确定具体的对象类型，则用直接new的方式。编译时不能确定对象类型（运行时才能确定对象类型）则用反射的方式\n\n2. 反射机制与面向对象的封装性是不是矛盾的？如何看待两个技术？\n\n> 不矛盾\n>\n> 面向对象的封装性解决的是一种规范和建议\n>\n> 反射机制解决的是能不能的问题\n\n## java.lang.Class\n\n在Object类中定义了以下的方法，此方法将被所有子类继承\n\n```java\npublic final Class getClass()\n```\n\n以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射 从程序的运行结果来看也很好理解，即: 可以通过对象反射求出类的名称。\n\n\n\n对象照镜子后可以得到的信息:某个类的属性、方法和构造器、某个类到底实现了哪些接 口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含 了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。\n\n> - Class本身也是一个类\n> - Class 对象只能由系统建立对象\n> - 一个加载的类在 JVM 中只会有一个Class实例\n> - 一个Class对象对应的是一个加载到JVM中的一个.class文件\n> - 每个类的实例都会记得自己是由哪个 Class 实例所生成\n> - 通过Class可以完整地得到一个类中的所有被加载的结构\n> - Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象\n\n### Class类的常用方法\n\n|                       方法名                       |                           功能说明                           |\n| :------------------------------------------------: | :----------------------------------------------------------: |\n|          static Class forName(Stringname)          |               返回指定类名 name 的 Class 对象                |\n|                Object newInstance()                |         调用缺省构造函数，返回该Class对象的一个实例          |\n|                     getName()                      | 返回此Class对象所表示的实体(类、接口、数组类、基本类型 或void)名称 |\n|               Class getSuperClass()                |              返回当前Class对象的父类的Class对象              |\n|              Class [] getInterfaces()              |                   获取当前Class对象的接口                    |\n|            ClassLoader getClassLoader()            |                      返回该类的类加载器                      |\n|               Class getSuperclass()                |           返回表示此Class所表示的实体的超类的Class           |\n|          Constructor[] getConstructors()           |            返回一个包含某些Constructor对象的数组             |\n|            Field[] getDeclaredFields()             |                   返回Field对象的一个数组                    |\n| Method getMethod(String name,Class ... paramTypes) |       返回一个Method对象，此对象的形参类型为paramType        |\n\n### 类的加载过程\n\n- 程序经过Javac.exe命令以后，会生成一个或多个字节码文件（.class结尾），接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，就作为Class的一个实例\n- 换句话说，Class的实例就对应着一个运行时类\n- 加载到内存中的运行时类会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类\n\n### 获取Class实例的四种方式\n\n```java\npublic class ReflectionTest {\n\n    @Test\n    public void testgetClass() throws ClassNotFoundException {\n        \n        // 方式一 调用运行时类的属性 .class\n        Class clazz1 = Person.class;\n        Class<Person> clazz1_1 = Person.class;\n        System.out.println(clazz1);\n        System.out.println(clazz1_1);\n\n        // 方式二 通过运行时类的对象获取\n        Person p = new Person();\n        Class clazz2 = p.getClass();\n        System.out.println(clazz2);\n\n        // 方式三 使用Class的静态方法： Class.forName(String classPath)\n        Class clazz3 = Class.forName(\"com.study.Person\");\n        System.out.println(clazz3);\n        \n        // 方式四 使用类的加载器 ClassLoader\n        ClassLoader classLoader = ReflectionTest.class.getClassLoader();\n        Class clazz4 = classLoader.loadClass(\"com.study.Person\");\n        System.out.println(clazz4);\n\n    }\n}\n```\n\n### 哪些类型可以有Class对象\n\n> (1) class: 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类\n>\n> (2) interface:接口\n>\n> (3) []:数组\n>\n> (4) enum:枚举\n>\n> (5) annotation:注解@interface\n>\n> (6) primitive type:基本数据类型\n>\n> (7) void\n\n\n\n- 理解Class类并获取Class的实例\n\n```java\n\nClass c1 = Object.class; \nClass c2 = Comparable.class;\nClass c3 = String[].class; \nClass c4 = int[][].class; \nClass c5 = ElementType.class; \nClass c6 = Override.class; \nClass c7 = int.class;\nClass c8 = void.class;\nClass c9 = Class.class;\n\nint[] a = new int[10];\nint[] b = new int[100];\nClass c10 = a.getClass();\nClass c11 = b.getClass();\n// 只要元素类型与维度一样，就是同一个Class \nSystem.out.println(c10 == c11);// true\n```\n\n# 类的加载与ClassLoader的理解\n\n\n\n## 使用ClassLoader加载配置文件\n\n```java\n   @Test\n    public void testLoadFileByClassLoader() throws IOException {\n\n        Properties properties = new Properties();\n\n//         方式一 此时文件默认在当前的module下\n//        FileInputStream fis = new FileInputStream(\"jdbc.properties\");\n//        properties.load(fis);\n\n        // 方式二 使用ClassLoader，文件路径默认为当前module的 src/main/resources 下\n        ClassLoader classLoader = this.getClass().getClassLoader();\n        InputStream is = classLoader.getResourceAsStream(\"jdbc3.properties\");\n        properties.load(is);\n\n        String user = properties.getProperty(\"name\");\n        String password = properties.getProperty(\"password\");\n        String age = properties.getProperty(\"age\");\n\n        System.out.println(\"user = \"+user+\",password = \"+password+\",age = \"+age);\n\n    }\n```\n\n\n\n# 创建运行时类的对象\n\n```java\n/**\n     * 1)类必须有一个无参数的构造器。\n     * 2)类的构造器的访问权限需要足够。\n     *\n     * 没有空参构造器会抛出 InstantiationException\n     * 权限不够抛出 InstantiationException\n     *\n     * */\n    @Test\n    public void testCreateObjectByReflection () throws InstantiationException, IllegalAccessException {\n        Class<Person> clazz = Person.class;\n        Person person = clazz.newInstance();\n        System.out.println(person);\n    }\n\n// 根据全类名获取对应的Class对象\n//1.根据全类名获取对应的Class对象\n        String name = \"atguigu.java.Person\";\n        Class clazz = null;\n        try {\n            clazz = Class.forName(name);\n            //2.调用指定参数结构的构造器，生成Constructor的实例\n            Constructor con = clazz.getConstructor(String.class,Integer.class);\n            //3.通过Constructor的实例创建对应类的对象，并初始化类属性\n            Person p2 = (Person) con.newInstance(\"Peter\",20);\n            System.out.println(p2);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n```\n\n# 获取运行时类的完 整结构\n\n- 自行查阅相关API\n\n# 调用运行时类的方法\n\n```java\n    @Test\n    public void test() throws Exception {\n        //属性\n        Class clazz = Person.class;\n        Person p = (Person) clazz.newInstance();\n\n        Field name = clazz.getDeclaredField(\"name\");\n        name.setAccessible(true);\n\n        name.set(p,\"章三\");\n//        System.out.println(name.get(p));\n//        System.out.println(p.getName());\n\n        //method\n        Method method = clazz.getDeclaredMethod(\"showName\", String.class);\n        Object res = method.invoke(p,\"海绵宝宝\");\n//        System.out.println(res);\n\n        //constructure\n        Constructor constructor = clazz.getDeclaredConstructor(String.class);\n        Person p2 = (Person) constructor.newInstance(\"小李\");\n        System.out.println(p2);\n    }\n```\n\n","tags":["java","reflection"],"categories":["java","reflection"]},{"title":"java - annotation","url":"/2020/11/17/java-annotation/","content":"\n# 概述\n\n- 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)\n\n- Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加 载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员 可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证 或者进行部署\n- Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中\n\n# 基本注解\n\n```java\n/* 作用：告诉编译器检查这个方法，保证父类包含一个被该方法重写的方法，否则就会编译出错。可以帮助程序员避免一些低级错误*/\n@Override\n/** java9 为@Deprecated增加了两个属性，\n\t\tforRemoveal：该boolean类型的属性指定该api在将来是否会被删除\n\t\tsince：该String类型的属性指定该api从哪个版本标记为过时\n*/\n@Deprecated\n@Deprecated(since=\"7\",forRemoval=true)\n\n@SuppressWarnings\n\n/* java7新增\n\t\t抑制“堆污染”警告\t\n*/\n@SafeVarargs\n\n/* java8新增*/\n@FunctionalInterface\n\n```\n\n","tags":["java","annotation"],"categories":["java","annotation"]},{"title":"java - 泛型","url":"/2020/11/12/java-泛型/","content":"\n# 概念\n\n> 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类 型或者是某个方法的返回值及参数类型。这个类型参数将在使用时(例如， 继承或实现这个接口，用这个类型声明变量、创建对象时)确定(即传入实 际的类型参数，也称为类型实参)。\n\n- JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持， 从而可以在声明集合变量、创建集合对象时传入类型实参\n\n","tags":["java","generic"],"categories":["java","generic"]},{"title":"DataStructure - List","url":"/2020/11/09/DataStructure-List/","content":"\n# LeetCode\n\n## Easy\n\n[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\n\n## Medium\n\n[92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\n\n","tags":["data-structure","algorithm"],"categories":["data-structure","algorithm"]},{"title":"《尚硅谷Netty视频教程》study notes","url":"/2020/11/02/《尚硅谷Netty视频教程》study-notes/","content":"\n# 备注\n\n> 写过的程序多敲几遍\n\n","tags":["netty"],"categories":["netty"]},{"title":"git","url":"/2020/10/30/git/","content":"\n# 将本地项目上传到Github\n\n```git\ncd [project dir]\n\n# 把这个文件夹变成Git可管理的仓库\ngit init \n\ngit add ./\n\ngit commit -m'add'\n\n# 在Github上创建一个Git仓库\n\n# 在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了。注意origin后面加的是你Github上创建好的仓库的地址\ngit remote add origin [your github repo addr]\n\n# 关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上\ngit push -u origin master\n\n# 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了\ngit push origin master\n\n# 有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to https://github.com/xxx/xxx.git的错\n\n# 这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并\ngit pull --rebase origin master\n```\n\n","tags":["git"],"categories":["git"]},{"title":"Java training camp study notes - jvm","url":"/2020/10/15/Java-training-camp-study-notes-jvm/","content":"\n\n\n# 概述\n\n## 目录\n\n> 1. JVM基础知识:不积跬步，无以至千里\n> 2. Java字节码技术:不积细流，无以成江河 \n> 3. JVM类加载器:山不辞土，故能成其高\n> 4. JVM内存模型:海不辞水，故能成其深\n> 5. JVM启动参数:博观而约取、厚积而薄发\n> 6. 第一节课总结回顾与作业实践\n\n## 编程语言\n\n- 机器语言 -> 汇编语言 -> 高级语言\n\n> 面向过程、面向对象、面向函数\n>\n> 静态类型、动态类型\n\n## 字节码、类加载器、虚拟\n\n\n\n\n\n# Java字节码技术\n\n- Java bytecode 由单字节(byte)的指令组成，理论上最多支持 256 个操作码(opcode)。实 际上Java只使用了200左右的操作码， 还有一些操作码则保留给调试操作\n\n","tags":["java","jvm"],"categories":["java","jvm"]},{"title":"Java training camp study notes","url":"/2020/10/15/Java-training-camp-study-notes/","content":"\n","tags":["java"],"categories":["java"]},{"title":"git study notes","url":"/2020/10/13/git-study-notes/","content":"\n# 配置\n\n```git\n# 显示config的配置，三个作用域\n# 优先级 local > global > system\ngit config --local --list\ngit config --global --list\ngit config --system --list\n```\n\n配置**user.name**和**user.email**\n\n```git\ngit config --global user.name ‘your_name’\ngit config --global user.email ‘your_email@domain.com’\n\n# 清除，--unset\ngit config --unset --local user.name\ngit config --unset --global user.name\n```\n\n","tags":["git"],"categories":["git"]},{"title":"java - 环境准备","url":"/2020/10/12/java-环境准备/","content":"\n# JDK、JRE、JVM的关系\n\n## JDK\n\nJDK(Java Development Kit) 是用于开发 Java 应用程序的软件开发工具集合，包括 了 Java 运行时的环境(JRE)、解释器(Java)、编译器(javac)、Java 归档 (jar)、文档生成器(Javadoc)等工具。简单的说我们要开发Java程序，就需要安 装某个版本的JDK工具包。\n\n## JRE\n\nJRE(Java Runtime Enviroment )提供 Java 应用程序执行时所需的环境，由 Java 虚拟机(JVM)、核心类、支持文件等组成。简单的说，我们要是想在某个机器上运 行Java程序，可以安装JDK，也可以只安装JRE，后者体积比较小。\n\n## JVM\n\nJava Virtual Machine(Java 虚拟机)有三层含义，分别是:\n\n- JVM规范要求\n- 满足 JVM 规范要求的一种具体实现(一种计算机程序)\n-  一个 JVM 运行实例，在命令提示符下编写 Java 命令以运行 Java 类时，都会创建一 个 JVM 实例，我们下面如果只记到JVM则指的是这个含义;如果我们带上了某种JVM 的名称，比如说是Zing JVM，则表示上面第二种含义\n\n# JDK 与 JRE、JVM 之间的关系\n\n就范围来说，JDK > JRE > JVM:\n\n- JDK = JRE + 开发工具\n- JRE = JVM + 类库\n\n<img src=\"14805043-171ef9e473a9f85d.webp\" />\n\n## 三者在开发运行Java程序时的交互关系:\n\n简单的说，就是通过JDK开发的程序，编译以后，可以打包分发给其他装有JRE的机器上去运行。而运行的程序，则是通过java命令启动的一个JVM实例，代码逻辑的执行都运行在这 个JVM实例上\n\n## Java程序的开发运行过程为:\n我们利用 JDK (调用 Java API)开发Java程序，编译成字节码或者打包程序 然后可以用 JRE 启动一个JVM实例，加载、验证、执行 Java 字节码以及依赖库， 运行Java程序而JVM 将程序和依赖库的Java字节码解析并变成本地代码执行，产生结果\n\n# jdk安装、环境配置、管理（mac OS）\n\n## 使用jenv管理jdk版本\n\n（1）oracle官网下载需要的jdk版本（这里使用解压缩版本）\n\n（2）[下载jenv](https://www.jenv.be/)\n\n（2）将jdk添加到jenv管理\n\n```linux\n# jenv add $JAVA_HOME\n\njenv add /Users/sorozy/Documents/dev/conf/jdk/jdk1.8.0_191.jdk/Contents/Home\njenv add /Users/sorozy/Documents/dev/conf/jdk/jdk-11.0.8.jdk/Contents/Home\njenv add /Users/sorozy/Documents/dev/conf/jdk/jdk-14.0.2.jdk/Contents/Home\n```\n\n（3）查看、切换、设置\n\n```linux\n# 查看现有jdk版本\njenv versions\n\n# 切换jdk版本\njenv local 1.8\n\n# 设置全局jdk版本\njenv global jdk11\n```\n\n\n\n","tags":["java"]},{"title":"《全面掌握MongoDB4.0》study notes","url":"/2020/10/04/《全面掌握MongoDB4-0》study-notes/","content":"\n\n\n","tags":["database","mongodb"],"categories":["database","mongodb"]},{"title":"List/链表","url":"/2020/09/28/List-链表/","content":"\n\n\n- 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的\n\n- This is a test","tags":["data-structure","list"]},{"title":"java - io","url":"/2020/09/24/java-io/","content":"\n# 学习备注\n\n> 有空可以研究一下读写方法的内部\n>\n> file部分的作业记得一定完成一下\n>\n> p602 600这块关于字符集的内容可以认真看一下\n>\n> p603的题目记得写一下\n\n\n\n# File类使用\n\n## 简介\n\n- java.io.File类:文件和文件目录路径的抽象表示形式，与平台无关\n- File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。 如果需要访问文件内容本身，则需要使用输入/输出流。\n- 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。\n- File对象可以作为参数传递给流的构造器\n\n## construtor\n\n```java\n// 以pathname为路径创建File对象，可以是绝对路径或者相对路径\npublic File(String pathname)\n  \n// 以parent为父路径，child为子路径创建File对象。\npublic File(String parent,String child)\n  \n// 根据一个父File对象和子文件路径创建File对象\npublic File(File parent,String child)\n```\n\n## 路径分隔符\n\n- 路径中的每级目录之间用一个路径分隔符隔开\n\n-  路径分隔符和系统有关:\n\n  - windows和DOS系统默认使用“\\”来表示\n\n  - UNIX和URL使用“/”来表示\n\n- 根据操作系统，动态的提供分隔符\n\n```java\npublic static final String separator\n\n// 举例\nFile file = new File(\"d:\" + File.separator + \"test\" + File.separator + \"info.txt\");\n```\n\n## 常用方法\n\n### get\n\n```java\npublic String getAbsolutePath()\t//获取绝对路径\n  \npublic String getPath() //获取路径\n\npublic String getName() //获取名称\n  \npublic String getParent() //获取上层文件目录路径。若无，返回null\n  \npublic long length() //获取文件长度(即:字节数)。不能获取目录的长度。\n  \npublic long lastModified() //获取最后一次的修改时间，毫秒值\n  \npublic String[] list() //获取指定目录下的所有文件或者文件目录的名称数组\n  \npublic File[] listFiles() //获取指定目录下的所有文件或者文件目录的File数组\n```\n\n### rename\n\n```java\npublic boolean renameTo(File dest) //把文件重命名为指定的文件路径\n// 比如 file1.renameTo(file2); 想要保证返回true，则需要保证file1在硬盘中是存在的，file2在硬盘中是不存在的\n```\n\n### judgment\n\n```java\npublic boolean isDirectory() // 判断是否是文件目录\n  \npublic boolean isFile() //判断是否是文件\n  \npublic boolean exists() //判断是否存在\n  \npublic boolean canRead() //判断是否可读\n  \npublic boolean canWrite() //判断是否可写\n  \npublic boolean isHidden() //判断是否隐藏\n```\n\n### create\n\n```java\npublic boolean createNewFile() //创建文件。若文件存在，则不创建，返回false\n  \npublic boolean mkdir() //创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。\n  \npublic boolean mkdirs() //创建文件目录。如果上层文件目录不存在，一并创建\n\n//注意事项:如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目 路径下。\n```\n\n### delete\n\n```java\npublic boolean delete() //删除文件或者文件夹\n\n// 删除注意事项:\n// Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录\n```\n\n# IO流原理及流的分类\n\n## java io原理\n\n- I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于 处理设备之间的数据传输。如读/写文件，网络通讯等\n- Java程序中，对于数据的输入/输出操作以“流**(stream)**” 的 方式进行。\n- java.io包下提供了各种“流”类和接口，用以获取不同种类的 数据，并通过标准的方法输入或输出数据。\n\n\n\n- 输入**input**:读取外部数据(磁 盘、光盘等存储设备的数据)到 程序(内存)中。\n- 输出**output**:将程序(内存) 数据输出到磁盘、光盘等存储设 备中。\n\n\n\n## 流的分类\n\n- 按操作数据单位不同分为:字节流**(8 bit)**，字符流**(16 bit)**\n- 按数据流的流向不同分为:输入流，输出流\n- 按流的角色的不同分为:节点流，处理流\n\n| (抽象基类) |    字节流    | 字符流 |\n| :--------: | :----------: | :----: |\n|   输入流   | InputStream  | Reader |\n|   输出流   | OutputStream | Writer |\n\n## io流体系\n\n<img src=\"WechatIMG698.png\" />\n\n## 节点流和处理流\n\n- 节点流:直接从数据源或目的地读写数据\n- 处理流:不直接连接到数据源或目的地，而是“连接”在已存 在的流(节点流或处理流)之上，通过对数据的处理为程序提 供更为强大的读写功能。\n\n## InputStream & Reader\n\n- InputStream 和 Reader 是所有输入流的基类\n- 程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资 源，所以应该显式关闭文件 **IO** 资源。\n- FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader\n\n```java\n//从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因 为已经到达流末尾而没有可用的字节，则返回值 -1。\nint read()\n\n//从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已 经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取 的字节数。\nint read(byte[] b)\n\n//将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于 文件末尾而没有可用的字节，则返回值 -1。  \nint read(byte[] b, int off,int len)\n\n// 关闭此输入流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n```java\n// 读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)(2个 字节的Unicode码)，如果已到达流的末尾，则返回 -1\nint read()\n\n// 将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。\nint read(char[] cbuf)\n\n// 将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字 符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。\nint read(char[] cbuf,int off,int len) \n  \n// 关闭此输入流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n## OutputStream & Writer\n\n- 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组， 即以 String 对象作为参数\n- **void write(String str);**\n- **void write(String str, int off, int len);**\n- FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter\n\n```java\n// 将指定的字节写入此输出流。write 的常规协定是:向输出流写入一个字节。要写 入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。\nvoid write(int b)\n\n// 将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是:应该 与调用 write(b, 0, b.length) 的效果完全相同。\nvoid write(byte[] b)\n\n// 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。\nvoid write(byte[] b,int off,int len)\n\n// 刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。\npublic void flush()throws IOException\n  \n// 关闭此输出流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n```java\n//写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即 写入0 到 65535 之间的Unicode码。\nvoid write(int c)\n\n//写入字符数组。\nvoid write(char[] cbuf)\n\n// 写入字符数组的某一部分。从off开始，写入len个字符\nvoid write(char[] cbuf,int off,int len) \n\n// 写入字符串。\nvoid write(String str)\n\n// 写入字符串的某一部分。\nvoid write(String str,int off,int len)\n\n// 刷新该流的缓冲，则立即将它们写入预期目标。\nvoid flush()\n\n// 关闭此输出流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n## 节点流\n\n### 节点流**(**文件流**)**:注意点\n\n> 定义文件路径时，注意:可以用“/”或者“\\\\”。\n>\n> 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文 件将被覆盖。\n>\n> 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖， 在文件内容末尾追加内容。\n>\n> 在读取文件时，必须保证该文件已存在，否则报异常。\n>\n> 字节流操作字节，比如:.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt\n>\n> 字符流操作字符，只能操作普通文本文件。最常见的文本文 件:.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。\n\n### 字符流\n\n- 使用字符流复制（拷贝）文本文件\n\n```java\n    public static void copyFile (File srcFile, File destFile) {\n      \t// 1.创建流对象，将（已存在的）文件加载进流。\n        FileReader fileReader = null;\n        FileWriter fileWriter = null;\n        try {\n            fileReader = new FileReader(srcFile);\n            fileWriter = new FileWriter(destFile);\n          \n\t\t\t\t// 2.创建临时存放数据的数组。\n            char [] cbuf = new char[5];\n            int len = 0;\n          \n        // 3.调用流对象的读取方法将流中的数据读入到数组中（写入到文件中）。\n            while ((len = fileReader.read(cbuf)) != -1) {\n                fileWriter.write(cbuf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n        // 4.关闭流资源\n            if (fileReader != null){\n                try {\n                    fileReader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (fileWriter != null) {\n                try {\n                    fileWriter.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n### 字节流\n\n- 使用字节流复制（拷贝）二进制文件\n\n```java\n    public static void copy2File (File srcFile, File destFile){\n      // 1.创建流对象，将（已存在的）文件加载进流。\n        FileInputStream fileInputStream = null;\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileInputStream = new FileInputStream(srcFile);\n            fileOutputStream = new FileOutputStream(destFile);\n\t\t\t// 2.创建临时存放数据的数组。\n            byte [] buf = new byte[5];\n            int len;\n      // 3.调用流对象的读取方法将流中的数据读入到数组中（写入到文件中）。\n            while ((len = fileInputStream.read(buf)) != -1){\n                fileOutputStream.write(buf,0,len);\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\t\t\t// 4.关闭流资源\n            if (fileInputStream != null) {\n                try {\n                    fileInputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (null != fileOutputStream ) {\n                try {\n                    fileOutputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n## 处理流\n\n### 缓冲流\n\n- 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区\n- 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区\n- 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从 文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中 读取下一个8192个字节数组。\n- 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法 flush()可以强制将缓冲区的内容全部写入输出流\n- 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也 会相应关闭内层节点\n- flush()方法的使用:手动将buffer中内容写入文件\n- 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷 新缓冲区，关闭后不能再写出\n\n\n\n- 使用缓冲流（字节型）复制文件\n\n```java\npublic static void copyFileByBufferedInputStream(File srcFile,File destFile) {\n        // 1、创建缓冲流（字节型）\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(srcFile));\n            bos = new BufferedOutputStream(new FileOutputStream(destFile));\n        // 2、创建零时数组 存放缓冲数据\n            byte [] buffered = new byte[1024];\n            int len = 0;\n            while ((len = bis.read(buffered)) != -1){\n                bos.write(buffered,0,len);\n            }\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n\n        // 3、关闭资源（先关闭外层，再关闭内层）关闭外层流的时候，内层流也会自动关闭，我们可以省略\n            if(bis!=null) {\n                try {\n                    bis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (bos != null) {\n                try {\n                    bos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n### 转换流\n\n- 转换流提供了在字节流和字符流之间的转换\n\n- Java API提供了两个转换流\n\n  > InputStreamReader:将InputStream转换为Reader\n  >\n  > OutputStreamWriter:将Writer转换为OutputStream\n\n- 字节流中的数据都是字符时，转成字符流操作更高效\n- 很多时候我们使用转换流来处理文件乱码问题。实现编码和 解码的功能\n\n#### InputStreamReader\n\n```java\n// 实现将字节的输入流按指定字符集转换为字符的输入流\n// 需要和InputStream“套接”\n\npublic InputStreamReader(InputStream in)\n  \npublic InputSreamReader(InputStream in,String charsetName)\n```\n\n#### OutputStreamWriter\n\n```java\n// 实现将字符的输出流按指定字符集转换为字节的输出流\n// 需要和OutputStream“套接”\n\npublic OutputStreamWriter(OutputStream out)\n  \npublic OutputSreamWriter(OutputStream out,String charsetName)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---","tags":["java","io"],"categories":["java","io"]},{"title":"《编程必备基础－大话HTTP协议》study notes","url":"/2020/09/22/《编程必备基础－大话HTTP协议》study-notes/","content":"\n# 学习备注\n\n>  ssession 和 cookie 的底层工作原理需要深入理解一下\n\n# 前言\n\n> 1. 学习了慕课网的《编程必备基础－大话HTTP协议》课程，本篇文章是学习笔记。以便温习\n\n# HTTP基础\n\n## http协议简介\n\n- **超文本传输协议**（英语：**H**yper**T**ext **T**ransfer **P**rotocol，缩写：**HTTP**）\n- 一种用于分布式、协作式和超媒体信息系统的应用层协议，（属于应用层面向对象的协议）\n- 设计HTTP最初的目的是为了提供一种发布和接收[HTML](https://zh.wikipedia.org/wiki/HTML)页面的方法。通过HTTP或者[HTTPS](https://zh.wikipedia.org/wiki/HTTPS)协议请求的资源由[统一资源标识符](https://zh.wikipedia.org/wiki/统一资源标志符)（Uniform Resource Identifiers，URI）来标识。\n\n\n\n- web\n\n> web是一种基于超文本和http的全球性的、动态交互的、跨平台的分布式图形信息系统\n\n## http协议历史版本\n\n- 版本\n\n> 超文本传输协议已经演化出了很多版本，它们中的大部分都是[向下兼容](https://zh.wikipedia.org/wiki/向下兼容)的。在 [RFC 2145](https://tools.ietf.org/html/rfc2145) 中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。\n\n- HTTP/0.9（1991年）\n\n> 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。\n\n- HTTP/1.0（1996年5月）\n\n>  这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在[代理服务器](https://zh.wikipedia.org/wiki/代理服务器)中\n\n- HTTP/1.1（1997年1月）\n\n> 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以[管道方式](https://zh.wikipedia.org/wiki/HTTP管线化)在同时发送多个请求，以便降低线路负载，提高传输速度。\n>\n> HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：\n>\n> - 缓存处理\n> - 带宽优化及网络连接的使用\n> - 错误通知的管理\n> - 消息在网络中的发送\n> - 互联网地址的维护\n> - 安全性及完整性\n\n- HTTP/2（2015年5月）\n\n> 于2015年5月作为互联网标准正式发布。\n\n- HTTP 3.0 / QUIC协议\n\n## TCP/IP\n\n- HTTP协议是构建在TCP/IP协议之上的，是TCP/IP协议的一个子集\n\n- TCP/IP协议族\n\n> tcp/ip协议其实是一系列与互联网相关联的协议集合起来的总称\n>\n> 分层管理是tcp/ip协议的重要特征\n\n### tcp/ip协议族分层\n\n| 分层       | 说明                                                         | 举例                           |\n| ---------- | ------------------------------------------------------------ | ------------------------------ |\n| 应用层     | 应用层一般是我们编写的应用程序，决定了向用户提供的用户服务，应用层可以通过系统调用与传输层进行通信 | ftp、dns、http                 |\n| 传输层     | 传输层通过系统调用向应用层提供处于网络连接中的两台计算机的数据传输功能 | tcp（面向连接）、udp（无连接） |\n| 网络互联层 | 网络层用来处理网络上流动的数据包，数据包是网络上数据传输的最小数据单位，该层规定了通过怎样的路径（传输线路）到达对方计算机，并把数据包传输给对方 |                                |\n| 数据链路层 | 链路层用来处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动NIC以及光纤等物理可以见部分，硬件上的范畴均在链路层的作用范围之内 |                                |\n\n### 数据包的封装过程\n\n<img src=\"tcpip.datagram.png\" width=\"80%\" />\n\n## HTTP数据传输过程\n\n- 使用tcp协议进行通信的双方必须先建立连接，然后才能开始传输数据，为了确保连接双方可靠性，在建立连接时，tcp协议采用了三次握手策略。\n\n<img src=\"WechatIMG660.png\" width=\"80%\" /><br>\n\n<img src=\"WechatIMG661.png\" width=\"80%\" />\n\n## 传输层 TCP三次握手\n\n<img src=\"daMoW6HkaxYhGW6o.png__original\" width=\"80%\" />\n\n- 第一次握手\n\n> 客户端发送SYN标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。 \n>\n> 服务端接收到信息后，此时，**服务端知道**：*客户端可以成功发送数据，服务端可以接受数据*\n\n- 第二次握手\n\n> 服务端接收到客户端的SYN报文段后，需要发送ACK信息对这个SYN报文段进行确认，同时还要发送自己的SYN请求信息。服务端会将上述的信息放到一个报文段（SYN+ACk报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECEIVED状态 \n>\n> 客户端接收到信息后，此时，**客户端知道**：*自己可以发送数据，可以接收数据，服务端可以接收数据，服务端可以发送数据*\n\n- 第三次握手\n\n> 客户端接收到服务端的SYN+ACK报文段后，会向服务端发送ACK确认报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED状态，完成tcp三次握手\n>\n> 服务端接收到信息后，服务端知道自己可以成功发送数据，客户端可以接收数据\n\n- 三次握手的意义\n\n> 服务端和客户端都确认彼此都能成功发送和接收数据\n\n## DNS\n\n- dns服务提供 域名到ip地址之间的解析服务\n- cdn负责转发（可以设置是否转发）\n- dns服务\n\n> 系统配置文件\n>\n> 本地dns服务\n>\n> 高级dns服务\n>\n> 根dns服务\n\n# HTTP协议结构和通讯原理\n\n## http协议特点\n\n- 支持客户/服务器模式\n\n> 由客户端向服务器发出请求，服务器端响应请求，并进行相应服务\n\n- 简单快速\n\n> 客户向服务器请求服务时，只需传送请求方法和路径\n>\n> http协议简单，使得http服务器的程序规模小，通信速度快\n\n- 灵活\n\n> http允许传输任意类型的对象\n>\n> 正在传输的数据类型由Content-Type标记\n\n- 无连接\n\n> 无连接的含义是：限制每次连接只处理一个请求\n>\n> 服务器处理完客户端的请求，并收到客户端的应答后即断开连接\n>\n> 采用这种方式可以节省传输时间\n\n- 无状态\n\n> http协议是无状态协议\n>\n> 无状态是指协议对事物处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则必须重传，这样可能导致每次每次连接传送的数据量增大\n>\n> 在服务区不需要先前的信息时，它应答就快\n\n## URI & URL & URN\n\n### URI\n\n> **统一资源标识符**（英语：**U**niform **R**esource **I**dentifier，缩写：**URI**）在[电脑](https://zh.wikipedia.org/wiki/電腦)术语中是一个用于[标识](https://zh.wikipedia.org/wiki/标识)某一[互联网](https://zh.wikipedia.org/wiki/互联网)[资源](https://zh.wikipedia.org/wiki/资源)名称的[字符串](https://zh.wikipedia.org/wiki/字符串)\n>\n> a URI 可以进一步分为定位符、名字或者两者都是\n>\n> URI可以分为URl 和 URN，或者同时具备locators和names特性的一个东西\n\n### URL\n\n> Uniform Resource Locator（URL）是URI的子集，除了确定一个资源，还提供一种该资源的主要访问机制（如网络“位置”）\n\n### URN\n\n> URN是唯一标识的一部分，是身份信息\n\n<br>\n\n> URL是URI的一种\n>\n> URI和URL最大的差别是访问机制\n>\n> URN的作用就好像一个人的名字，URL就好像一个人的地址\n>\n> URN确定了东西的身份，URL提供了找到它的方式\n\n## HTTP报文结构\n\n<img src=\"oBhtzgH1zfetmRvb__original.png\" width=\"80%\" />\n\n<img src=\"image.png__original\" width=\"80%\" />\n\n<img src=\"6fkx0BHVtqGmBT9K.png__original\" width=\"80%\" />\n\n### HTTP报文头\n\n- 在HTTP1.1里一共规范了47种报文头字段\n\n#### 通用报文头\n\n<img src=\"WechatIMG662.png\" width=\"80%\" />\n\n#### 请求报文头\n\n<img src=\"WechatIMG663.png\" width=\"80%\" />\n\n#### 响应报文头\n\n<img src=\"WechatIMG664.png\" width=\"80%\" />\n\n#### 实体报文头\n\n<img src=\"WechatIMG665.png\" width=\"80%\" />\n\n#### 常用报文头解析\n\n- Accept\n\n| 作用   | 浏览器可以接收的媒体类型                                     |\n| ------ | ------------------------------------------------------------ |\n| 举例   | Accept: text/html （代表浏览器可以接受的返回类型为text/html，也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务区应该返回一个406错误（Non Acceptable）） |\n|        | Accept: \\*/\\* （代表浏览器可以处理所有类型）                 |\n| 优先级 | 如果想要给显示的媒体类型增加优先级，则使用q= 来额外表示权重值；q的范围是0～1，（可精确到小数点后3位）。且1为最大值。不指定权重q值时，默认权重q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型 |\n\n- Accept-Encoding\n\n| 作用 | 浏览器申明自己的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） |\n| ---- | ------------------------------------------------------------ |\n| 举例 | Accept-Encoding: gzip,deflate;                               |\n\n- Accept-Language\n\n| 作用 | 浏览器申明自己接收的语言                       |\n| ---- | ---------------------------------------------- |\n| 举例 | Accept-Language: zh-cn,zh,q=0.7,en-us,en,q=0.3 |\n\n- Connection\n\nConnection: kite-alive;（当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接）\n\nConnection: close;\n\n- Host\n\n作用：请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来\n\n- Referer\n\n当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的。服务器藉此可以获得一些信息用于处理\n\n- User-Agent\n\n作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本\n\n- Content-Type\n\n作用：说明了报文体内对象的媒体类型\n\n常见的媒体格式类型如下：\n\n- text/html ： HTML格式\n- text/plain ：纯文本格式\n- text/xml ： XML格式\n- image/gif ：gif图片格式\n- image/jpeg ：jpg图片格式\n- image/png：png图片格式\n\n以application开头的媒体格式类型：\n\n- application/xhtml+xml ：XHTML格式\n- application/xml： XML数据格式\n- application/atom+xml ：Atom XML聚合格式\n- application/json： JSON数据格式\n- application/pdf：pdf格式\n- application/msword ： Word文档格式\n- application/octet-stream ： 二进制流数据（如常见的文件下载）\n- application/x-www-form-urlencoded ： \\<form encType=\"\">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）\n\n另外一种常见的媒体格式是上传文件之时使用的：\n\n- multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式\n\n## HTTP请求方法\n\n### HTTP状态码分类\n\n| 分类 | 分类描述                                       |\n| :--- | :--------------------------------------------- |\n| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |\n| 2**  | 成功，操作被成功接收并处理                     |\n| 3**  | 重定向，需要进一步的操作以完成请求             |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\n\n### HTTP状态码列表\n\n| 状态码 | 状态码英文名称                  | 中文描述                                                     |\n| ------ | ------------------------------- | ------------------------------------------------------------ |\n| 100    | Continue                        | 继续。客户端应继续其请求                                     |\n| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |\n|        |                                 |                                                              |\n| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |\n| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |\n| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |\n| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |\n| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |\n| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |\n| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |\n|        |                                 |                                                              |\n| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |\n| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |\n| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |\n| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |\n| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |\n| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |\n|        |                                 |                                                              |\n| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |\n| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |\n| 402    | Payment Required                | 保留，将来使用                                               |\n| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |\n| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 |\n| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |\n| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |\n| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |\n| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |\n| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |\n| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |\n| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |\n| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |\n| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |\n| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |\n| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |\n| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |\n| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |\n|        |                                 |                                                              |\n| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |\n| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |\n| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |\n| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |\n| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |\n| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |\n\n## Cookie & Session\n\n\n\n# 深入认识HTTP协议不为人知的特性和使用\n\n\n\n---","tags":["http","network"],"categories":["http","network"]},{"title":"《新版Nginx体系化深度精讲》study notes","url":"/2020/09/16/《新版Nginx体系化深度精讲》study-notes/","content":"\n# 学习备注\n\n> 总结出自己的思维脑图\n\n# 前言\n\n> 1. 学习了慕课网的《新版Nginx体系化深度精讲，从青铜到王者的飞跃》课程，本篇文章是学习笔记。以便温习\n\n# 初识Nginx\n\n## 学习Nginx的三个理由\n\n> 1. 应用广泛，大厂和小厂必用的WEB组件\n> 2. 前后端、运维必知必会技能之一\n> 3. 性能优化，进阶高级工程师\n\n## 学习后收获\n\n> 部署前端项目，反向代理nodejs\n>\n> 反向代理java、python等，负载均衡\n>\n> 协调前后端，故障排查，性能优化\n\n## Nginx概念\n\n​\t\tNginx* (engine x) 是一个高性能的[HTTP](https://baike.baidu.com/item/HTTP)和[反向代理](https://baike.baidu.com/item/反向代理/7793488)web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为[俄罗斯](https://baike.baidu.com/item/俄罗斯/125568)访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n\n​\t\t其将[源代码](https://baike.baidu.com/item/源代码)以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而[闻名](https://baike.baidu.com/item/闻名/2303308)。2011年6月1日，nginx 1.0.4发布。\n\n​\t\tNginx是一款[轻量级](https://baike.baidu.com/item/轻量级/10002835)的[Web](https://baike.baidu.com/item/Web/150564) 服务器/[反向代理](https://baike.baidu.com/item/反向代理/7793488)服务器及[电子邮件](https://baike.baidu.com/item/电子邮件/111106)（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，[并发](https://baike.baidu.com/item/并发/11024806)能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、[京东](https://baike.baidu.com/item/京东/210931)、[新浪](https://baike.baidu.com/item/新浪/125692)、[网易](https://baike.baidu.com/item/网易/185754)、[腾讯](https://baike.baidu.com/item/腾讯/112204)、[淘宝](https://baike.baidu.com/item/淘宝/145661)等。\n\n## Nginx为什么出现并如此流行\n\n- 互联网数据的快速增长\n- Apache请求处理的低效性\n\n### Nginx相较于Apache的优势\n\n|        Apache        |        Nginx         |\n| :------------------: | :------------------: |\n| 一个进程处理一个请求 | 一个进程处理多个请求 |\n|       阻塞式的       |      非阻塞式的      |\n\n## Nginx处理请求过程\n\n<img src=\"WechatIMG550.png\" width=\"80%\" />\n\n## 三个常见应用场景\n\n1. 静态资源服务\n2. 反向代理服务\n3. API服务\n\n## 优势特点\n\n- 高并发、高性能\n- 扩展性好\n- 异步非阻塞的事件驱动模型\n\n## 简单安装\n\n- linux环境准备\n\n> Centos7\n\n```linux\nyum install epel-release -y\n\nyum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake\n\nyum -y install wget httpd-tools vim\n\nyum list all | grep nginx\n\nyum install nginx -y\n\n# 列出包里的所有文件\nrpm -ql nginx\n\nrpm -ql nginx | grep bin\n```\n\n## Linux信号量\n\n```linux\n# 列出linux所有信号量\nkill -l\n```\n\n## 利用信号量管理Nginx进程\n\n- Master进程\n\n<img src=\"WechatIMG606.png\" width=\"80%\" />\n\n- Woker进程\n\n<img src=\"WechatIMG607.png\" width=\"80%\" />\n\n- 命令行\n\n<img src=\"WechatIMG608.png\" width=\"80%\" />\n\n> Nginx会监测当前环境有几个cpu，就会启动几个woker进程（当nginx.conf 的 **worker_processes** 配置为 `auto`时，即没有指定**worker_processes**的数量时），每个worker进程都会绑定到一颗cpu上\n\n```linux\n# 查看linux cpu 相关信息\nlscpu\n\n# 杀死（关闭）master进程\nkill -s SIGTERM pid[master进程pid]\n\n# 重新读取配置文件关闭旧的worker进程，开启新的worker进程\nkill -s SIGHUP pid[master进程pid]\n\n```\n\n## reload重载配置文件的流程\n\n1. 向master进程发送HUP信号（reload命令）\n2. master进程检查配置语法是否正确\n3. master进程打开监听端口\n4. master进程使用新的配置文件启动新的worker子进程\n5. master进程向老的woker子进程发送QUIT信号\n6. 旧的work进程关闭监听句柄，处理完当前连接后关闭进程\n\n<img src=\"WechatIMG609.png\" width=\"80%\" />\n\n## Nginx热部署\n\n1. 将旧的Nginx文件替换成新的Nginx文件\n2. 向mstaer进程发送USR2信号\n3. master进程修改pid文件，加后缀.oldbin\n4. master进程用新nginx文件启动新master进程\n5. 向旧的master进程发送WINCH信号，旧的worker子进程退出\n6. 回滚情形：向旧master发送HUP，向新的master发送QUIT\n\n<img src=\"WechatIMG610.png\" width=\"80%\" />\n\n- Nginx热部署演示\n\n```linux\n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     1776  1775  0 11:11 ?        00:00:00 nginx: worker process\nnginx     1777  1775  0 11:11 ?        00:00:00 nginx: worker process\nroot      2078  1460  0 11:21 pts/0    00:00:00 grep --color=auto nginx\n\n\n[root@sorozy run]# kill -s SIGUSR2 1775\n[root@sorozy run]# \n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     1776  1775  0 11:11 ?        00:00:00 nginx: worker process\nnginx     1777  1775  0 11:11 ?        00:00:00 nginx: worker process\nroot      2146  1775  0 11:22 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2147  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2148  2146  0 11:22 ?        00:00:00 nginx: worker process\nroot      2159  1460  0 11:22 pts/0    00:00:00 grep --color=auto nginx\n\n\n[root@sorozy run]# kill -s SIGWINCH 1775\n[root@sorozy run]# \n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nroot      2146  1775  0 11:22 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2147  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2148  2146  0 11:22 ?        00:00:00 nginx: worker process\nroot      2201  1460  0 11:23 pts/0    00:00:00 grep --color=auto nginx\n\n##（1） 回滚\n[root@sorozy run]# kill -s SIGHUP 1775\n[root@sorozy run]# \n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nroot      2146  1775  0 11:22 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2147  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2148  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2280  1775  0 11:25 ?        00:00:00 nginx: worker process\nnginx     2281  1775  0 11:25 ?        00:00:00 nginx: worker process\nroot      2285  1460  0 11:25 pts/0    00:00:00 grep --color=auto nginx\n\n\n[root@sorozy run]#  kill -s SIGQUIT 2146\n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2280  1775  0 11:25 ?        00:00:00 nginx: worker process\nnginx     2281  1775  0 11:25 ?        00:00:00 nginx: worker process\nroot      2355  1460  0 11:26 pts/0    00:00:00 grep --color=auto nginx\n\n## (2) 删除不需要的old进程\nkill -s SIGQUIT 1775\n```\n\n## 模块化设计机制\n\n- 模块结构图\n\n<img src=\"WechatIMG611.png\" width=\"80%\" />\n\n- 模块体系结构\n\n<img src=\"WechatIMG612.png\" width=\"80%\" />\n\n## Nginx编译安装配置参数\n\n- 常用配置参数\n\n<img src=\"WechatIMG613.png\" width=\"80%\" />\n\n## 定制编译安装Nginx\n\n- 环境准备\n\n```linux\ncentos7\n\nwget\n\nyum\n```\n\n- 软件包准备\n\n```linux\n[root@sorozy source]# pwd\n/opt/source\n[root@sorozy source]# ll\n总用量 3512\n-rw-r--r--. 1 root root 1032630 8月  14 2019 nginx-1.16.1.tar.gz\n-rw-r--r--. 1 root root 2085854 2月  24 2019 pcre-8.43.tar.gz\n-rw-r--r--. 1 root root  467960 1月  16 2017 zlib-1.2.11.tar.xz\n```\n\n- 解压\n\n```linux\n[root@sorozy source]# tar xf zlib-1.2.11.tar.xz \n[root@sorozy source]# tar xf pcre-8.43.tar.gz \n[root@sorozy source]# tar xf nginx-1.16.1.tar.gz \n[root@sorozy source]# \n[root@sorozy source]# \n[root@sorozy source]# ll\n总用量 3528\ndrwxr-xr-x.  8 1001  1001     158 8月  13 2019 nginx-1.16.1\n-rw-r--r--.  1 root root  1032630 8月  14 2019 nginx-1.16.1.tar.gz\ndrwxr-xr-x.  7 1169  1169    8192 2月  24 2019 pcre-8.43\n-rw-r--r--.  1 root root  2085854 2月  24 2019 pcre-8.43.tar.gz\ndrwxr-xr-x. 14  501 games    4096 1月  16 2017 zlib-1.2.11\n-rw-r--r--.  1 root root   467960 1月  16 2017 zlib-1.2.11.tar.xz\n```\n\n- 编译前需要安装的相关依赖以及准备工作\n\n```linux\nyum install -y gcc gcc-c++\nyum install openssl openssl-devel -y\nyum install gd gd-devel -y\nuseradd nginx\n\n# 关闭防火墙\n# 关闭selinux\n```\n\n- 指定编译参数对nginx进行编译安装\n\n```linux\n# 进入nginx的解压目录\ncd nginx-1.16.1\n\n./configure --prefix=/opt/nginx --conf-path=/opt/nginx/conf/nginx.conf --user=nginx --group=nginx --pid-path=/opt/nginx/pid/nginx.pid --error-log-path=/opt/nginx/logs/error.log --with-pcre=/opt/source/pcre-8.43 --with-zlib=/opt/source/zlib-1.2.11 --with-http_ssl_module --with-http_image_filter_module --with-http_stub_status_module --http-log-path=/opt/nginx/logs/access.log\n```\n\n<br>\n\n```linux\nmake\n\nmake install\n```\n\n- nginx启动\n\n```linux\n/opt/nginx/sbin/nginx\n```\n\n# Nginx配置文件结构\n\n<img src=\"WechatIMG614.png\" width=\"80%\" />\n\n\n\n## 配置文件核心参数用法\n\n### main段核心参数\n\n|      | user USERNAME [GROUP]                                       |\n| :--: | ----------------------------------------------------------- |\n| 解释 | 指定运行Nginx的worker子进程的属主和属组，其中属组可以不指定 |\n| 示例 | user nginx nginx;                                           |\n\n|      | pid DIR                                      |\n| :--: | -------------------------------------------- |\n| 解释 | 指定运行Nginx的master主进程的pid文件存放路径 |\n| 示例 | pid /opt/nginx/logs/nginx.pid;               |\n\n|      | worker_rlimit_nofile number              |\n| :--: | ---------------------------------------- |\n| 解释 | 指定worker子进程可以打开的最大文件句柄数 |\n| 示例 | worker_rlimit_nofile 20480;              |\n\n|      | worker_rlimit_core size                                      |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 指定worker子进程异常终止后的core文件，用于记录分析问题       |\n| 示例 | worker_rlimit_core 50M;<br>working_directory /opt/nginx/tmp; |\n\n|      | work_processes number \\| auto                 |\n| :--: | --------------------------------------------- |\n| 解释 | 指定nginx启动的worker子进程数量               |\n| 示例 | worker_processes 4;<br>worker_processes auto; |\n\n|      | worker_cpu_affinity cpumask1 cpumask2...                     |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 将每个worker子进程与我们的cpu物理核心绑定                    |\n| 示例 | worker_cpu_affinity 0001 0010 0100 1000;<br>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000; # 8物理核心 8个worker子进程<br>worker_cpu_affinity 01 10 01 10; # 2个物理核心 4个worker子进程 |\n| 备注 | 将每个worker子进程与特定cpu物理核心绑定，优势在于：避免同一个worker子进程在不同的cpu物理核心上切换，缓存失效，降低性能；其并不能避免真正的进程切换 |\n\n|      | worker_priority number                                       |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 指定worker子进程的nice值，以调整运行nginx的优先级。通常设置为负值，以优先调用nginx |\n| 示例 | worker_priority -10;                                         |\n| 备注 | Linux默认进程的优先级值是120，值越小越优先；nice设定范围为-20到+19 |\n\n|      | worker_shutdown_timeout time         |\n| :--: | ------------------------------------ |\n| 解释 | 指定worker子进程优雅退出时的超时时间 |\n| 示例 | worker_shutdown_timeout 5s;          |\n\n|      | timer_resolution time                                        |\n| :--: | ------------------------------------------------------------ |\n| 解释 | worker子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升，反之，系统调用越多，性能下降 |\n| 示例 | worker_resolution 100ms;                                     |\n\n|      | daemon on \\| off                                             |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 设定nginx的运行方式，前台还是后台，前台用户调试，后台用于生产 |\n| 示例 | daemon off;                                                  |\n\n- lock_file\n\n| 语法     | lock_file file             |\n| -------- | -------------------------- |\n| 默认配置 | lock_file logs/nginx.lock  |\n| 推荐配置 | lock_file logs/nginx.lock  |\n| 解释     | 负载均衡锁信息会写入该文件 |\n\n### events段核心参数\n\n| 参数               | 含义                                 |\n| :----------------- | ------------------------------------ |\n| use                | nginx使用何种事件驱动模型            |\n| worker_connections | worker子进程能够处理的最大并发连接数 |\n| accept_mutex       | 是否打开负载均衡互斥锁               |\n| accept_mutex_delay | 新连接分配给worker子进程的超时时间   |\n| lock_file          | 负载均衡互斥锁文件存放路径           |\n| multi_accept       | worker子进程可以接收的新连接个数     |\n\n- use\n\n| 语法         | use method                                        |\n| ------------ | ------------------------------------------------- |\n| method可选值 | select、poll、kqueue、epoll、/dev/poll、eventport |\n| 默认配置     | 无                                                |\n| 推荐配置     | 不指定，让nginx自己选择                           |\n\n- worker_connections\n\n| 语法     | worker_connections number                          |\n| -------- | -------------------------------------------------- |\n| 默认配置 | worker_connections 1024                            |\n| 推荐配置 | worker_connections 65535/worker_processes \\| 65535 |\n\n- accept_mutex\n\n| 语法     | accept_mutex on \\| off                                       |\n| -------- | ------------------------------------------------------------ |\n| 可选值   | on、off                                                      |\n| 默认配置 | accept_muttex off                                            |\n| 推荐配置 | accept_mutex on                                              |\n| 解释     | 当请求到达master process，off（默认）：给所有子进程发送这个请求。on：只给其中的一个子进程发送请求 |\n\n- accept_mutex_delay\n\n| 语法     | accept_mutex_delay time                                      |\n| -------- | ------------------------------------------------------------ |\n| 默认配置 | accept_mutex_delay 500ms                                     |\n| 推荐配置 | accept_mutex_delay 200ms                                     |\n| 解释     | 当请求到达master process，会给其中一个子进程发送请求，如果该子进程在设置的时间内未响应（响应超时），则master process会再给其它子进程发送请求 |\n| 备注     | 只有当`accept_mutex`设置为`on`的时候才有意义                 |\n\n- multi_accept\n\n| 语法     | multi_accept on \\| off         |\n| -------- | ------------------------------ |\n| 可选值   | on、of                         |\n| 默认配置 | multi_accept off               |\n| 推荐配置 | multi_accept on                |\n| 解释     | 一个子进程一次可以接受多个请求 |\n\n### server_name\n\n**语法**：server_name name1,name2,...;\n\n- 四种写法\n\n| server_name | www.badiu.com      |\n| ----------- | ------------------ |\n| server_name | *.baidu.com        |\n| server_name | www.baidu.*        |\n| server_name | ~^www\\\\.baidu\\\\.*$ |\n\n`~`表示正则表达式匹配\n\n- 优先级\n\n> 精确匹配 > 左侧通配符匹配 > 右侧通配符匹配 > 正则表达式匹配\n\n### root & alias\n\n- 相同点\n\n  > URI到磁盘路径的映射\n\n- 区别\n\n  > root会将定义路径与URI叠加<br>\n  >\n  > alias则只去定义路径<br>\n  >\n  > 使用alias末尾一定要加/<br>\n  >\n  > alias只能位于location块中<br>\n\n### location\n\n- 匹配规则\n\n<img src=\"WechatIMG640.png\" width=\"80%\" />\n\n- 优先级\n\n> `=` > `^~` > `~` > `~*` > `不带任何字符`\n\n- URL末尾带`/`和不带`/`的区别\n\n# module\n\n## stub_status\n\n> 指令：stub_status；<br>\n>\n> 低于1.7.5版本：stub_status on；<br>\n>\n> 上下文：server location；\n\n- 配置示例\n\n```nginx\nlocation /uri {\n  stub_status;\n}\n```\n\n- 状态项\n\n<img src=\"WechatIMG643.png\" width=\"80%\" />\n\n- 内嵌变量\n\n<img src=\"WechatIMG644.png\" width=\"80%\" />\n\n## limit_conn\n\n### 基本功能\n\n> 用于限制客户端并发连接数<br>\n>\n> 默认编译进Nginx，通过`--without-http_limit_conn_module`\n>\n> 使用共享内存，对所有worker子进程生效\n\n### 常用指令\n\n`limit_conn_zone`\n\n`limit_conn_status`\n\n`limit_conn_log_level`\n\n`limit_conn`\n\n### limit_conn_zone\n\n| 语法   | limit_conn_zone key zone=name:size                  |\n| ------ | --------------------------------------------------- |\n| 默认值 | 无                                                  |\n| 上下文 | http                                                |\n| 示例   | `limit_conn_zone $binary_remote_addr name=addr:10m` |\n\n### limit_conn_status\n\n| 语法   | limit_conn_status code; |\n| ------ | ----------------------- |\n| 默认值 | `limit_conn_status 503` |\n| 上下文 | http、server、location  |\n\n### limit_conn_log_level\n\n| 语法   | `limit_conn_log_level`  `info`/`notice`/`warn`/`error`; |\n| ------ | ------------------------------------------------------- |\n| 默认值 | `limit_conn_status` `503`                               |\n| 上下文 | http、server、location                                  |\n\n### limit_conn\n\n| 语法   | limit_conn zone number; |\n| ------ | ----------------------- |\n| 默认值 | 无                      |\n| 上下文 | http、server、location  |\n\n## limit_req\n\n> 用于限制客户端处理请求的平均速率\n>\n> 默认编译进nginx，通过`--without-http_limit_req_module`禁用\n>\n> 使用共享内存，对所有woker子进程生效\n>\n> 限流算法：leaky_bucket\n\n- leaky_bucket算法\n\n<img src=\"WechatIMG647.png\" width=\"80%\" />\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"《Nginx核心知识100讲》study notes","url":"/2020/09/16/《Nginx核心知识100讲》study-notes/","content":"\n# 学习备注\n\n> 1. 10需要再看看\n\n# 初识Nginx\n\n## 主流web服务器\n\n> Nginx\n>\n> Apache\n>\n> Tomcat\n\n## Nginx优点\n\n> 高并发、高性能\n>\n> 可扩展性好\n>\n> 高可靠性\n>\n> 热部署\n>\n> BSD许可\n\n## Nginx的三个主要应用场景\n\n<img src=\"WechatIMG550.png\" width=\"80%\"/>\n\n## Nginx为什么会出现\n\n> 1. 互联网的数据量快速增长：互联网的快速普及、全球化物联网\n>\n> 2. 摩尔定律：性能提升\n>\n> 3. 低效的Apache：一个连接对应一个进程\n\n## Nginx组成\n\n<img src=\"WechatIMG552.png\" width=\"80%\"/>\n\n## Nginx配置语法\n\n<img src=\"WechatIMG559.png\" width=\"80%\"/>\n\n### 配置参数 - 时间单位\n\n| 简写 |      单位       |\n| :--: | :-------------: |\n|  ms  |   millisecond   |\n|  s   |     seconds     |\n|  m   |     minutes     |\n|  h   |      hours      |\n|  d   |      days       |\n|  w   |      weeks      |\n|  m   | months，30 days |\n|  y   | years，365days  |\n\n### 配置参数 - 空间单位\n\n| 简写 |   单位    |\n| :--: | :-------: |\n|      |   bytes   |\n| k/K  | kilobytes |\n| m/M  | megabytes |\n| g/G  | gigabytes |\n\n### http配置的指令块\n\n> http\n>\n> server\n>\n> upstream\n>\n> Location\n\n## Nginx命令行\n\n<img src=\"WechatIMG560.png\" width=\"80%\"/>","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"《线程八大核心+Java并发底层原理精讲》study notes","url":"/2020/09/04/《线程八大核心-Java并发底层原理精讲》study-notes/","content":"\n# 为什么需要学习并发编程\n\n1. 源于JD的硬性要求，尤其是大厂\n\n2. 网络上面经高频出现，且水平参差不齐，做归纳整理耗时耗力，难辨真伪\n\n3. 是成为高级工程师的必经之路\n\n> 几乎所有程序或多或少需要并发和多线程<br>\n>\n> 线上服务用户量大，并发量轻松过万，如果不使用并发编程，性能很快成为瓶颈<br>\n>\n> 在职场打怪升级过程中，并发编程是绕不过去的boos<br>\n\n1. 众多框架的原理和基础\n\n> spring中对线程池、单例的应用<br>\n>\n> 数据库中的乐观锁思想<br>\n>\n> log4j2对阻塞队列的应用<br>\n\n# 课程学习概述\n\n- 知识需要成体系，否则很容易忘记\n\n- 课程内容包含：\n\n> 8大核心基础<br>\n>\n> java内存模型<br>\n>\n> 死锁<br>\n>\n> 高频面试题+面试加薪技巧<br>\n\n- 分析本质、深入原理\n\n> 深入原理：剖析背后设计理念<br>\n>\n> java内存模型——底层原理，修炼内功<br>\n\n\n\n# 实现多线程的办法？是一种还是两种？\n\n- 正确的说法\n\n> oracle官网说法：https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html\n\n> 有两种方法可以创建新的执行线程。一种是将一个类声明为Thread的子类。另一种方法是声明一个实现Runnable接口的类\n\n- 实现Runnable接口\n\n```java\npublic class RunnableStyle implements Runnable {\n  \n    @Override\n    public void run() {\n        System.out.println(\"通过实现Runnable接口创建线程\");\n    }\n\n    public static void main(String[] args) {\n        new Thread(new RunnableStyle()).start();\n    }\n}\n```\n\n- 继承Thread类\n\n```java\npublic class ThreadStyle extends Thread{\n\n    @Override\n    public void run() {\n        System.out.println(\"通过继承Thread类 创建线程\");\n    }\n\n    public static void main(String[] args) {\n        new ThreadStyle().start();\n    }\n}\n```\n\n> 准确的讲，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式\n>\n> 方法一：实现`Runnable`接口的run方法，并把Runnable实例传给Thread类\n>\n> 方法二：重写Thread的run方法（继承Thread类）\n\n## *继承Thread与实现Runnable接口方法区别\n\n- 实现（Runnable接口）更好\n\n> 1. 解耦角度（run方法应该和Thread类解耦）\n> 2. 资源节约（Runnable可以使用线程池，比Thread类节约资源）（线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类）\n> 3. 避免由单继承局限带来的影响\n\n- 本质对比\n\n> 实现（Runnable接口）：最终调用target.run();\n>\n> 继承Thread：run()整个都被重写\n\n- 思考：同时使用两种方法会怎么样？\n\n```java\npublic class BothRunnableThread {\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //下面折行代码将不会执行\n                System.out.println(\"我来自Runnable\");\n            }\n        }) {\n            @Override\n            public void run() {\n                System.out.println(\"我来自Thread\");\n            }\n        }.start();\n    }\n}\n\n//控制台打印：我来自Thread\n// 原因: run方法被重写了\n```\n\n# 彩蛋\n\n## 学习编程知识的优质途径\n\n- 宏观上\n\n  > 1. 并不是靠工作年限增长技术\n  > 2. 要有强大责任心，不放过任何bug，找到原因并去解决，这就是提高\n  > 3. 主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等\n  > 4. 敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程中，进步是飞速的\n  > 5. 关心产品，关心业务，而不只是写代码\n\n- 微观上\n\n  > 1. 看经典书籍（指外国人写的经典的中国译本比如java并发编程实战、自顶向下计算机网络）\n  > 2. 看官方文档\n  > 3. 使用英文搜索，使用google、stackoverflow\n  > 4. 自己动手写，实践写demo，尝试用到项目里\n  > 5. 不理解的参考该领域的多个书本，综合判断\n  > 6. 学习开源项目，分析源码（学习synchronized原理，反编译 看cpp代码）\n\n## 如何了解技术领域的最新动态\n\n- 高质量固定途径\n- 订阅技术论坛\n- 公众号\n\n## 如何在业务开发中成长\n\n- 偏业务方向...\n- 偏技术方向...\n- 两个25%理论\n\n# 实现多线程 - 常见面试问题\n\n- 有多少种实现线程的方法?思路有5点\n\n  > 1. 从不同角度看，会有不同的答案\n  > 2. 典型答案是两种\n  > 3. 我们看原理，两种本质都是一样的\n  > 4. 具体展开说其它方式\n  > 5. 结论\n\n  解答：\n\n  > 从不同的角度看这个问题会有不同的答案，（没有说是几种代码实现方法还是本质实现方法）。（典型回答是：）通过继承Thread类和实现Runnable接口两种方式来实现多线程。实现Runnable接口方式更好。有三点优势：\n  >\n  > 1. 解耦角度（run方法应该和Thread类解耦）\n  > 2. 资源节约（Runnable可以使用线程池，比Thread类节约资源）（线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类）\n  > 3. 避免由单继承局限带来的影响\n  >\n  > 看原理两种方法本质一样,Thread类中的run方法代码是\n\n  ```java\n   @Override\n      public void run() {\n          if (target != null) {\n              target.run();\n          }\n      }\n  ```\n\n  > 其实都是都是利用了Thread类的run方法，另外一种是重写了run方法，一种是传入target再执行run方法。\n  >\n  > （展开说：）除了上面说的两种方法还有很多种方法：线程池、定时器等。但是它们细看源码后，都没有逃脱以上这个本质。\n  >\n  > （总结：）本质上只有一种，新建线程我们必须通过Thread类，但是通常我们把它区分为两种形式：重写Thread的run方法（继承Thread类）、实现`Runnable`接口的run方法，并把Runnable实例传给Thread类。另外还有更多的外在表现形式：线程池、计时器、lamda、匿名内部类等等\n\n  \n\n- 实现Runnable接口和继承Thread类那种方式更好？\n\n> 1. 从代码架构角度\n> 2. 新建线程的损耗\n> 3. java不支持双继承\n\n解答：\n\n\n\n# 启动线程的正确和错误方式\n\n- star方法含义：启动新线程\n- 不能重复执行start方法\n- start()方法源码分析\n\n> 启动过新线程检查线程状态\n>\n> 加入线程组\n>\n> 调用start0(); （本地方法）\n\n## 启动线程 - 常见面试问题\n\n- 一个线程两次调用start()方法会出现什么情况？为什么？\n\n解答：\n\n> Java中线程是不允许启动两次的，第二次调用会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。\n>\n> 通过Thread类start方法源码，可以看出start方法是一个同步方法，并且在执行start方法时首先会判断当前线程的运行状态，只有在当前状态为**NEW**的时候才会继续执行，方法执行完毕或改变当前线程的状态。如此设计保证了线程仅可执行一次start。\n>\n> （在回答完以上内容后，如果感觉面试官没有让你停下来的意思，可以继续说下自己对于线程生命周期的理解。以下是对于线程生命周期的完整阐述，面试的时候可摘取必要部分进行阐述。）\n>\n> 关于线程生命周期的不同状态，在Java 5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：\n>\n> **新建（NEW）**，表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。\n>\n> **就绪（RUNNABLE）**，表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。\n>\n> 在其他一些分析中，会额外区分一种状态**RUNNING**，但是从Java API的角度，并不能表示出来。\n>\n> **阻塞（BLOCKED）**，这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。\n>\n> **等待（WAITING）**，表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。\n>\n> **计时等待（TIMED_WAIT）**，其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例：\n>\n> public final native void wait(long timeout) throws InterruptedException;\n>\n> **终止（TERMINATED）**，不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。\n>\n> 在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。\n>\n> - 考点分析\n>\n> 这个问题可以算是个常见的面试热身题目，不仅阿里，一些有技术积累的团队也会有类似的问法。前面给出的推荐回答，算是对线程基本状态和简单流转的一个简单介绍，如果觉得还不够直观，请参考如下状态图进行演练。\n\n<img src=\"123.jpeg\" width=\"700px\" />\n\n> 总的来说，理解线程的内部原理对于我们日常开发或者诊断分析，都是不可或缺的。\n>\n> 面试官可能会以此为契机，从各种不同角度考察你对线程的掌握：\n>\n> \\1. 资深一点的面试官可能会问你线程到底是什么以及Java底层实现线程的方式。\n>\n> \\2. 线程状态的切换、线程安全以及并发工具类等方面的扩展。\n>\n> \\3. 多线程编程时容易踩的坑与体会等。\n>\n> 可以看出，仅仅是一个线程，就有非常多的内容需要掌握。我们在面试备战过程中切忌浮躁，脚踏实地地把相关的知识点逐一攻克，还担心没有心仪大厂的offer嘛！\n\n- 既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？\n\n解答：\n\n> start()用来启动一个线程，当调用start()方法时，系统才会开启一个线程，通过Thead类中start()方法来启动的线程处于就绪状态（可运行状态），此时并没有运行，一旦得到CPU时间片，就自动开始执行run()方法。此时不需要等待run()方法执行完也可以继续执行下面的代码，所以也由此看出run()方法并没有实现多线程。\n> run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。\n\n# 线程停止、中断\n\n## 如何正确停止线程\n\n- 使用interrupt来通知（停止线程），而不是强制\n\n- 两种情况下线程会停止\n\n  > run()方法所有代码执行完毕<br>\n  >\n  > 抛出异常未捕获\n\n\n\n### 普通情况下停止线程\n\n```java\n/**\n *  run方法内没有sleep或wait方法时，停止线程\n */\npublic class RightWayStopThreadWithoutSleep implements Runnable{\n    @Override\n    public void run() {\n        int num=0;\n        //Thread.currentThread().isInterrupted() 线程是否被中断\n        while (!Thread.currentThread().isInterrupted() && num <= Integer.MAX_VALUE / 2) {\n            if (num % 10000 == 0 ) {\n                System.out.println(num+\"是10000的倍数\");\n            }\n            num++;\n        }\n        System.out.println(\"任务运行结束了\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new RightWayStopThreadWithoutSleep());\n        thread.start();\n        Thread.sleep(2000);\n        thread.interrupt();\n    }\n}\n```\n\n### 阻塞的情况下停止线程（响应中断的方式：抛出异常）\n\n```java\n/**\n * run方法内有sleep或wait时停止线程\n \n */\npublic class RightWayStopThreadWithSleep {\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            try {\n                int num = 0;\n\n                while (!Thread.currentThread().isInterrupted() && num <= 300 ) {\n                    if (num % 100 == 0 ) {\n                        System.out.println(num + \"是100的倍数\");\n                    }\n                    num++;\n                }\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n        Thread thread = new Thread(runnable);\n        thread.start();\n        Thread.sleep(500);\n        thread.interrupt();\n    }\n}\n```\n\n### 每次迭代后都阻塞\n\n```java\n/**\n * 如果在执行过程中，每次循环都会调用sleep或wait方法，那么不需要每次迭代都检查是否被中断，\n * 因为在sleep过程中会响应这个中断\n */\npublic class RightWayStopThreadWithSleepEveryLoop {\n  \n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            int num=0;\n            try {\n                // 在这里检测是否被打断是多余的\n                while (num <= 10000) {\n                    if (num % 100 == 0 ) {\n                        System.out.println(num+\"是100的倍数\");\n                    }\n                    num++;\n                    Thread.sleep(10);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        Thread.sleep(2000);\n        thread.interrupt();\n    }\n}\n```\n\n### while内try/catch问题\n\n*响应中断后会把interrupt标记位清除*\n\n```java\n/**\n * 描述：如果while里面放try catch 会导致中断失效\n 响应中断后会把interrupt标记位清除\n */\npublic class CantInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n          int num=0;\n              while (!Thread.currentThread().isInterrupted() &&  num <= 10000 ) {\n                  if (num % 100 == 0 ) {\n                      System.out.println(num + \"是100的倍数\");\n                  }\n                  num++;\n\n                  try {\n                    Thread.sleep(10);\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  }\n              }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        Thread.sleep(2000);\n        thread.interrupt();\n    }\n}\n```\n\n### 两种最佳实践\n\n优先选择：传递中断\n\n```java\n\n/**\n * @author 李国栋\n * @create 2020-09-09 3:51 下午\n *\n */\npublic class RightWayStopThreadInProd implements Runnable{\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted() && true) {\n            System.out.println(\"go\");\n            try {\n                throwInMethod();\n            } catch (InterruptedException e) {\n                //保存日志 或停止程序\n                e.printStackTrace();\n                System.out.println(\"保存日志 或停止程序\");\n            }\n        }\n    }\n\n    /**\n     * 把中断吞了（错误做法）\n     */\n//    private void throwInMethod() {\n//        try {\n//            Thread.sleep(1000);\n//        } catch (InterruptedException e) {\n//            e.printStackTrace();\n//        }\n//    }\n  /**\n  应该传递（正确做法）\n  */\n    private void throwInMethod() throws InterruptedException {\n      Thread.sleep(1000);\n    }\n        \n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new RightWayStopThreadInProd());\n        thread.start();\n        Thread.sleep(1000);\n        thread.interrupt();\n    }\n}\n\n```\n\n\n\n不想或无法传递：恢复中断\n\n\n\n不应屏蔽中断\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---","tags":["java","concurrent"],"categories":["java","concurrent"]},{"title":"《理论+实战 构建完整JVM知识体系》study notes","url":"/2020/09/03/《理论-实战-构建完整JVM知识体系》study-notes/","content":"\n\n\n# 备注\n\n> Java9模块系统开发需要抽空了解一下\n\n# JVM概述\n\n- JVM：Java Virtual Machine（java虚拟机）\n- 虚拟机：通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的计算机系统\n- jvm是通过软件来模拟java的字节码指令集，是java程序的运行环境\n\n<br>\n\n<img width=\"700px\" src=\"WechatIMG388.png\" />\n\n## jvm主要功能\n\n1. 通过ClassLoader寻找和装载class文件\n2. 解释字节码成为指令并执行，提供class文件的运行环境\n3. 进行运行期间的内存分配和垃圾回收\n4. 提供与硬件交互的平台\n\n<br>\n\n- 虚拟机是java平台无关的保障\n\n<img width=\"700px\" src=\"WechatIMG393.png\" />\n\n\n\n## jvm规范作用\n\n- java虚拟机规范为不同的硬件平台提供了一种编译java技术代码的规范\n- 该规范使用java软件独立于平台，因为编译是针对作为虚拟机的`一般机器`而做\n- 这个`一般机器`可用软件模拟并运行于各种现存的计算机系统，也可用硬件来实现\n\n## jvm规范定义的主要内容\n\n- 字节码指令集（相当于中央处理器cpu）\n- class文件的格式\n- 数据类型和值\n- 运行时数据区\n- 栈帧\n- 特殊方法\n- 类库\n- 异常\n- 虚拟机的启动、加载、链接和初始化\n\n# class文件格式概述\n\nclass文件是jvm的输入，java虚拟机规范中定义了，class文件的结构，class问价是jvm实现平台无关、技术无关的基础\n\n1:class文件是一组以8字节为单位的字节流，各个数据项目按顺序紧凑排列\n\n2:对于占用空间大于8字节的的数据项，按照高位在前的方式分割成多个8字节进行存储\n\n3:class文件格式里面只有两种数据类型：无符号数、表\n\n（1）无符号数：基础数据类型，以u1、u2、u4、u8来代表几个字节的无符号数\n\n（2）表：由多个无符号数和其它表构成的复合数据类型，通常以`_info`结尾\n\n\n\n\n\n# 类加载\n\n## 概述\n\n<img width=\"500px\" src=\"WechatIMG404.png\" />\n\n- 加载：查找并加载类文件的二进制数据\n- 连接：将已经读入内存的类的二进制数据合并到jvm运行时环境中去，包含如下几个步骤\n\n> 1. 验证 ：确保被加载类的正确性\n> 2. 准备：为类的静态变量分配内存，并初始化它们\n> 3. 解析：把常量池中的符号引用转换成直接引用\n\n- 初始化：为类的静态变量赋初始值\n\n### 类加载要完成的功能\n\n1. 通过类的全限定名来获取该类的二进制字节流\n2. 把二进制字节流转化为方法区的运行时数据结构\n3. 在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口\n\n### 加载类的方式\n\n- 最常见的方式：本地文件系统中加载、从jar等归档文件中加载\n- 动态的方式：将java源文件动态编译成class\n- 其它方式：网络下载、从专有数据库中加载等等\n\n## 类加载器\n\n<img width=\"500px\" src=\"WechatIMG409.png\" />\n\n- 为什么要废除jdk1.8的扩展类加载器\n\n> 1. jdk1.8的扩展类加载器主要加载`jre/lib/ext` 下面的jar包，当我们想扩展功能的时候就把jar包放在下面。其实并不安全\n> 2. jdk9想要扩展功能的时候，因为jdk9有了模块化开发，这种扩展机制就被模块化的天然扩展能力取代了\n\n- 类加载器的关系\n\n<img width=\"500px\" src=\"WechatIMG411.png\" />\n\n## 类加载器说明\n\n<img width=\"500px\" src=\"WechatIMG413.png\" /><br>\n\n```java\n// 各种类加载器\npublic class ClassLoaderStudy {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\tString str = \"Hello ClassLoader\";\n\t\tSystem.out.println(\"str ClassLoader == \" + str.getClass().getClassLoader());\n\t\t\n\t\tSystem.out.println(\"\\n\");\n\t\t\n\t\tClass driver = Class.forName(\"java.sql.Driver\");\n\t\tSystem.out.println(\"driver ClassLoader == \" + driver.getClassLoader());\n\t\tSystem.out.println(\"driver parent ClassLoader == \" + driver.getClassLoader().getParent());\n\t\t\n\t\tSystem.out.println(\"\\n\");\n\t\t\n\t\tClassLoaderStudy clt = new ClassLoaderStudy();\n\t\tSystem.out.println(\"clt ClassLoader == \" + clt.getClass().getClassLoader());\n\t\tSystem.out.println(\"clt parent  ClassLoader == \" + clt.getClass().getClassLoader().getParent());\n\t\tSystem.out.println(\"clt parent parent ClassLoader == \" + clt.getClass().getClassLoader().getParent().getParent());\n\t}\n}\n```\n\n```java\n// 运行输出结果\nstr ClassLoader == null\n\n\ndriver ClassLoader == jdk.internal.loader.ClassLoaders$PlatformClassLoader@27c170f0\ndriver parent ClassLoader == null\n\n\nclt ClassLoader == jdk.internal.loader.ClassLoaders$AppClassLoader@55054057\nclt parent  ClassLoader == jdk.internal.loader.ClassLoaders$PlatformClassLoader@27c170f0\nclt parent parent ClassLoader == null\n```\n\n\n\n<img width=\"500px\" src=\"WechatIMG414.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG415.png\" />\n\n\n\n\n\n## 双亲委派模型\n\n<img width=\"500px\" src=\"WechatIMG416.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG417.png\" /><br><img width=\"500px\" src=\"WechatIMG30.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG31.png\" /><br>\n\n### 破坏双亲委派模型\n\n<img width=\"500px\" src=\"WechatIMG32.png\" /><br>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jvm"],"categories":["jvm"]},{"title":"《一站式学习Java网络编程 全面理解BIO/NIO/AIO》study notes","url":"/2020/09/01/《一站式学习Java网络编程-全面理解BIO-NIO-AIO》study-notes/","content":"\n# 学习备注\n\n> 学习java io中的装饰器模式\n>\n> 学习线程池相关的知识\n>\n> 学习socket等相关的知识\n>\n> 多线程并发这块是先导知识，后序要深入理解\n>\n> Ok-学习 同步 异步 阻塞 非阻塞\n\n\n\n# 概述\n\n> BIO: Java 1.4以前\n>\n> NIO: java 1.4\n>\n> AIO: java 1.7\n\n- 网络编程的本质：进程间的通信\n\n## java io\n\n## 字符流\n\n<img src=\"WechatIMG702.png\" />\n\n## 字节流\n\n<img src=\"WechatIMG703.png\" />\n\n# Socket\n\n- socket也是一种数据源\n- socket是网络通信的断点\n\n- 通过socket发送数据\n\n<img src=\"WechatIMG706.png\" />\n\n# 同步 异步 阻塞 非阻塞\n\n- 同步和异步关注的是**消息通信机制**\n\n> 同步：就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回\n>\n> 异步：**调用**在发出之后，这个**调用**就直接返回了，所以没有返回结果\n\n- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态\n\n> 阻塞调用：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回\n> 非阻塞调用：指在不能立刻得到结果之前，该调用不会阻塞当前线程\n\n# 线程池\n\n<img src=\"WechatIMG708.png\" />\n\n- 创建线程池的方法\n\n<img src=\"WechatIMG709.png\" />\n\n"},{"title":"《深入理解Java虚拟机》study notes","url":"/2020/09/01/《深入理解Java虚拟机》study-notes/","content":"\n\n\n# 第二章 Java内存区域与内存溢出异常\n\n## 运行时数据区\n\n<img src=\"unnamed.jpg\" width=\"500px\" />\n\n### 程序计数器（program counter register）\n\n- 当前线程所执行的字节码行号指示器\n- 线程私有的内存\n- 没有OOM的区域","tags":["jvm"]},{"title":"适合后端编程人员的Redis实战教程","url":"/2020/08/24/适合后端编程人员的Redis实战教程/","content":"# Redis\n\n## 1.  NoSQL的引言\n\n**NoSQL**(` Not Only SQL` )，意即**不仅仅是SQL**, 泛指非关系型的数据库。Nosql这个技术门类,早期就有人提出,发展至2009年趋势越发高涨。\n\n## 2. 为什么是NoSQL\n\n随着互联网网站的兴起，传统的关系数据库在应付动态网站，特别是超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。如`商城网站中对商品数据频繁查询`、`对热搜商品的排行统计`、`订单超时问题`、以及微信朋友圈（音频，视频）存储等相关使用传统的关系型数据库实现就显得非常复杂，虽然能实现相应功能但是在性能上却不是那么乐观。nosql这个技术门类的出现，更好的解决了这些问题，它告诉了世界不仅仅是sql。\n\n## 3. NoSQL的四大分类\n\n### 3.1 键值(Key-Value)存储数据库\n\n```markdown\n# 1.说明: \n- 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。\n\n# 2.特点\n- Key/value模型对于IT系统来说的优势在于简单、易部署。  \n- 但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。\n\n# 3.相关产品\n- Tokyo Cabinet/Tyrant,\n- Redis\n- SSDB\n- Voldemort \n- Oracle BDB\n```\n\n### 3.2 列存储数据库\n\n```markdown\n# 1.说明\n- 这部分数据库通常是用来应对分布式存储的海量数据。\n\n# 2.特点\n- 键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。\n\n# 3.相关产品\n- Cassandra、HBase、Riak.\n```\n\n### 3.3 文档型数据库\n\n```markdown\n# 1.说明\n- 文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高\n\n# 2.特点\n- 以文档形式存储\n\n# 3.相关产品\n- MongoDB、CouchDB、 MongoDb(4.x). 国内也有文档型数据库SequoiaDB，已经开源。\n```\n\n### 3.4 图形(Graph)数据库\n\n ```markdown\n# 1.说明\n- 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。\n- NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。\n\n# 2.特点\n\n# 3.相关产品\n- Neo4J、InfoGrid、 Infinite Graph、\n ```\n\n----\n\n## 4. NoSQL应用场景\n\n- 数据模型比较简单\n\n- 需要灵活性更强的IT系统\n\n- 对数据库性能要求较高\n\n- 不需要高度的数据一致性\n\n## 5. 什么是Redis\n\n<img width=\"700px\" src=\"image-20200623121234046.png\" />\n\n> Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.\n\nRedis 开源  遵循BSD  基于内存数据存储 被用于作为 数据库 缓存  消息中间件\n\n- 总结: redis是一个内存型的数据库\n\n## 6. Redis特点\n\n-  Redis是一个高性能key/value内存型数据库\n\n- Redis支持丰富的数据类型 \n\n- Redis支持持久化 \n\n- Redis单线程,单进程\n\n---\n\n## 7. Redis安装\n\n```markdown\n# 0.准备环境\n- vmware15.x+\n- centos7.x+\n\n# 1.下载redis源码包\n- https://redis.io/\n```\n\n<img width=\"700px\" src=\"image-20200623121621195.png\"  />\n\n```markdown\n# 2.下载完整源码包\n- redis-4.0.10.tar.gz\n```\n\n<img width=\"700px\" src=\"image-20200623123918876.png\" />\n\n```markdown\n# 3.将下载redis资料包上传到Linux中\n```\n\n<img width=\"700px\" src=\"image-20200623124327319.png\" />\n\n```markdown\n# 4.解压缩文件\n[root@localhost ~]# tar -zxvf redis-4.0.10.tar.gz\n[root@localhost ~]# ll\n```\n\n<img width=\"700px\" src=\"image-20200623124522026.png\" />\n\n```markdown\n# 5.安装gcc  \n- yum install -y gcc\n\n# 6.进入解压缩目录执行如下命令\n- make MALLOC=libc\n\n# 7.编译完成后执行如下命令\n- make install PREFIX=/usr/redis\n\n# 8.进入/usr/redis目录启动redis服务 \n- ./redis-server\n```\n\n<img width=\"700px\" src=\"image-20200623125420505.png\" />\n\n```markdown\n# 9.Redis服务端口默认是 6379\n\n# 10.进入bin目录执行客户端连接操作\n- ./redis-cli –p 6379\n```\n\n<img width=\"700px\" src=\"image-20200623125716013.png\" />\n\n```markdown\n# 11.连接成功出现上面界面连接成功\n```\n\n## 8. Redis数据库相关指令\n\n### 8.1 数据库操作指令\n\n```markdown\n# 1.Redis中库说明\n- 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15\n- 可以使用select 库的编号 来选择一个redis的库\n\n# 2.Redis中操作库的指令\n- 清空当前的库  FLUSHDB\n- 清空全部的库  FLUSHALL\n\n# 3.redis客户端显示中文\n-\t./redis-cli  -p 7000 --raw\n```\n\n### 8.2 操作key相关指令\n\n```markdown\n# 1.DEL指令\n- 语法 :  DEL key [key ...] \n- 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。\n- 可用版本： >= 1.0.0\n- 返回值： 被删除key 的数量。 \n\n# 2.EXISTS指令\n- 语法:  EXISTS key\n- 作用:  检查给定key 是否存在。\n- 可用版本： >= 1.0.0\n- 返回值： 若key 存在，返回1 ，否则返回0。\n\n# 3.EXPIRE\n- 语法:  EXPIRE key seconds\n- 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。\n- 可用版本： >= 1.0.0\n- 时间复杂度： O(1)\n- 返回值：设置成功返回1 。\n\n# 4.KEYS\n- 语法 :  KEYS pattern\n- 作用 :  查找所有符合给定模式pattern 的key 。\n- 语法:\n\tKEYS * 匹配数据库中所有key 。\n\tKEYS h?llo 匹配hello ，hallo 和hxllo 等。\n\tKEYS h*llo 匹配hllo 和heeeeello 等。\n\tKEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 \"\\\" 隔开\n- 可用版本： >= 1.0.0\n- 返回值： 符合给定模式的key 列表。\n\n# 5.MOVE\n- 语法 :  MOVE key db\n- 作用 :  将当前数据库的key 移动到给定的数据库db 当中。\n- 可用版本： >= 1.0.0\n- 返回值： 移动成功返回1 ，失败则返回0 。\n\n# 6.PEXPIRE\n- 语法 :  PEXPIRE key milliseconds\n- 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。\n- 可用版本： >= 2.6.0\n- 时间复杂度： O(1)\n- 返回值：设置成功，返回1  key 不存在或设置失败，返回0\n\n# 7.PEXPIREAT\n- 语法 :  PEXPIREAT key milliseconds-timestamp\n- 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。\n- 可用版本： >= 2.6.0\n- 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)\n\n# 8.TTL\n- 语法 :   TTL key\n- 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。\n- 可用版本： >= 1.0.0\n- 返回值：\n\t当key 不存在时，返回-2 。\n\t当key 存在但没有设置剩余生存时间时，返回-1 。\n\t否则，以秒为单位，返回key 的剩余生存时间。\n- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。\n\n# 9.PTTL\n- 语法 :  PTTL key\n- 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。\n- 可用版本： >= 2.6.0\n- 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。\n- 否则，以毫秒为单位，返回key 的剩余生存时间。\n- 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。\n\n# 10.RANDOMKEY\n- 语法 :  RANDOMKEY\n- 作用 :  从当前数据库中随机返回(不删除) 一个key 。\n- 可用版本： >= 1.0.0\n- 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。\n\n# 11.RENAME\n- 语法 :  RENAME key newkey\n- 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。\n- 可用版本： >= 1.0.0\n- 返回值： 改名成功时提示OK ，失败时候返回一个错误。\n\n# 12.TYPE\n- 语法 :  TYPE key\n- 作用 :  返回key 所储存的值的类型。\n- 可用版本： >= 1.0.0\n- 返回值：\n\tnone (key 不存在)\n\tstring (字符串)\n\tlist (列表)\n\tset (集合)\n\tzset (有序集)\n\thash (哈希表)\n```\n\n### 8.3 String类型\n\n#### 1. 内存存储模型\n\n<img width=\"700px\" src=\"image-20200623132104399.png\" />\n\n#### 2. 常用操作命令\n\n| 命令                                       | 说明                                       |\n| ------------------------------------------ | ------------------------------------------ |\n| set                                        | 设置一个key/value                          |\n| get                                        | 根据key获得对应的value                     |\n| mset                                       | 一次设置多个key value                      |\n| mget                                       | 一次获得多个key的value                     |\n| getset                                     | 获得原始key的值，同时设置新值              |\n| strlen                                     | 获得对应key存储value的长度                 |\n| append                                     | 为对应key的value追加内容                   |\n| getrange 索引0开始                         | 截取value的内容                            |\n| setex                                      | 设置一个key存活的有效期（秒）              |\n| psetex                                     | 设置一个key存活的有效期（毫秒）            |\n| setnx                                      | 存在不做任何操作,不存在添加                |\n| msetnx原子操作(只要有一个存在不做任何操作) | 可以同时设置多个key,只有有一个存在都不保存 |\n| decr                                       | 进行数值类型的-1操作                       |\n| decrby                                     | 根据提供的数据进行减法操作                 |\n| Incr                                       | 进行数值类型的+1操作                       |\n| incrby                                     | 根据提供的数据进行加法操作                 |\n| Incrbyfloat                                | 根据提供的数据加入浮点数                   |\n\n###  8.4 List类型\n\nlist 列表 相当于java中list 集合  特点  元素有序  且 可以重复\n\n#### 1.内存存储模型\n\n<img width=\"700px\" src=\"image-20200623161114380.png\" />\n\n#### 2.常用操作指令\n\n| 命令    | 说明                                 |\n| ------- | ------------------------------------ |\n| lpush   | 将某个值加入到一个key列表头部        |\n| lpushx  | 同lpush,但是必须要保证这个key存在    |\n| rpush   | 将某个值加入到一个key列表末尾        |\n| rpushx  | 同rpush,但是必须要保证这个key存在    |\n| lpop    | 返回和移除列表左边的第一个元素       |\n| rpop    | 返回和移除列表右边的第一个元素       |\n| lrange  | 获取某一个下标区间内的元素           |\n| llen    | 获取列表元素个数                     |\n| lset    | 设置某一个指定索引的值(索引必须存在) |\n| lindex  | 获取某一个指定索引位置的元素         |\n| lrem    | 删除重复元素                         |\n| ltrim   | 保留列表中特定区间内的元素           |\n| linsert | 在某一个元素之前，之后插入新元素     |\n\n### 8.5 Set类型\n\n特点: Set类型 Set集合 元素无序  不可以重复\n\n#### 1.内存存储模型\n\n<img width=\"700px\" src=\"image-20200623193634316.png\" />\n\n#### 2.常用命令\n\n| 命令        | 说明                                               |\n| ----------- | -------------------------------------------------- |\n| sadd        | 为集合添加元素                                     |\n| smembers    | 显示集合中所有元素 无序                            |\n| scard       | 返回集合中元素的个数                               |\n| spop        | 随机返回一个元素 并将元素在集合中删除              |\n| smove       | 从一个集合中向另一个集合移动元素  必须是同一种类型 |\n| srem        | 从集合中删除一个元素                               |\n| sismember   | 判断一个集合中是否含有这个元素                     |\n| srandmember | 随机返回元素                                       |\n| sdiff       | 去掉第一个集合中其它集合含有的相同元素             |\n| sinter      | 求交集                                             |\n| sunion      | 求和集                                             |\n\n###  8.6 ZSet类型\n\n特点: 可排序的set集合  排序  不可重复 \n\nZSET 官方  可排序SET  sortSet   \n\n#### 1.内存模型\n\n<img width=\"700px\" src=\"image-20200623194903967.png\" />\n\n#### 2.常用命令\n\n| 命令                       | 说明                         |\n| -------------------------- | ---------------------------- |\n| zadd                       | 添加一个有序集合元素         |\n| zcard                      | 返回集合的元素个数           |\n| zrange 升序 zrevrange 降序 | 返回一个范围内的元素         |\n| zrangebyscore              | 按照分数查找一个范围内的元素 |\n| zrank                      | 返回排名                     |\n| zrevrank                   | 倒序排名                     |\n| zscore                     | 显示某一个元素的分数         |\n| zrem                       | 移除某一个元素               |\n| zincrby                    | 给某个特定元素加分           |\n\n###  8.7 hash类型\n\n特点: value 是一个map结构 存在key value  key 无序的  \n\n#### 1.内存模型\n\n<img width=\"700px\" src=\"image-20200623200348408.png\" />\n\n#### 2.常用命令\n\n| 命令         | 说明                    |\n| ------------ | ----------------------- |\n| hset         | 设置一个key/value对     |\n| hget         | 获得一个key对应的value  |\n| hgetall      | 获得所有的key/value对   |\n| hdel         | 删除某一个key/value对   |\n| hexists      | 判断一个key是否存在     |\n| hkeys        | 获得所有的key           |\n| hvals        | 获得所有的value         |\n| hmset        | 设置多个key/value       |\n| hmget        | 获得多个key的value      |\n| hsetnx       | 设置一个不存在的key的值 |\n| hincrby      | 为value进行加法运算     |\n| hincrbyfloat | 为value加入浮点值       |\n\n---\n\n## 9. 持久化机制\n\nclient  redis[内存] ----->  内存数据- 数据持久化-->磁盘\n\nRedis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:\n\n- 快照(Snapshot)\n- AOF (Append Only File) 只追加日志文件\n\n### 9.1 快照(Snapshot)\n\n#### 1. 特点\n\n这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是**redis的默认开启持久化方式**,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。\n\n<img width=\"700px\" src=\"image-20200623204303074.png\" />\n\n#### 2.快照生成方式\n\n- 客户端方式: BGSAVE 和 SAVE指令\n- 服务器配置自动触发\n\n```markdown\n# 1.客户端方式之BGSAVE\n- a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。\n\t\n\t`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务`\n```\n\n<img width=\"700px\" src=\"image-20200623205132460.png\" />\n\n```markdown\n# 2.客户端方式之SAVE\n- b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令\n```\n\n<img width=\"700px\" src=\"image-20200623205444101.png\" />\n\n- **注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务**\n\n```markdown\n# 3.服务器配置方式之满足配置自动触发\n- 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令\n```\n\n<img width=\"700px\" src=\"image-20200623210021012.png\" />\n\n```markdown\n# 4.服务器接收客户端shutdown指令\n- 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器\n```\n\n#### 3.配置生成快照名称和位置\n\n```markdown\n#1.修改生成快照名称\n- dbfilename dump.rdb\n\n# 2.修改生成位置\n- dir ./\n```\n\n<img width=\"700px\" src=\"image-20200623210352448.png\" />\n\n----\n\n### 9.2 AOF 只追加日志文件\n\n#### 1.特点\n\n这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.\n\n<img width=\"700px\" src=\"image-20200623211330798.png\" />\n\n#### 2.开启AOF持久化\n\n在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启\n\n```markdown\n# 1.开启AOF持久化\n- a.修改 appendonly yes 开启持久化\n- b.修改 appendfilename \"appendonly.aof\" 指定生成文件名称\n```\n\n<img width=\"700px\" src=\"image-20200623211508987.png\" />\n\n#### 3.日志追加频率\n\n```markdown\n# 1.always 【谨慎使用】\n- 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度\n- 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;\n- 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;\n- 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。\n\n# 2.everysec 【推荐】\n- 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘\n- 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。\n\n# 3.no\t【不推荐】\n- 说明: 由操作系统决定何时同步 \n- 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。\n```\n\n#### 4.修改同步频率\n\n```markdown\n# 1.修改日志同步频率\n- 修改appendfsync everysec|always|no 指定\n```\n\n<img width=\"700px\" src=\"image-20200623211658910.png\" />\n\n----\n\n### 9.3 AOF文件的重写\n\n#### 1. AOF带来的问题\n\nAOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。\n\n#### 2. AOF重写\n\n用来在一定程度上减小AOF文件的体积\n\n#### 3. 触发重写方式\n\n```markdown\n# 1.客户端方式触发重写\n- 执行BGREWRITEAOF命令  不会阻塞redis的服务\n\n# 2.服务器配置方式自动触发\n- 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓\n- 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大\n```\n\n<img width=\"700px\" src=\"image-20200623212547775.png\" />\n\n#### 4. 重写原理\n\n **注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。**\n\n```markdown\n# 重写流程\n- 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令\n- 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。\n- 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。\n- 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。\n```\n\n<img width=\"700px\" src=\"image-20200623214843123.png\" />\n\n----\n\n### 9.4 持久化总结\n\n两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。\n\n无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。\n\n---\n\n## 10. java操作Redis\n\n### 10.1 环境准备\n\n#### 1. 引入依赖\n\n```xml\n<!--引入jedis连接依赖-->\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.9.0</version>\n</dependency>\n```\n\n#### 2.创建jedis对象\n\n```java\n public static void main(String[] args) {\n   //1.创建jedis对象\n   Jedis jedis = new Jedis(\"192.168.40.4\", 6379);//1.redis服务必须关闭防火墙  2.redis服务必须开启远程连接\n   jedis.select(0);//选择操作的库默认0号库\n   //2.执行相关操作\n   //....\n   //3.释放资源\n   jedis.close();\n }\n```\n\n<img width=\"700px\" src=\"image-20200623201932000.png\" />\n\n### 10.2 操作key相关API\n\n```java\nprivate Jedis jedis;\n    @Before\n    public void before(){\n        this.jedis = new Jedis(\"192.168.202.205\", 7000);\n    }\n    @After\n    public void after(){\n        jedis.close();\n    }\n\n    //测试key相关\n    @Test\n    public void testKeys(){\n        //删除一个key\n        jedis.del(\"name\");\n        //删除多个key\n        jedis.del(\"name\",\"age\");\n\n        //判断一个key是否存在exits\n        Boolean name = jedis.exists(\"name\");\n        System.out.println(name);\n\n        //设置一个key超时时间 expire pexpire\n        Long age = jedis.expire(\"age\", 100);\n        System.out.println(age);\n\n        //获取一个key超时时间 ttl\n        Long age1 = jedis.ttl(\"newage\");\n        System.out.println(age1);\n\n        //随机获取一个key\n        String s = jedis.randomKey();\n\n        //修改key名称\n        jedis.rename(\"age\",\"newage\");\n\n        //查看可以对应值的类型\n        String name1 = jedis.type(\"name\");\n        System.out.println(name1);\n        String maps = jedis.type(\"maps\");\n        System.out.println(maps);\n    }\n```\n\n<img width=\"700px\" src=\"image-20200627180325687.png\" />\n\n### 10.3操作String相关API\n\n```java\n//测试String相关\n    @Test\n    public void testString(){\n        //set\n        jedis.set(\"name\",\"小陈\");\n        //get\n        String s = jedis.get(\"name\");\n        System.out.println(s);\n        //mset\n        jedis.mset(\"content\",\"好人\",\"address\",\"海淀区\");\n        //mget\n        List<String> mget = jedis.mget(\"name\", \"content\", \"address\");\n        mget.forEach(v-> System.out.println(\"v = \" + v));\n        //getset\n        String set = jedis.getSet(\"name\", \"小明\");\n        System.out.println(set);\n\n        //............\n    }\n```\n\n<img width=\"700px\" src=\"image-20200627180352953.png\" />\n\n### 10.4操作List相关API\n\n```java\n//测试List相关\n    @Test\n    public void testList(){\n\n        //lpush\n        jedis.lpush(\"names1\",\"张三\",\"王五\",\"赵柳\",\"win7\");\n\n        //rpush\n        jedis.rpush(\"names1\",\"xiaomingming\");\n\n        //lrange\n\n        List<String> names1 = jedis.lrange(\"names1\", 0, -1);\n        names1.forEach(name-> System.out.println(\"name = \" + name));\n\n        //lpop rpop\n        String names11 = jedis.lpop(\"names1\");\n        System.out.println(names11);\n\n        //llen\n        jedis.linsert(\"lists\", BinaryClient.LIST_POSITION.BEFORE,\"xiaohei\",\"xiaobai\");\n\n      \t//........\n\n    }\n\n```\n\n<img width=\"700px\" src=\"image-20200627180435997.png\" />\n\n### 10.5操作Set的相关API\n\n```java\n//测试SET相关\n@Test\npublic void testSet(){\n\n  //sadd\n  jedis.sadd(\"names\",\"zhangsan\",\"lisi\");\n\n  //smembers\n  jedis.smembers(\"names\");\n\n  //sismember\n  jedis.sismember(\"names\",\"xiaochen\");\n\n  //...\n}\n```\n\n<img width=\"700px\" src=\"image-20200627181913715.png\" />\n\n### 10.6 操作ZSet相关API\n\n```java\n//测试ZSET相关\n@Test\npublic void testZset(){\n\n  //zadd\n  jedis.zadd(\"names\",10,\"张三\");\n\n  //zrange\n  jedis.zrange(\"names\",0,-1);\n\n  //zcard\n  jedis.zcard(\"names\");\n\n  //zrangeByScore\n  jedis.zrangeByScore(\"names\",\"0\",\"100\",0,5);\n\n  //..\n\n}\n```\n\n<img width=\"700px\" src=\"image-20200627181947116.png\" />\n\n### 10.7 操作Hash相关API\n\n```java\n//测试HASH相关\n@Test\npublic void testHash(){\n  //hset\n  jedis.hset(\"maps\",\"name\",\"zhangsan\");\n  //hget\n  jedis.hget(\"maps\",\"name\");\n  //hgetall\n  jedis.hgetAll(\"mps\");\n  //hkeys\n  jedis.hkeys(\"maps\");\n  //hvals\n  jedis.hvals(\"maps\");\n  //....\n}\n```\n\n<img width=\"700px\" src=\"image-20200628093242527.png\" />\n\n----\n\n## 11.SpringBoot整合Redis\n\nSpring Boot Data(数据) Redis 中提供了**RedisTemplate和StringRedisTemplate**，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，**RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。**\n\n`注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口`\n\n### 11.1 环境准备\n\n#### 1.引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n#### 2.配置application.propertie\n\n```properties\nspring.redis.host=localhost\nspring.redis.port=6379\nspring.redis.database=0\n```\n\n### 11.2 使用StringRedisTemplate和RedisTemplate\n\n```java\n\t\t@Autowired\n    private StringRedisTemplate stringRedisTemplate;  //对字符串支持比较友好,不能存储对象\n    @Autowired\n    private RedisTemplate redisTemplate;  //存储对象\n\n    @Test\n    public void testRedisTemplate(){\n        System.out.println(redisTemplate);\n        //设置redistemplate值使用对象序列化策略\n        redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());//指定值使用对象序列化\n        //redisTemplate.opsForValue().set(\"user\",new User(\"21\",\"小黑\",23,new Date()));\n        User user = (User) redisTemplate.opsForValue().get(\"user\");\n        System.out.println(user);\n//      Set keys = redisTemplate.keys(\"*\");\n//      keys.forEach(key -> System.out.println(key));\n        /*Object name = redisTemplate.opsForValue().get(\"name\");\n        System.out.println(name);*/\n\n        //Object xiaohei = redisTemplate.opsForValue().get(\"xiaohei\");\n        //System.out.println(xiaohei);\n        /*redisTemplate.opsForValue().set(\"name\",\"xxxx\");\n        Object name = redisTemplate.opsForValue().get(\"name\");\n        System.out.println(name);*/\n        /*redisTemplate.opsForList().leftPushAll(\"lists\",\"xxxx\",\"1111\");\n        List lists = redisTemplate.opsForList().range(\"lists\", 0, -1);\n        lists.forEach(list-> System.out.println(list));*/\n    }\n\n\n    //key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key\n    //boundValueOps 用来对String值绑定key\n    //boundListOps 用来对List值绑定key\n    //boundSetOps 用来对Set值绑定key\n    //boundZsetOps 用来对Zset值绑定key\n    //boundHashOps 用来对Hash值绑定key\n\n    @Test\n    public void testBoundKey(){\n        BoundValueOperations<String, String> nameValueOperations = stringRedisTemplate.boundValueOps(\"name\");\n        nameValueOperations.set(\"1\");\n        //yuew\n        nameValueOperations.set(\"2\");\n        String s = nameValueOperations.get();\n        System.out.println(s);\n\n    }\n\n\n    //hash相关操作 opsForHash\n    @Test\n    public void testHash(){\n        stringRedisTemplate.opsForHash().put(\"maps\",\"name\",\"小黑\");\n        Object o = stringRedisTemplate.opsForHash().get(\"maps\", \"name\");\n        System.out.println(o);\n    }\n\n    //zset相关操作 opsForZSet\n    @Test\n    public void testZSet(){\n        stringRedisTemplate.opsForZSet().add(\"zsets\",\"小黑\",10);\n        Set<String> zsets = stringRedisTemplate.opsForZSet().range(\"zsets\", 0, -1);\n        zsets.forEach(value-> System.out.println(value));\n    }\n\n    //set相关操作 opsForSet\n    @Test\n    public void testSet(){\n        stringRedisTemplate.opsForSet().add(\"sets\",\"xiaosan\",\"xiaosi\",\"xiaowu\");\n        Set<String> sets = stringRedisTemplate.opsForSet().members(\"sets\");\n        sets.forEach(value-> System.out.println(value));\n    }\n\n    //list相关的操作opsForList\n    @Test\n    public void testList(){\n        // stringRedisTemplate.opsForList().leftPushAll(\"lists\",\"张三\",\"李四\",\"王五\");\n        List<String> lists = stringRedisTemplate.opsForList().range(\"lists\", 0, -1);\n        lists.forEach(key -> System.out.println(key));\n    }\n\n\n    //String相关的操作 opsForValue\n    @Test\n    public void testString(){\n        //stringRedisTemplate.opsForValue().set(\"166\",\"好同学\");\n        String s = stringRedisTemplate.opsForValue().get(\"166\");\n        System.out.println(s);\n        Long size = stringRedisTemplate.opsForValue().size(\"166\");\n        System.out.println(size);\n    }\n\n\n    //key相关的操作\n    @Test\n    public void test(){\n        Set<String> keys = stringRedisTemplate.keys(\"*\");//查看所有key\n        Boolean name = stringRedisTemplate.hasKey(\"name\");//判断某个key是否存在\n        stringRedisTemplate.delete(\"age\");//根据指定key删除\n        stringRedisTemplate.rename(\"\",\"\");//修改key的名称\n        stringRedisTemplate.expire(\"key\",10, TimeUnit.HOURS);\n      \t//设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位\n        stringRedisTemplate.move(\"\",1);//移动key\n    }\n```\n\n---\n\n## 12. Redis 主从复制\n\n### 12.1 主从复制\n\n主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据\n\n**无法解决: 1.master节点出现故障的自动故障转移**\n\n### 12.2 主从复制架构图\n\n<img width=\"700px\" src=\"image-20200627201722700.png\" />\n\n### 12.3 搭建主从复制\n\n```markdown\n# 1.准备3台机器并修改配置\n- master\n\tport 6379\n\tbind 0.0.0.0\n\t\n- slave1\n\tport 6380\n\tbind 0.0.0.0\n\tslaveof masterip masterport\n\n- slave2\n\tport 6381\n\tbind 0.0.0.0\n\tslaveof masterip masterport\n```\n\n<img width=\"700px\" src=\"image-20200627202443388.png\" />\n\n```markdown\n# 2.启动3台机器进行测试\n- cd /usr/redis/bin\n- ./redis-server /root/master/redis.conf\n- ./redis-server /root/slave1/redis.conf\n- ./redis-server /root/slave2/redis.conf\n```\n\n---\n\n## 13. Redis哨兵机制\n\n### 13.1 哨兵Sentinel机制\n\nSentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有**自动故障转移功能的主从架构**。\n\n**无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限**\n\n### 13.2 哨兵架构原理\n\n<img width=\"700px\" src=\"image-20200627204422750.png\" />\n\n### 13.3 搭建哨兵架构\n\n```markdown\n# 1.在主节点上创建哨兵配置\n- 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；\n\n# 2.配置哨兵，在sentinel.conf文件中填入内容：\n- sentinel monitor 被监控数据库名字（自己起名字） ip port 1\n\n# 3.启动哨兵模式进行测试\n- redis-sentinel  /root/sentinel/sentinel.conf\n\t说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。\n```\n\n### 13.4 通过springboot操作哨兵\n\n```properties\n# redis sentinel 配置\n# master书写是使用哨兵监听的那个名称\nspring.redis.sentinel.master=mymaster\n# 连接的不再是一个具体redis主机,书写的是多个哨兵节点\nspring.redis.sentinel.nodes=192.168.202.206:26379\n```\n\n- **注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)**\n- **解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限**\n\n<img width=\"700px\" src=\"image-20200629154647970.png\" />\n\n## 14. Redis集群\n\n### 14.1 集群\n\nRedis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持节点的自动发现,支持slave-master选举和容错,支持在线分片(sharding shard )等特性。reshard\n\n### 14.2 <img width=\"700px\" src=\"wpsgRnQP8.jpg)\" />\n### 14.3 集群细节\n\n```markdown\n- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.\n- 节点的fail是通过集群中超过半数的节点检测失效时才生效. \n- 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可\n- redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->value\n```\n\n<img width=\"700px\" src=\"image-20200629165226329.png\" />\n\n### 14.4 集群搭建\n\n判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数，**搭建集群至少需要三个主节点,三个从节点,至少需要6个节点**。\n\n```markdown\n# 1.准备环境安装ruby以及redis集群依赖\n- yum install -y ruby rubygems\n- gem install redis-xxx.gem\n\n```\n\n<img width=\"700px\" src=\"image-20200627193219366.png\" />\n\n<img width=\"700px\" src=\"image-20200627193348905.png\" />\n\n```markdown\n# 2.在一台机器创建7个目录\n```\n\n<img width=\"700px\" src=\"image-20200627193849867.png\" />\n\n```markdown\n# 3.每个目录复制一份配置文件\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/\n```\n\n<img width=\"700px\" src=\"image-20200627194103354.png\" />\n\n```markdown\n# 4.修改不同目录配置文件\n- port \t6379 .....                \t\t //修改端口\n- bind  0.0.0.0                   \t\t //开启远程连接\n- cluster-enabled  yes \t        \t\t\t //开启集群模式\n- cluster-config-file  nodes-port.conf //集群节点配置文件\n- cluster-node-timeout  5000      \t   //集群节点超时时间\n- appendonly  yes   \t\t               //开启AOF持久化\n\n# 5.指定不同目录配置文件启动七个节点\n- [root@localhost bin]# ./redis-server  /root/7000/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7001/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7002/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7003/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7004/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7005/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7006/redis.conf\n```\n\n<img width=\"700px\" src=\"image-20200627194913866.png\" />\n\n```markdown\n# 6.查看进程\n- [root@localhost bin]# ps aux|grep redis\n```\n\n<img width=\"700px\" src=\"image-20200627194954143.png\" />\n\n#### 1.创建集群\n\n```markdown\n# 1.复制集群操作脚本到bin目录中\n- [root@localhost bin]# cp /root/redis-4.0.10/src/redis-trib.rb .\n\n# 2.创建集群\n- ./redis-trib.rb create --replicas 1 192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005\n```\n\n<img width=\"700px\" src=\"image-20200627195601307.png\" />\n\n```markdown\n# 3.集群创建成功出现如下提示\n```\n\n<img width=\"700px\" src=\"image-20200627195647767.png\" />\n\n#### 2.查看集群状态\n\n```markdown\n# 1.查看集群状态 check [原始集群中任意节点] [无]\n- ./redis-trib.rb check 192.168.202.205:7000\n\n# 2.集群节点状态说明\n- 主节点 \n\t主节点存在hash slots,且主节点的hash slots 没有交叉\n\t主节点不能删除\n\t一个主节点可以有多个从节点\n\t主节点宕机时多个副本之间自动选举主节点\n\n- 从节点\n\t从节点没有hash slots\n\t从节点可以删除\n\t从节点不负责数据的写,只负责数据的同步\n```\n\n#### 3.添加主节点\n\n```markdown\n# 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]\n- ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005\n- 注意:\n\t1.该节点必须以集群模式启动\n\t2.默认情况下该节点就是以master节点形式添加\n```\n\n#### 4.添加从节点\n\n```markdown\n# 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]\n- ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000\n- 注意:\n\t当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点\n\t\n# 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]\n- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000\n```\n\n#### 5.删除副本节点\n\n```markdown\n# 1.删除节点 del-node [集群中任意节点] [删除节点id]\n- ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1\n- 注意:\n 1.被删除的节点必须是从节点或没有被分配hash slots的节点\n```\n\n#### 6.集群在线分片\n\n```markdown\n# 1.在线分片 reshard [集群中任意节点] [无]\n- ./redis-trib.rb  reshard  192.168.1.158:7000\n```\n\n----\n\n## 15.Redis实现分布式Session管理\n\n### 15.1 管理机制\n\n**redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据。**\n\n<img width=\"700px\" src=\"image-20200628201643358.png\" />\n\n### 15.2 开发Session管理\n\n#### 1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.session</groupId>\n  <artifactId>spring-session-data-redis</artifactId>\n</dependency>\n```\n\n#### 2. 开发Session管理配置类\n\n```java\n@Configuration\n@EnableRedisHttpSession\npublic class RedisSessionManager {\n   \n}\n```\n\n#### 3.打包测试即可\n\n----\n\n\n\n","tags":["database","redis"],"categories":["database","redis"]},{"title":"Linux study Record","url":"/2020/08/21/Linux-Study-Record/","content":"\n\n\n# CentOS 7 安装完成后初始化配置\n\n## 网络配置\n\n```linux\n# 通过下面命令查询机器的网卡名\nip addr\n\nvi /etc/sysconfig/network-scripts/ifcfg-eth0\n\nTYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=dhcp\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=eth0\nUUID=c342a3ec-d2f5-48f9-a858-6dae42718cc5\nDEVICE=eth0\nONBOOT=yes\t# 开机自动启动网卡\n```\n\n\n\n","tags":["linux"]},{"title":"《尚硅谷Mycat教程》study notes","url":"/2020/08/21/《尚硅谷Mycat教程》study-notes/","content":"\n\n\n# 环境准备\n\n>  linux （CentOS-7-x86_64-DVD-2003.iso）\n\n# MyCat下载与安装\n\n```linux\ncd /opt\nwget http://dl.mycat.org.cn/1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz\n\n# z 按照gzip筛选； x 解压操作；v 显示信息； f 指定文件\n\ntar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz\n\n# -r 递归拷贝\ncp -r mycat/ /usr/local/\n```\n\n- 三个配置文件\n\n> schema.xml:定义逻辑库，表、分片节点等内容 \n>\n> rule.xml:定义分片规则 \n>\n> server.xml:定义用户以及系统相关变量，如端口等\n\n# MyCat启动\n\n- 修改配置文件\n\n```linux\n# 修改 /mycat/conf/server.xml user为mycat\n\n<user name=\"user\">\n\t\t<property name=\"password\">user</property>\n\t\t<property name=\"schemas\">TESTDB</property>\n\t\t<property name=\"readOnly\">true</property>\n\t</user>\n```\n\n","tags":["mysql","mycat"],"categories":["mysql","mycat"]},{"title":"《MyCAT+MySQL 搭建高可用企业级数据库集群》study notes","url":"/2020/08/20/《MyCAT-MySQL-搭建高可用企业级数据库集群》study-notes/","content":"\n\n\n# MyCat简介\n\n​\t\tMyCat 是目前最流行的`基于 java` 语言编写的`数据库中间件`，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是`分库分表`。配合数据库的主从模式还可实现`读写分离`。\n  \tMyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。\n\n<br>\n\n<img width=\"700px\" src=\"WechatIMG203.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG204.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG205.png\" /><br>\n\n## MyCat主要作用\n\n<img width=\"700px\" src=\"WechatIMG206.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG207.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG208.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG209.png\" /><br>\n\n## MyCat的基本元素\n\n<img width=\"700px\" src=\"WechatIMG210.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG211.png\" /><br>\n\n\n\n# MyCat安装\n\n## 安装步骤\n\n<img width=\"700px\" src=\"WechatIMG212.png\" /><br>\n\n- 下载安装mycat\n\n```linux\ncd /usr/local\n\nwget http://dl.mycat.org.cn/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz\n\ntar zxf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz\n\nchown mycat:mycat -R mycat/\n```\n\n- 下载安装jdk\n\n```linux\ncd /usr/local\n\nwget https://repo.huaweicloud.com/java/jdk/7u80-b15/jdk-7u80-linux-x64.tar.gz\n\ntar zxf jdk-7u80-linux-x64.tar.gz\n\nmkdir /usr/local/java\n\nmv ./jdk1.7.0_80/ /usr/local/java\n```\n\n- Add user\n\n```linux\nadduser mycat\n```\n\n- 修改mycat运行内存\n\n```linux\n# mycat目录下的 conf/wrapper.conf 文件配置了mycat运行所需要的内存大小\nwrapper.java.additional.5=-XX:MaxDirectMemorySize=2G\n\nfree -m # 查看linux的内存\n\nvi wrapper.conf\n\nwrapper.java.additional.5=-XX:MaxDirectMemorySize=256M\n```\n\n- 配置环境变量\n\n```linux\nvim /etc/profile\n\nexport PATH=$PATH:/usr/local/mycat/bin:/usr/local/java/jdk1.7.0_80/bin\n\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_80\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n\nexport MYCAT_HOME=/usr/local/mycat\n\nsource /etc/profile\n\n# 验证jdk是否安装成功\njava -version\n```\n\n- mycat\n\n```linux\nmycat start \n\n# mycat/logs/wrapper.log 记录了启动信息\n```\n\n\n\n\n\n# 课程实例使用的数据库对象\n\n<img width=\"700px\" src=\"WechatIMG199.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG200.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG201.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG202.png\" /><br>\n\n\n\n# MyCat配置文件\n\n<img width=\"700px\" src=\"WechatIMG213.png\" /><br>\n\n## server.xml\n\n- 配置系统相关参数\n- 配置用户访问权限\n- 配置SQL防火墙以及SQL拦截功能\n\n\n\n\n\n","tags":["mysql","mycat"],"categories":["mysql","mycat"]},{"title":"《一站式学习Redis 从入门到高可用分布式实践》study notes","url":"/2020/08/06/《一站式学习Redis-从入门到高可用分布式实践》study-notes/","content":"\n# redis初识\n\n## redis特性\n\n- 速度快（官方：10w OPS）\n\n> **数据存在内存中**（速度快的主要原因）\n>\n> C语言编写\n>\n> 单线程\n\n- 持久化（断电不丢数据）\n\n> redis所有数据保存在内存中，对数据的更新将异步的保存到磁盘上\n\n> \n>\n> 多种数据结构\n>\n> 支持多种编程语言\n>\n> 功能丰富\n>\n> 简单\n>\n> 主从复制\n>\n> 高可用、分布式\n\n## redis适用场景\n\n\n\n## redis实验环境搭建\n\n### 环境准备\n\n（1）Parallels Desktop\n\n（2）CentOS（CentOS-7-x86_64-DVD-2003.iso）\n\n（3）网络环境：桥接网络（WI-FI）\n\n（4）linux网络配置\n\n```linux\n# 通过ip addr 命令获取网卡名称\nip addr\n\nvi /etc/sysconfig/network-scripts/ifcfg-eth0\n\nTYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=dhcp\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=eth0\nUUID=c342a3ec-d2f5-48f9-a858-6dae42718cc5\nDEVICE=eth0\nONBOOT=yes # 开机自动启动网卡\n```\n\n<br>\n\n- 修改主机名\n\n```linux\nvi /etc/hostname\n\nsorozy-redis\n\n# 重启生效\nreboot\n```\n\n<br>\n\n### redis下载与安装\n\n```linux\n# 确保wget可以使用\nyum install wget -y\n\n# 下载相关依赖库\nyum install gcc-c++ -y\n\ncd /opt/soft\n\nwget http://download.redis.io/releases/redis-3.0.7.tar.gz\n\n# 解压缩\ntar -xvf redis-3.0.7.tar.gz\n\n# 建立软连接\nln -s redis-3.0.7 redis\n\ncd redis\n\nmake\n\n# make MALLOC=libc\n\nmake install\n\ncd src\n\nll | grep redis-\n\n```\n\n<br>\n\n### 启动方式一：在任意目录下启动redis（默认启动方式，非守护进程）\n\n```linux\nredis-server\n```\n\n### 启动方式二：在任意目录下使用redis客户端连接redis\n\n```linux\n# 动态参数启动redis\nredis-cli -h 127.0.0.1 -p 6379\nredis-server --port 6380\n```\n\n### 启动方式三：配置文件方式启动（建议在生产环境使用这种方式）\n\n#### 准备工作\n\n```linux\n# 配置文件方式启动\ncd /opt/soft/redis\n\nmkdir config\n\ncp redis.conf config\n\ncd config\n\nmv redis.conf redis-6381.conf\n\n# 查看的时候去除空格和注释\ncat redis-6381.conf | grep -v \"#\" | grep -v \"^$\"\n\ncat redis-6381.conf | grep -v \"#\" | grep -v \"^$\" > redis-6382.conf\n```\n\n<br>\n\n```linux\ncat redis-6382.conf\n\ndaemonize no\npidfile /var/run/redis.pid\nport 6379\ntcp-backlog 511\ntimeout 0\ntcp-keepalive 0\nloglevel notice\nlogfile \"\"\ndatabases 16\nsave 900 1\nsave 300 10\nsave 60 10000\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\ndbfilename dump.rdb\ndir ./\nslave-serve-stale-data yes\nslave-read-only yes\nrepl-diskless-sync no\nrepl-diskless-sync-delay 5\nrepl-disable-tcp-nodelay no\nslave-priority 100\nappendonly no\nappendfilename \"appendonly.aof\"\nappendfsync everysec\nno-appendfsync-on-rewrite no\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\naof-load-truncated yes\nlua-time-limit 5000\nslowlog-log-slower-than 10000\nslowlog-max-len 128\nlatency-monitor-threshold 0\nnotify-keyspace-events \"\"\nhash-max-ziplist-entries 512\nhash-max-ziplist-value 64\nlist-max-ziplist-entries 512\nlist-max-ziplist-value 64\nset-max-intset-entries 512\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\nhll-sparse-max-bytes 3000\nactiverehashing yes\nclient-output-buffer-limit normal 0 0 0\nclient-output-buffer-limit slave 256mb 64mb 60\nclient-output-buffer-limit pubsub 32mb 8mb 60\nhz 10\naof-rewrite-incremental-fsync yes\n```\n\n<br>\n\n```linux\nvim redis-6382.conf\n\ndaemonize yes # 是否以守护进程的方式启动\n# pidfile /var/run/redis.pid # 进程号存储位置，实际上还是需要用端口号进行区别\nport 6382\t# 端口号\ndir \"/opt/soft/redis/data\" # 工作目录\nlogfile \"6382.log\"\n```\n\n<br>\n\n```linux\ncd /opt/soft/redis\n\nmkdir data\n```\n\n#### 配置文件方式启动\n\n```linux\nredis-server config/redis-6382.conf\n\n# 查看进程\nps -ef | grep redis-server | grep 6382\n\n# 查看日志\ncd data\ncat 6382.log\n```\n\n\n\n# Redis API的理解和使用\n\n- 通用命令\n- 字符串类型\n- 哈希类型\n- 列表类型\n- 集合类型\n- 有序集合类型\n\n## 通用命令\n\n```redis\n# 计算数据库中所有的健，一般不在生产环境使用，O(n)的命令\nkeys\n\n\n\n\n# 算出数据库的大小,O(1),有内置计数器\ndbsize\n\n# 判断一个key是否存在 返回 0 / 1 O(1)\nexists key\n\n# 删除多个key O(1)\ndel key [key...]\n\n# 设置key的过期时间 O(1)\nexpire key seconds\n\n# 查询key的过期时间,-1代表没有过期时间，-2 代表已经过期 \nttl key\n\n# 去掉 key 的过期时间\npersist key\n\n# key的类型，可以返回 String hash list set zset none O(1)\ntype key\n\n\n```\n\n\n\n- 数据结构和内部编码\n\n<img width=\"500px\" src=\"WechatIMG14.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG15.png\" /><br>\n\n- 单线程架构\n\n<img width=\"500px\" src=\"WechatIMG16.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG17.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG18.png\" /><br>\n\n\n\n## 字符串\n\n- 对于redis来说所有的key都是字符串\n- value限制512M\n\n- 使用场景\n\n> 缓存、计数器、分布式锁\n\n<img width=\"500px\" src=\"WechatIMG20.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG21.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG22.png\" /><br>\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n---\n\n","tags":["database","redis"],"categories":["database","redis"]},{"title":"XML文件的读写","url":"/2020/07/29/XML文件的读写/","content":"\n\n\nXML 指可扩展标记语言（e**X**tensible **M**arkup **L**anguage）。\n\nXML 被设计用来传输和存储数据。\n\n","tags":["xml"]},{"title":"《Linux核心技能与应用》study notes","url":"/2020/07/24/《Linux核心技能与应用》study-notes/","content":"\n# 环境\n\n> Centos 7、VirtualBox、git、Apache、Nginx、Squid、Bash\n\n# 快捷键\n\n```linux\n\n\n# tab补全补全命令\n# 上、下键\n\nhistory \n\nctrl + L / clean # 清屏\n\nctrl + a # 光标跳到一行命令的开头\nctrl + E # 光标跳到一行命令的结尾\nctrl + U # 删除光标左侧的字符\nctrl + K # 删除光标右侧的字符\nctrl + W # 删除光标左侧的一个单词\nctrl + Y # 粘贴用 ctrl + U / ctrl + K / ctrl + W\n\n\n# 显示当前目录路径\npwd\n\n# 获取命令的可执行文件的位置\nwhich\n例如：which pwd\n\n# 列出当前目录下的文件和目录\nls\n\n# a 表示 all \nls -a # 显示所有的文件目录，包括隐藏文件\nls --all\nls -l # 显示详细信息\nls -lh\nls -t # 按修改时间降序排列\n\n# 显示目录包含的文件大小\ndu\ndu -h\ndu -a\ndu -s\n\n\ncat 一次显示文件所有内容\nless\nhead -n\ntail -n\n\ntouch\nmkdir\nmkdir -p a/b/c # 递归的创建目录\n\ncp file_name new_file_name\ncp -r # 递归的拷贝目录\n\nmv # 移动或重命名目录\n\nln # 创建链接\n\n# 硬链接、软链接\nln file1 file2 # 创建硬链接\nln -s file1 file2 # 创建软链接\n\n\nsudo su\nadduser\npasswd thomas\nuserdel -r thomas\n\ngroupadd\nusermod -g [group_name] [user_name]\n\nchown [user_name] [file_name]\n\nchgrp [user_name] [file_name]\n\nchmod 600 [file_name] \n\nlocate\n\n```\n\n\n\n- grep命令：筛选数据\n\n```linux\ngrep text file\t# 在file文件中搜索'text'文字，区分大小写\n\ngrep -i text file # 忽略大小写\n\ngrep -n text file # -n 显示行号\n\n# -v 显示文本不包含字符串的行\n# -r 在所有的子文件子目录中查找（递归查找）\n\n# rgrep 相当于grep -r\n\n# -E 或 --extended-regexp : 将样式为延伸的正则表达式来使用\n```\n\n","tags":["linux"],"categories":["linux"]},{"title":"《MySQL必知必会》read notes","url":"/2020/07/22/《MySQL必知必会》read-notes/","content":"\n\n\n- 学习备注\n\n  > mysql 正则这块不是很熟悉\n\n  \n\n---\n\n# 数据库基础知识\n\n- 数据库(database) \n\n> 保存有组织的数据的容器(通常是一个文 件或一组文件)。\n>\n> 数据库软件应称为DBMS(数据库管理系统)。数据库 是通过DBMS创建和操纵的容器。\n\n- 表(table)： 某种特定类型数据的结构化清单\n- 列(column) ：表中的一个字段\n- 数据类型(datatype) ：所容许的数据的类型。每个表列都有相 应的数据类型，它限制(或容许)该列中存储的数据\n- 行(row)： 表中的一个记录\n- 主键(primary key)：一列(或一组列)，其值能够唯一区分表 中每个行\n- SQL(Structured Query Language)：SQL是一种专门用来与数据库通信的语言\n\n# 使用MySQL\n\n```mysql\nUSE [database_name]\n\nSHOW DATABASES;\n\nSHOW TABLES;\n\nSHOW COLUMNS FROM customers;\n\nSHOW STATUS # 用于显示广泛的服务器状态信息;\n\nSHOW CREATE DATABASE\n\nSHOW CREATE TABLE\n\nSHOW GRANTS\n\nSHOW ERRORS;\nSHOW WARNINGS;\n# 用来显示服务器错误或警告消息\n```\n\n\n\n# SELECT\n\n```mysql\n\nselect * from [table_name];\n\nselect distinct id,name from [table_name]; # 作用于所有列\n\nselect id from [table_name] limit 5;\n\nselect id from [table_name] limit 5; # 返回从第5行开始的5行\n\n# 检索出来的第一行为行0而不是行1。因此，LIMIT1,1 将检索出第二行而不是第一行\n\nselect name,id from [table_name] order by name,id;\n\n# order by ,默认升序，ASC 升序，DESC 降序\n\n```\n\n# WHERE\n\n```mysql\n# where 子句操作符\n=\n<>\n!=\n<\n<=\n>\n>=\nBETWEEN\n\n# BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。\nselect prod_price from [table_name] where prod_price between 5 and 10;\n\nIS NULL\n\nAND 的计算次序高于 OR\n\nIN\nNOT IN\n\n# 通配符 % _\n\nlike '1000'\nregexp '1000'\n\n# LIKE匹配整个列。如果被匹配的文本在列值 中出现，LIKE将不会找到它，相应的行也不被返回(除非使用 通配符)。而REGEXP在列值内进行匹配，如果被匹配的文本在 列值中出现，REGEXP将会找到它，相应的行将被返回。\n\n# |为正则表达式的OR操作 符。它表示匹配其中之一\n```\n\n\n\n# 计算字段\n\n```mysql\nconcat()\n\nLeft() 返回串左边的字符\nLength() 返回串的长度\nLocate() 找出串的一个子串\nLower() 将串转换为小写\nLTrim() 去掉串左边的空格\nRight() 返回串右边的字符\nRTrim() 去掉串右边的空格\nSoundex() 返回串的SOUNDEX值\nSubString() 返回子串的字符\nUpper() 将串转换为大写\n\n\n# 数值处理\nAbs() 返回一个数的绝对值\nRand() 返回一个随机数\nSqrt() 返回一个数的平方根\n\nAVG() 返回某列的平均值\nCOUNT() 返回某列的行数\nMAX() 返回某列的最大值\nMIN() 返回某列的最小值\nSUM() 返回某列值之和\n\n# 使用COUNT(column)对特定列中具有值的行进行计数，忽略 NULL值\n\n\n```\n\n<br>\n\n```mysql\nHAVING 和 WHERE 的差别:\n这里有另一种理解方法，WHERE在数据 分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重 要的区别，WHERE排除的行不包括在分组中。\n```\n\n\n\n- Select 子句顺序\n\n```mysql\nselect\nfrom\nwhere\ngroup by\nhaving\norder by\nlimit\n```\n\n<br>\n\n```mysql\nUNION\nUNION ALL\n\nmath() against()\n```\n\n# INSERT\n\n```mysql\ninsert into values (),();\ninsert into values select * from [table_name]\n```\n\n\n\n# UPDATE\n\n```mysql\nupdate [table_name] set name='',age=18 where id='1';\n\nupdate ignore [table_name] ... # 如果某条语句出错，则 取消所有更新\n```\n\n\n\n# DELETE\n\n```mysql\ndelete from [table_name] where id='1';\n\ndelete from [table_name];\ntruncate from [table_name];\n```\n\n\n\n# CREATE\n\n```mysql\ncreate table [table_name] {\n\tid int auto_increment,\n\tname char(50),\n\tprimary key(id)\n\t\n} engine =InnoDB\n```\n\n\n\n# ALTER\n\n```mysql\nalter table [table_name] add tel char(20);\n\nalter table [table_name] drop column [age];\n\ndrop table [table_name]\n\nrename table [table_name] to [table_name1]\n\n```\n\n\n\n# VIEW\n\n```mysql\ncreate view [view_name] as select * from [table_name]\n\nshow create view [view_name];\n\ndrop view [view_name];\n```\n\n\n\n# 存储过程\n\n```mysql\ncreate procedure getDate()\n  begin\n    select now();\n  end;\n  \n \ncall getDate();\n\ndrop procedure getDate;\n\nshow create procedure getDate;\n```\n\n","tags":["mysql","database","read-notes"],"categories":["mysql","database","read-notes"]},{"title":"新锐台球教程 study notes","url":"/2020/07/21/新锐台球教程-study-notes/","content":"\n\n\n# 台球入门教学-击球动作和出杆（一级）\n\n- 手架\n\n> 放稳：手掌不要悬空，小臂放在台面上，小臂不要太直，不需要太用力\n>\n> 距离：适中，不要太近，也不要太远\n\n- 握杆\n\n> 虎口贴住球杆，拇指和食指握住球杆，其他指头轻轻贴住球杆\n>\n> **后手放松**\n>\n> 一松一合\n\n- 站位\n\n> 右脚脚后跟站到击球线上\n>\n> 入位\n\n- 俯身\n\n- 运杆\n\n> 通过小臂摆动找到击球的感觉\n>\n> 前停，后停\n\n- 练习直球\n\n> 固定站位，手架，运杆节奏\n\n## 练习\n\n1. 五分点直球，连续进球\n2. 中线摆放15颗球，练习进球\n\n","tags":["台球"],"categories":["台球"]},{"title":"牛课网算法初级班课程 study notes","url":"/2020/07/20/牛课网算法初级班课程-study-notes/","content":"\n","tags":["data-structure","algorithm"],"categories":["data-structure","algorithm"]},{"title":"《MySQL 8.0详解与实战》study notes","url":"/2020/07/02/《MySQL-8-0详解与实战》study-notes/","content":"\n- 学习备注与扩展\n\n> 1. 数据库需求分析，设计这块，后续需要自己跟着老师的设计进行思考，再学习一遍。（第三章前面部分）\n>2. 需要熟悉各个常见MySQL引擎，了解使用场景，优缺点等等。\n> 3. 熟悉（记忆、理解）三范式\n\n- 学习环境\n\n> MySQL8.0.15、CentOS7、SQLyog\n\n---\n\n\n\n# 数据库选型\n\n## SQL（关系型数据库）\n\n- MySQL、oracle、SQLServer、PostGreSQL\n\n- 特点\n\n  1. 数据结构化存储在二维表中\n\n  2. 支持事物的ACID特性\n\n  3. 支持使用SQL语言对存储在其中的数据进行操作\n\n### 适用场景\n\n1. 数据之间存在着一定关系，需要关联查询数据的场景\n\n2. 需要事物支持业务场景\n\n3. 需要使用SQL语言灵活操作数据的场景\n\n## NOSQL（非关系型数据库）\n\n- HBase、MOngoDB、Redis、Hadoop\n\n- 特点\n  1. 存储结构灵活，没有固定的结构\n  2. 对事物的支持比较弱，但对数据的并发处理性能高\n  3. 大多不使用SQL语言操作数据\n\n### 适用场景\n\n1. 数据结构不固定的场景\n2. 对事物要求不高，但读写并发比较大的场景\n3. 对数据的处理操作比较简单的场景\n\n## 关系型数据库选型原则\n\n- 广泛性、可扩展性、安全性和稳定性、数据库所支持的系统、使用成本\n\n## 选择MySQL数据库\n\n- 可扩展性\n\n  1. 支持基于二进制日志的逻辑复制\n\n  2. 存在多种第三方数据库中间层，支持读写分离、分库分表\n\n- 安全性和稳定性\n\n  1. MySQL主从复置集群可达到99%的可用性\n\n  2. 配合主从复置高可用架构可以达到99%的可用性\n\n  3. 支持对存储在MySQL的数据进行分级安全控制\n\n- 支持的系统：支持Windows、linux系统\n\n- 使用成本\n\n  1. 社区版本免费\n\n  2. 使用人员众多，方便获取技术支持\n\n# MySQL实验环境搭建\n\n## 环境准备\n\n- VirtualBox、CentOS-7-x86_64-DVD-1611.iso、MySQL8.0.15、\n\n## 虚拟机环境搭建\n\n（1）安装 VirtualBox\n\n（2）在 VirtualBox 中安装 CentOS（CentOS-7-x86_64-DVD-1611）\n\n​\t\t设置网络为桥接网卡\n\n（3）配置虚拟机环境\n\n- 设置静态ip\n\n  ```shell\n  cd /etc/sysconfig/network-scripts\n  \n  # 通过ip addr 命令获取网卡名称\n  ip addr\n  \n  vi ifcfg-enp0s3\n  ```\n\n  ```shell\n  TYPE=Ethernet\n  BOOTPROTO=none\t# 关闭自动获取ip，设置为静态ip\n  DEFROUTE=yes\n  PEERDNS=yes\n  PEERROUTES=yes\n  IPV4_FAILURE_FATAL=no\n  IPV6INIT=no\t# 关闭ipv6\n  IPV6_AUTOCONF=yes\n  IPV6_DEFROUTE=yes\n  IPV6_PEERDNS=yes\n  IPV6_PEERROUTES=yes\n  IPV6_FAILURE_FATAL=no\n  IPV6_ADDR_GEN_MODE=stable-privacy\n  NAME=enp0s3\n  UUID=c43ba353-8a1c-4c0c-9c24-04d308950e1b\n  DEVICE=enp0s3\n  ONBOOT=yes\t# 开机自动启动网卡\n  IPADDR=10.2.103.103\t# 配置静态ip\n  NETMASK=255.255.254.0\t# 子网掩码\n  GATEWAY=10.2.103.254\t# 网关\n  DNS1=8.8.8.8\n  ```\n\n- 修改主机名\n\n  ```shell\n  vi /etc/hostname\n  \n  sorozy-mysql\n  \n  reboot\n  ```\n\n## 下载、安装与配置MySQL8.0.15\n\n```shell\n# 确保wget可以使用\nyum install wget -y\n\n# 一般安装在 /usr/local 目录下\ncd /usr/local\n\n# 下载mysql安装包\nwget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz\n\n# 或者上传下载好的文件到linux下\nscp -P 22 /Users/sorozy/Documents/bak/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz root@172.20.94.39:/usr/local/\n\n# 解压缩\nxz -d mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz\n\n# 提取文件\ntar xf mysql-8.0.15-linux-glibc2.12-x86_64.tar\n# 迁移并更名至 /usr/local/mysql 目录下\nmv mysql-8.0.15-linux-glibc2.12-x86_64 mysql\n\n# 创建mysql用户,专门启动服务\nuseradd mysql\n\n# 修改my.cnf\nvi /etc/my.cnf\n```\n\n- 修改my.cnf\n\n  ```shell\n  [client]\n  port            = 3306\n  socket          = /usr/local/mysql/data/mysql.sock\n  [mysqld]\n  # Skip #\n  #skip_name_resolve              = 1\n  #skip_external_locking          = 1 \n  #skip_symbolic_links     = 1\n  # GENERAL #\n  user = mysql\n  default_storage_engine = InnoDB\n  character-set-server = utf8\n  socket  = /usr/local/mysql/data/mysql.sock\n  pid_file = /usr/local/mysql/data/mysqld.pid\n  basedir = /usr/local/mysql\n  port = 3306\n  bind-address = 0.0.0.0\n  #explicit_defaults_for_timestamp = off\n  sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n  #read_only=on\n  # MyISAM #\n  key_buffer_size                = 32M\n  #myisam_recover                 = FORCE,BACKUP\n  \n  # undo log #\n  innodb_undo_directory = /usr/local/mysql/undo\n  innodb_undo_tablespaces = 8\n  \n  # SAFETY #\n  max_allowed_packet             = 100M\n  max_connect_errors             = 1000000\n  sysdate_is_now                 = 1\n  #innodb = FORCE\n  #innodb_strict_mode = 1\n  secure-file-priv='/tmp'\n  default_authentication_plugin='mysql_native_password'\n  # Replice #\n   server-id = 1001\n   relay_log = mysqld-relay-bin\n   gtid_mode = on\n   enforce-gtid-consistency\n   log-slave-updates = on\n   master_info_repository =TABLE\n   relay_log_info_repository =TABLE\n  \n  \n  # DATA STORAGE #\n   datadir = /usr/local/mysql/data/\n   tmpdir = /tmp\n   \n  # BINARY LOGGING #\n   log_bin = /usr/local/mysql/sql_log/mysql-bin\n   max_binlog_size = 1000M\n   binlog_format = row\n   binlog_expire_logs_seconds=86400\n  # sync_binlog = 1\n  \n   # CACHES AND LIMITS #\n   tmp_table_size                 = 32M\n   max_heap_table_size            = 32M\n   max_connections                = 4000\n   thread_cache_size              = 2048\n   open_files_limit               = 65535\n   table_definition_cache         = 4096\n   table_open_cache               = 4096\n   sort_buffer_size               = 2M\n   read_buffer_size               = 2M\n   read_rnd_buffer_size           = 2M\n  # thread_concurrency             = 24\n   join_buffer_size = 1M\n  # table_cache = 32768\n   thread_stack = 512k\n   max_length_for_sort_data = 16k\n  \n  \n   # INNODB #\n   innodb_flush_method            = O_DIRECT\n   innodb_log_buffer_size = 16M\n   innodb_flush_log_at_trx_commit = 2\n   innodb_file_per_table          = 1\n   innodb_buffer_pool_size        = 256M\n   #innodb_buffer_pool_instances = 8\n   innodb_stats_on_metadata = off\n   innodb_open_files = 8192\n   innodb_read_io_threads = 16\n   innodb_write_io_threads = 16\n   innodb_io_capacity = 20000\n   innodb_thread_concurrency = 0\n   innodb_lock_wait_timeout = 60\n   innodb_old_blocks_time=1000\n   innodb_use_native_aio = 1\n   innodb_purge_threads=1\n   innodb_change_buffering=all\n   innodb_log_file_size = 64M\n   innodb_log_files_in_group = 2\n   innodb_data_file_path  = ibdata1:256M:autoextend\n   \n   innodb_rollback_on_timeout=on\n   # LOGGING #\n   log_error                      = /usr/local/mysql/sql_log/mysql-error.log\n   # log_queries_not_using_indexes  = 1\n   # slow_query_log                 = 1\n    slow_query_log_file            = /usr/local/mysql/sql_log/slowlog.log\n  \n   # TimeOut #\n   #interactive_timeout = 30\n   #wait_timeout        = 30\n   #net_read_timeout = 60\n  \n  [mysqldump]\n  quick\n  max_allowed_packet = 100M\n  \n  [mysql]\n  no-auto-rehash\n  # Remove the next comment character if you are not familiar with SQL\n  #safe-updates\n  \n  [myisamchk]\n  key_buffer_size = 256M\n  sort_buffer_size = 256M\n  read_buffer = 2M\n  write_buffer = 2M\n  \n  [mysqlhotcopy]\n  interactive-timeout\n  ```\n\n- 新建文件目录\n\n  ```shell\n  cd /usr/local/mysql/\n  \n  mkdir data sql_log undo\n  \n  chown mysql:mysql -R data/ sql_log/ undo/\n  ```\n\n- 环境变量配置\n\n  ```shell\n  vi /etc/profile\n  \n  # 添加下面这行代码\n  export PATH=$PATH:/usr/local/mysql/bin\n  \n  source /etc/profile\n  ```\n\n## 初始化与启动MySQL\n\n```=mysql --basedir=linux\n# 在mysql 5.7之后使用mysqld初始化mysql数据库，以及相关系统表，\n# mysqld --initialize 表示初始化\n# --user=mysql 启动用户\n# --basedir=/usr/local/mysql 安装目录\n# 数据目录 --datadir=/usr/local/mysql/data\n\nmysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data\n# 可能会有报错，根据报错信息修改即可\n\n# 初始化完成之后可以在data目录看到初始化好后的数据库系统文件/数据\n```\n\n- start\n\n  ```shell\n  # 进入/usr/local/mysql/support-files\n  cp mysql.server /etc/init.d/mysqld\n  \n  /etc/init.d/mysqld start\n  \n  # 查看mysql进程\n  ps -ef | grep mysql\n  ```\n\n- 修改密码\n\n  ```shell\n  cd sql_log/\n  \n  # 得到初始化密码\n  grep password mysql-error.log\n  \n  # 登录进入数据库后修改密码\n  alter user  user() identified by '111111';\n  ```\n\n# 数据库设计实战\n\n## 需求分析与设计\n\n- 宽表存在的问题\n  - 数据插入异常：部分数据由于缺失主键信息而无法写入表中\n  - 数据更新异常：修改一行中某列的值时，同时修改了多行数据\n  - 数据删除异常：删除某一数据时不得不删除另一数据\n  - 数据冗余：相同的数据在一个表中出现了多次\n- 宽表模式存在的问题\n  - 配合列存储的数据报表应用\n\n## 数据库设计三范式\n\n- 第一范式：要求有主键，并且要求每一个字段原子性不可再分\n\n- 第二范式：要求所有非主键字段完全依赖主键，不能产生部分依赖\n\n- 第三范式：非主键列之间不能相互依赖。所有非主键字段和主键字段之间不能产生传递依赖\n\n## 常用MySQL存储引擎\n\n<img width=\"800px\" src=\"WechatIMG165.png\" />\n\n<br>\n\n<img width=\"800px\" src=\"WechatIMG167.png\" />\n\n## 数据类型\n\n<img width=\"800px\" src=\"WechatIMG168.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG169.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG170.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG171.png\" />\n\n## 为数据选择合适的数据类型\n\n<img width=\"800px\" src=\"WechatIMG172.png\" />\n\n## 为表和列选择合适的名字\n\n<img width=\"800px\" src=\"WechatIMG176.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG175.png\" />\n\n# 访问/连接MySQL\n\n- 命令行\n\n```mysql\nmysql -uroot -p -hlocalhost\n```\n\n- 设置mysql可以使用root账户远程登录\n\n```\nupdate user set host='%' where user='root';\nflush privileges;\n```\n\n# SQL\n\n- structured query language\n- RDBMS（关系型数据库管理系统，全称 Relational Database Management Syste）\n\n## 常用的SQL语言种类\n\n### DCL 数据库管理语句/访问控制语句\n\n```sql\n# 创建用户\ncreate user mc_test@'%' identified by '111111' with max_user_connections 1;\n\n# 给账号授权\ngrant\n\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;\n\n# 收回用户权限\nrevoke\n\n# 展示插件\nshow plugins;\n\n# 查看权限\nshow privileges;\n\n\n```\n\n### DDL 数据定义\n\n> create/alter/drop database\n>\n> create/alter/drop table\n>\n> create/drop index\n>\n> truncate table\n>\n> rename table\n>\n> Create/alter/drop view\n\n```sql\nCREATE DATABASE imc_db;\n\ntruncate table [table_name];\n\nrename table [table_name] to [table_name2];\n```\n\n\n\n> DCL 数据库管理语句\n>\n> DDL 数据定义\n>\n> DML 数据操作\n>\n> TCL 事物控制\n\n### DML 表操作\n\n> insert\n> delete\n>\n> update\n>\n> select\n\n```mysql\nselect \"this is mysql course \" like \"%mysql%\";\n\n```\n\n\n\n### TCL\n\n\n\n# SQL优化\n\n## 步骤\n\n> 发现问题>分析执行计划>优化索引>改写SQL\n\n> 数据库垂直切分、数据库水平切分\n\n## 发现有性能问题的SQL\n\n- 用户主动上报应用性能问题\n- 分析慢查询日志，发现存在问题的SQL\n- 数据库实时监控长时间运行的SQL\n\n## 配置慢查询日志\n\n```mysql\n# 开启慢查询日志（on）\nset global slow_query_log = [on|off]\n\n# 配置慢查询日志目录/文件\nset global slow_query_log_file = /sql_log/slowlog.log\n\n# 超过这个执行时间的sql会被记录在日志中，如果记录所有的查询sql，则 参数设置为0即可\nset global long_query_time = xx.xxx 秒\n\n# 所有使未用到索引（on）的sql都会记录到日志中\nset global log_queries_not_using_indexes=[on|off]\n```\n\n## 分析MySQL慢查询日志的工具\n\nmysqldumpslow\n\nPt-query-digest\n\n- 下载安装工具\n\n```linux\n# 访问 https://www.percona.com/downloads/percona-toolkit/LATEST/\n\n# 下载 percona-toolkit-3.0.13-1.el7.x86_64.rpm\n\nwget https://www.percona.com/downloads/percona-toolkit/3.2.0/binary/redhat/7/x86_64/percona-toolkit-3.2.0-1.el7.x86_64.rpm\n\n# 安装相关依赖包\nyum install -y perl-DBD-MySQL.X86_64 perl-DBI.x86 perl-Time-HiRes.x86_64 perl-IO-Socket-SSL.noarch perl-TermReadKey.x86_64 perl-Digest-MD5\n\nrpm -ivh percona-toolkit-3.0.13-1.el7.x86_64.rpm\n```\n\n## 启用慢查询日志\n\n```mysql\nshow variables like 'long_query_time';\n\nset global long_query_time=0;\n\nshow variables like 'slow_query_log';\n\nset global slow_query_log=on;\n\nshow variables like 'slow_query_log_file';\n```\n\n## 分析慢查询日志\n\n```mysql\nmysqldumpslow slowlog.log\n\npt-query-digest slowlog.log\n```\n\n## 实时监控sql\n\n\n\n## 分析SQL执行计划\n\n\n\n### 获取SQL执行计划\n\n\n\n# 事务与并发控制\n\n- 事务是数据库执行操作的最小逻辑单元\n- 事务可以由一个sql组成也可以由多个sql组成\n- 组成事务的sql要么全部成功要么全部失败\n\n```mysql\n# BEGIN 或 START TRANSACTION 显式地开启一个事务\n# COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；\n\n# ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；\n```\n\n## ACID\n\n- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n## 脏读\n\n<img width=\"800px\" src=\"WechatIMG191.png\" />\n\n## 不可重复读\n\n<img width=\"800px\" src=\"WechatIMG192.png\" />\n\n## 幻读\n\n<img width=\"800px\" src=\"WechatIMG193.png\" />\n\n## INNODB的事务隔离级别\n\n<img width=\"800px\" src=\"WechatIMG194.png\" />\n\n默认：可重复读\n\n\n\n## she\n\n\n\n\n\n\n\n\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"MySQL study notes","url":"/2020/07/02/MySQL-study-notes/","content":"\n# MySQL基础\n\n## 基本概念\n\n### DB（DataBase）\n\n数据库， 实际上在硬盘上以文件的形似存在\n\n### DBMS（Database Management System）\n\n数据库管理系统，常见的有：MySQL, Oracle DB2 Sybase, SqlServer...\n\n### SQL（Structured Query Language）\n\n结构化查询语言， 是一门标准通用语言， 标准的sql语句适用于所有的数据库产品\n\n<br>\n\n> DBMS 负责执行 sql 语句， 通过执行 sql 语句来操作 db 中的数据\n> DBMS -（执行）-> SQL 语句 -（操作）-> DB\n\n### table\n\n表是数据库的基本组成单元， 所有的数据都以表格的格式组织\n一个表包括行和列：\n行： 被称为数据/记录\n列：被称为字段\n\n- 每个字段名包含哪些信息：字段名， 数据类型， 相关约束\n\n### sql 语句分类\n\nDQL（Data Query Language）（数据库查询语言）： 查询语句， 凡是 select 语句都是 DQL\nDML（Data Manipulation Language）（数据操作语言）：insert /delete /update 对表当中的数据进行增删改\nDDL（Data Defination Language）（数据定义语言）：create drop alter ， 对表结构的增删改\nTCL（Transaction Control Language）（事务控制语言）：commit 提交事务， rollback 回滚事务\nDCL（Data Control Language）（数据控制语言）：grant 授权， revoke 撤销权限等\n\n## 基本操作\n\n```mysql\n# 登录\nmysql -u用户名 -p密码\n\n# 查看有哪些数据库 (这个不是 SQL 语句，属于 mysql 的命令)\nshow database;\n\n# 创建数据库 (这个不是 SQL 语句，属于 mysql 的命令)\ncreate database [database_name];\n\n# 使用数据库 (这个不是 SQL 语句，属于 mysql 的命令)\nuse [databse_name]\n\n```\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"《Web协议详解与抓包实战》study notes","url":"/2020/07/01/《Web协议详解与抓包实战》study-notes/","content":"\n\n\n# HTTP/1.1协议\n\n- 浏览器发起HTTP请求的典型场景\n\n<img width=\"700px\" src=\"WechatIMG326.png\" />\n\n- HTTP协议的定义\n\n<img width=\"700px\" src=\"WechatIMG327.png\" />\n\n- ABNF\n\n<img width=\"700px\" src=\"WechatIMG328.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG329.png\" />\n\n- 基于ABNF描述的HTTP协议格式\n\n<img width=\"700px\" src=\"WechatIMG330.png\" />\n\n- OSI概念模型\n\n<img width=\"700px\" src=\"WechatIMG332.png\" />\n\n- OSI模型与TCP/IP模型对照\n\n<img width=\"700px\" src=\"WechatIMG332.png\" />\n\n","tags":["network"],"categories":["network"]},{"title":"《透视HTTP协议》study notes","url":"/2020/06/24/《透视HTTP协议》study-notes/","content":"\n# 学习备注\n\n1. 好需要好好熟悉3次握手、四次挥手\n2. 需要对头字段进行整理\n3. 各种方法详解需要熟悉（熟悉自定义方法？）\n4. 安全幂等需要熟悉\n\n---\n\n# HTTP发展史（来龙去脉）\n\n## 来源\n\n1989 年，蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。\n\n> 1. URI：统一资源标识符，作为互联网上资源的唯一身份；\n> 2. HTML：即超文本标记语言，描述超文本文档；\n> 3. HTTP：即超文本传输协议，用来传输超文本。\n\n## HTTP/0.9\n\n20 世纪 90 年代初期发布。\n\n只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接\n\n## HTTP/1.0\n\n1996 年正式发布（确立了大部分现在使用的技术，但它不是正式标准）\n\n> 1. 增加了 HEAD、POST 等新方法；\n> 2. 增加了响应状态码，标记可能的错误原因；\n> 3. 引入了协议版本号概念；\n> 4. 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；\n> 5. 传输的数据不再仅限于文本。\n\n## HTTP/1.1\n\n1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616（它是一个“正式的标准”）\n\n> 1. 增加了 PUT、DELETE 等新的方法；\n> 2. 增加了缓存管理和控制；\n> 3. 明确了连接管理，允许持久连接；\n> 4. 允许响应数据分块（chunked），利于传输大文件；\n> 5. 强制要求 Host 头，让互联网主机托管成为可能。\n\n## HTTP/2\n\n- 连接慢，无法跟上迅猛发展的互联网\n- 2015 年发布了 HTTP/2，RFC 编号 7540\n- HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及（Google 顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议）\n- HTTP/2 的制定充分考虑了现今互联网的现状：**宽带、移动、不安全**，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：\n\n> 1. 二进制协议，不再是纯文本；\n> 2. 可发起多个请求，废弃了 1.1 里的管道；\n> 3. 使用专用算法压缩头部，减少数据传输量；\n> 4. 允许服务器主动向客户端推送数据；\n> 5. 增强了安全性，“事实上”要求加密通信。\n\n## HTTP/3\n\n- Google 又发明了一个新的协议，叫做 QUIC。\n- 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段\n- HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向\n\n# HTTP概念\n\n## HTTP（HyperText Transfer Protocol）超文本传输协议\n\n- 协议\n\n> 协：必须要有两个或多个参与者<br>\n>\n> 议：对参与者的一种行为约定和规范\n\n- 传输\n\n> 发起传输动作的叫做**请求方**<br>\n>\n> 后接到传输的叫做**应答方**或者**响应方**\n\n- 超文本\n\n> HTTP眼里的“文本”：图片、音频、视频、甚至是压缩包<br>\n>\n> 超文本：“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”\n\n## <font color=red >HTTP 是什么？</font>\n\n<font color=red>**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**</font>\n\n<br>\n\n\n- HTTP 不是一个孤立的协议\n\n> <font color=red>HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。</font>此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位\n\n- <font color=red>**HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接**</font>\n\n## HTTP知识地图\n\n<img src=\"http-all.png\" width=\"650\"/>\n\n# 与HTTP相关的各种概念\n\n## 网络世界\n\n- 实际的互联网是由许许多多个规模略小的网络连接而成的\n\n> 这些“小网络”可能是:只有几百台电脑的局域网，可能是有几万、几十万台电脑的广域网，可能是用电缆、光纤构成的固定网络，也可能是用基站、热点构成的移动网络……\n\n- 互联网的正式名称是 Internet\n\n- 互联网的一个子集“万维网”（World Wide Web）(即：我们通常所说的“上网”)\n\n> 它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内\n\n- 万维网之外的资源\n\n> 电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等\n\n- 互联网上绝大部分资源都使用 HTTP 协议传输\n\n## 浏览器（Web Browser）\n\n> 检索、查看互联网上网页资源的应用程序，名字里的 Web，指“World Wide Web”（万维网）\n>\n> 本质上是一个 HTTP 协议中的**请求方**，使用 HTTP 协议获取网络上的各种资源<br>\n\n> 集成了很多额外的功能：HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，甚至还有开发者工具用来调试网页，以及五花八门的各种插件和扩展<br>\n\n> HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求\n\n- Linux上的wget、curl等命令工具基于HTTP，也是一种user agent\n\n## Web 服务器（Web Server）\n\n- HTTP 协议里响应请求的主体\n- 两个层面的含义：硬件和软件\n\n### 硬件\n\n> **硬件**含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。\n\n### 软件\n\n> 提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。\n\n- 常见Web Server\n\n> Apache\n>\n> Nginx：Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展\n>\n> Windows 上的 IIS、Java 的 Jetty/Tomcat 等\n\n## CDN（Content Delivery Network）\n\n- CDN：Content Delivery Network（内容分发网络）\n\n> 应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求\n\n- CDN 位于浏览器和服务器之间\n\n- CDN 的好处：缓存源站的数据\n\n> 除去网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分\n\n## 爬虫（Crawler）\n\n- 一种可以自动访问 Web 资源的应用程序\n\n- 爬虫来源？\n\n> 绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面\n\n- 爬虫不好的一面\n\n> 它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏\n\n- “反爬虫”技术\n\n> 通过各种手段来限制爬虫<br>\n>\n> “君子协定”robots.txt，约定哪些该爬，哪些不该爬\n\n- “爬虫”、“反爬虫”基本技术： HTTP、 HTML\n\n## HTML/WebService/WAF\n\n- **HTML**描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面\n\n- **Web Service**是一种由 W3C 定义的应用服务开发规范\n\n> **基于 Web（HTTP）的服务架构技术**\n\n- **WAF**（“网络应用防火墙”）\n\n> 应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术\n\n> WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx\n\n## TCP/IP\n\n- TCP/IP 协议是目前网络世界“事实上”的标准通信协议\n- TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是**TCP**和**IP**，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈\n- **TCP 属于“传输层”，IP 属于“网际层”**\n\n### IP协议（Internet Protocol）\n\n---\n\n- 主要解决寻址和路由问题，以及如何在两点间传送数据包\n- IP 协议使用“**IP 地址**”的概念来定位互联网上的每一台计算机\n\n### TCP 协议（Transmission Control Protocol）（传输控制协议）\n\n- 位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础\n\n> “可靠”是指保证数据不丢失<br>\n>\n> “字节流”是指保证数据完整\n\n> <font color=red>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收</font>\n\n## DNS（Domain Name System）（域名系统)\n\n- 在DNS中，“域名”（Domain Name）又称为“主机名”（Host）\n\n更多请参考：[DNS](#DNS)\n\n## URI/URL\n\n更多请参考：[URI](#URI)\n\n## HTTPS（HTTP over SSL/TLS）\n\n- 运行在 SSL/TLS 协议上的 HTTP\n- HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”\n\n### SSL/TLS\n\n- 负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层\n- SSL：（Secure Socket Layer）后改名（Transport Layer Security）\n- SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲\n\n##代理（Proxy）\n\n- HTTP 协议中请求方和应答方中间的一个环节，既可以转发客户端的请求，也可以转发服务器的应答\n\n- 常见代理\n\n> 1. 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；\n> 2. 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；\n> 3. 正向代理：靠近客户端，代表客户端向服务器发送请求；\n> 4. 反向代理：靠近服务器端，代表服务器响应客户端的请求；\n\n- 可以做：\n\n> 1. 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；\n> 2. 内容缓存：暂存上下行的数据，减轻后端的压力；\n> 3. 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；\n> 4. 数据处理：提供压缩、加密等额外的功能。\n\n# 网络分层模型\n\n## TCP/IP 网络分层模型\n\n<img src=\"h1.png\" width=\"650\"/>\n\n- 第一层叫“链接层”（link layer）\n\n> 负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。\n\n- 第二层叫“网际层”或者“网络互连层”（internet layer）\n\n> IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。\n\n- 第三层叫“传输层”（transport layer）\n\n> 这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。\n\n- 第四层叫“应用层”（application layer）\n\n> 由于下面的三层把基础打得非常好，所以在这一层就有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 、 HTTP\n\n<br>\n\n> MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包\n\n## OSI 网络分层模型\n\n- OSI：（Open System Interconnection Reference Model）开放式系统互联通信参考模型\n\n<img src=\"h2.png\" width=\"650\"/>\n\n- OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：\n\n> 1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；\n> 2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；\n> 3. 第三层：网络层，相当于 TCP/IP 里的网际层；\n> 4. 第四层：传输层，相当于 TCP/IP 里的传输层；\n> 5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；\n> 6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；\n> 7. 第七层：应用层，面向具体的应用传输数据。\n\n- OSI模型优点\n\n> TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整。\n\n## 两个分层模型的映射关系\n\n<img src=\"h3.png\" width=\"650\"/>\n\n> 1. 第一层：物理层，TCP/IP 里无对应；\n> 2. 第二层：数据链路层，对应 TCP/IP 的链接层；\n> 3. 第三层：网络层，对应 TCP/IP 的网际层；\n> 4. 第四层：传输层，对应 TCP/IP 的传输层；\n> 5. 第五、六、七层：统一对应到 TCP/IP 的应用层。\n\n- 四层负载均衡\n\n> 工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡\n\n- 七层负载均衡\n\n> 工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器\n\n## TCP/IP 协议栈的工作方式\n\n<img src=\"h4.png\" width=\"650\"/>\n\n- 凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。\n\n- 二层转发\n\n> 设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播\n\n- 三层路由\n\n> 设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关\n\n# DNS\n\n## 域名作用与形式\n\n> 1. 代替IP\n>\n> 2. 可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令\n\n- 本质上是一个名字空间系统\n\n- 域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低\n## 域名的解析\n\n- <font color=red>**DNS 的核心系统是一个三层的树状、分布式服务**</font>，基本对应域名的结构：\n\n> 1. 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；\n> 2. 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；\n> 3. 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。\n\n- 目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到\n- 访问“www.apple.com”，就要进行下面的三次查询：\n\n> 1. 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；\n> 2. 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；\n> 3. 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。\n\n## DNS缓存\n\n- 为了提高查询效率，外围有多级的缓存\n\n> 1. 许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理\n> 2. 操作系统里也会对 DNS 解析结果做缓存\n\n## 域名玩法\n\n> 1. 重定向（变更主机ip）\n> 2. 搭建内部DNS\n> 3. 基于域名实现的负载均衡（轮询 or 返回最近主机）\n> 4. 域名屏蔽、域名劫持（域名污染）\n\n## DNS解析过程\n\n> 浏览器缓存->操作系统缓存->hosts->dns\n\n# 搭建HTTP实验环境\n\n- 软件准备\n\n> Wireshark\n>\n> Chrome/Firefox\n>\n> Telnet\n>\n> OpenResty\n\n- 修改hosts文件，添加配置本机 IP 地址到测试域名的映射\n\n```linux\n127.0.0.1       www.chrono.com\n127.0.0.1       www.metroid.net\n127.0.0.1       origin.io\n```\n\n- Mac上 安装 OpenResty\n\n```linux\n# 使用homebrew安装OpenResty （ke能需要用梯子）\nbrew install openresty/brew/openresty\n\n# 执行上面命令 可能出现报错如下：\n    Error: The following directories are not writable by your user:\n    /usr/local/share/man/man8\n\n    You should change the ownership of these directories to your user.\n      sudo chown -R $(whoami) /usr/local/share/man/man8\n\n    And make sure that your user has write permission.\n      chmod u+w /usr/local/share/man/man8\n  \n# 解决方案：在终端执行下面命令\nsudo chown -R `whoami`:admin /usr/local/bin\nsudo chown -R `whoami`:admin /usr/local/share\n\n# 查看是否安装成功\nresty -v\n\n# 执行上面命令出现了下面内容就代表成功了\n    resty 0.23\n    nginx version: openresty/1.15.8.3\n    built by clang 11.0.3 (clang-1103.0.32.62)\n    built with OpenSSL 1.1.0l  10 Sep 2019\n\ngit clone https://github.com/chronolaw/http_study\n\ncd http_study/www/    #脚本必须在www目录下运行，才能找到nginx.conf\n./run.sh start        #启动实验环境\n./run.sh list         #列出实验环境的Nginx进程\n./run.sh reload       #重启实验环境\n./run.sh stop         #停止实验环境\n\n# 启动实验环境后访问 localhost，如果正常访问则环境搭建成功\n\n# 访问localhost 若出现403， 则在 conf/nginx.conf 文件的顶部添加 user xxxx staff，这个 xxxx 是自己的 mac 账户名，再重启实验环境即可\n```\n\n- 用浏览器或者 curl 来验证课程里的各个测试 URI\n\n```linux\ncurl -v \"http://127.0.0.1/\"\ncurl -v \"http://www.chrono.com/09-1\"\ncurl -k \"https://www.chrono.com/24-1?key=1234\"\ncurl -v \"http://www.chrono.com/41-1\"\n```\n\n<br>\n\n# 键入网址再按下回车，后面究竟发生了什么\n\n<img src=\"h5.png\" width=\"650\"/>\n\n- 最简单的浏览器 HTTP 请求过程：\n\n> 1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；\n> 2. 浏览器用 TCP 的三次握手与服务器建立连接；\n> 3. 浏览器向服务器发送拼好的报文；\n> 4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；\n> 5. 浏览器解析报文，渲染输出页面。\n\n\n\n- 当浏览器发现输入的url不是数字形式的IP地址（那就肯定是域名了）于是就会发起域名解析动作，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址\n\n- 域名解析过程\n\n> 操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析\n>\n> 会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址\n>\n> 缓存服务器\n>\n> 应用服务器\n\n\n\n> 1. HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；\n> 2. 如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败；\n> 3. 建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文；\n> 4. 为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现“短路”操作\n\n# HTTP报文\n\n## TCP报文\n\n<img src=\"h6.png\" width=\"650\"/>\n\n> 在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等\n\n## HTTP报文\n\n- 所以头数据都是 ASCII 码的文本\n- HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：\n\n> 1. 起始行（start line）：描述请求或响应的基本信息；\n> 2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；\n> 3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据h\n\n<img src=\"h7.png\" width=\"650\"/>\n\n### 请求行（request line）\n\n- 简要地描述了**客户端想要如何操作服务器端的资源**\n- 请求行由三部分构成\n\n> 1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；\n> 2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；\n> 3. 版本号：表示报文使用的 HTTP 协议版本\n\n三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束\n\n<img src=\"h8.png\" width=\"650\"/>\n\n### 状态行（status line）\n\n- **服务器响应的状态**\n- 状态行由三部分构成\n\n> 1. 版本号：表示报文使用的 HTTP 协议版本；\n> 2. 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；\n> 3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因\n\n<img src=\"h9.png\" width=\"650\"/>\n\n### 头部字段\n\n- 请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头\n\n<img src=\"h10.png\" width=\"650\"/>\n\n<img src=\"h11.png\" width=\"650\"/>\n\n- 头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束\n- HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能\n- 使用头字段需要注意下面几点：\n\n> 1. 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；\n> 2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；\n> 3. 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；\n> 4. 字段的顺序是没有意义的，可以任意排列不影响语义；\n> 5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie\n\n#### 常用头字段\n\n基本上可以分为四大类：\n\n> 1. 通用字段：在请求头和响应头里都可以出现；\n> 2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；\n> 3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；\n> 4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息\n\n\n\n|     头字段     |              类别              | 说明/备注                                                    |\n| :------------: | :----------------------------: | ------------------------------------------------------------ |\n|      Host      |            请求字段            | Host 字段告诉服务器这个请求应该由哪个主机来处理（唯一一个 HTTP/1.1 规范里要求**必须出现**的字段） |\n|   User-Agent   |   请求字段，只出现在请求头里   | 使用一个字符串来描述发起 HTTP 请求的客户端                   |\n|      Date      | 通用字段，但通常出现在响应头里 | 表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略 |\n|     Server     |            响应字段            | 告诉客户端当前正在提供 Web 服务的软件名称和版本号（非必须出现） |\n| Content-Length |            实体字段            | 它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输 |\n\n# HTTP方法\n\n- 为什么要有“请求方法”\n\n> 客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作\n\n- 目前 HTTP/1.1 规定了八种方法，单词**都必须是大写的形式**\n\n> 1. GET：获取资源，可以理解为读取或者下载数据；\n> 2. HEAD：获取资源的元信息；\n> 3. POST：向资源提交数据，相当于写入或上传数据；\n> 4. PUT：类似 POST；\n> 5. DELETE：删除资源；\n> 6. CONNECT：建立特殊的连接隧道；\n> 7. OPTIONS：列出可对资源实行的方法；\n> 8. TRACE：追踪请求 - 响应的传输路径。\n\n<img src=\"h12.png\" width=\"650\"/>\n\n## 安全、幂等\n\n- 幂等：多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”\n\n# URI\n\n- URL\n\n> 统一资源定位符（Uniform Resource Locator）\n\n- URI\n\n> 统一资源标识符（Uniform Resource Identifier）\n>\n> URI 本质上是一个字符串，这个字符串的作用是**唯一地标记资源的位置或者名字**\n>\n> 包含有 URL 和 URN 两个部分\n\n- URI 最常用的形式\n\n<img src=\"h13.png\" width=\"650\"/>\n\n- URI 的基本组成\n\n  > scheme:\t“方案名”或者“协议名”，表示**资源应该使用哪种协议**来访问。\n\n  > “://”之后:\t是被称为“**authority**”的部分，表示**资源所在的主机名**，通常的形式是“host:port”，即主机名加端口号\n\n- 客户端和服务器看到的 URI 是不一样的\n\n> 客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI。\n\n- URI 的查询参数\n\n> 多个“**key=value**”的字符串，这些 KV 值用字符“**&**”连接，浏览器和客户端都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。\n\n- URI 的完整格式\n\n<img src=\"h14.png\" width=\"650\"/>\n\n> **身份信息**“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患\n\n- **片段标识符**“#fragment”\n\n> 它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置\n\n> 片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段\n\n- URI 的编码\n\n> URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。\n\n> URI 转义的规则：直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”\n\n## 课后问题\n\n- URI 的查询参数和头字段很相似，都是 key-value 形式，都可以任意自定义，那么它们在使用时该如何区别呢？\n\n> query参数针对的是资源（uri），而字段针对的是本次请求，也就是报文。<br>\n>\n> 一个是长期、稳定的，一个是短期、临时的\n\n# HTTP响应状态码\n\n- 状态码（Status Code）\n\n> 它是一个十进制数字，以代码的形式表示服务器对请求的处理结果\n\n> 表达 HTTP 数据处理的“状态”，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思\n\n- RFC 标准把状态码分成了五类\n\n> - 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；\n> - 2××：成功，报文已经收到并被正确处理；\n> - 3××：重定向，资源位置发生变动，需要客户端重新发送请求；\n> - 4××：客户端错误，请求报文有误，服务器无法处理；\n> - 5××：服务器错误，服务器在处理请求时内部发生了错误。\n\n## 1××\n\n- **101 Switching Protocols**\n\n> 客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了\n\n## 2××\n\n- **200 OK**\n\n> 是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果\n\n- **204 No Content**\n\n> 含义与“200 OK”基本相同，但响应头后没有 body 数据\n\n- **206 Partial Content**\n\n> 是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分\n\n> 状态码 206 通常还会伴随着头字段“**Content-Range**”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节\n\n## 3××\n\n- **301 Moved Permanently**\n\n> 永久重定向\n\n- **302 Found**\n\n> 临时重定向\n\n**301 和 302 都会在响应头里使用字段**Location**指明后续要跳转的 URI**\n\n- **304 Not Modified**\n\n> 它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制<br>\n>\n> 可以理解成“重定向已到缓存的文件”（即“缓存重定向”）\n\n## 4××\n\n- **400 Bad Request**\n\n> 是一个通用的错误码，表示请求报文有错误\n\n- **403 Forbidden**\n\n> 实际上不是客户端的请求出错，而是表示服务器禁止访问资源\n\n- **404 Not Found**\n\n> 原意是资源在本服务器上未找到，所以无法提供给客户端\n\n\n\n> - 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；\n> - 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；\n> - 408 Request Timeout：请求超时，服务器等待了过长的时间；\n> - 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；\n> - 413 Request Entity Too Large：请求报文里的 body 太大；\n> - 414 Request-URI Too Long：请求行里的 URI 太大；\n> - 429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；\n> - 431 Request Header Fields Too Large：请求头某个字段或总体太大；\n\n## 5××\n\n- **500 Internal Server Error**\n\n> 服务器错误\n\n- **501 Not Implemented**\n\n> 表示客户端请求的功能还不支持\n\n- **502 Bad Gateway**\n\n> 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误\n\n- **503 Service Unavailable**\n\n> 服务器当前很忙，暂时无法响应服务<br>\n>\n> 503 响应报文里通常还会有一个“**Retry-After**”字段，指示客户端可以在多久以后再次尝试发送请求\n\n# HTTP特点\n\n- 灵活可扩展\n\n> 只规定了报文的基本格<br>\n>\n> 报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制\n\n- 可靠传输\n\n> HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议<br>\n>\n> 是对实际传输的数据（entity）做了一层包装，加上一个头，然后调用 Socket API，通过 TCP/IP 协议栈发送或者接收\n\n- 应用层协议\n- 请求 - 应答\n- 无状态\n- 其它特点\n\n> 传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等。但这些并不能算是 HTTP 的基本特点，因为这都是由第一个“灵活可扩展”的特点所衍生出来的\n\n# HTTP优缺点\n\n- 简单、灵活、易于扩展\n\n> 降低了学习和使用的门槛<br>\n>\n> 允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由<br>\n>\n> 不限制具体的下层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定\n\n- 应用广泛、环境成熟\n\n> 不限定某种编程语言或者操作系统，所以天然具有“**跨语言、跨平台**”的优越性<br>\n>\n> 有许多硬件基础设施支持\n\n- 无状态\n\n> 不需要额外的资源来记录状态信息<br>\n>\n> 不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务<br>\n>\n> 容易地组成集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使用“堆机器”的“笨办法”轻松实现高并发高可用\n\n> 无法支持需要连续多个步骤的“事务”操作，不仅麻烦，而且还增加了不必要的数据传输量\n\n- 明文\n\n> 不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利\n\n> 不安全\n\n- 不安全\n\n> 没有提供有效的手段来确认通信双方的真实身份<br>\n>\n> 不支持“完整性校验”，数据在传输过程中容易被窜改而无法验证真伪。\n\n- 性能\n\n> 不算差，不够好<br>\n>\n> 不能保证稳定的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好<br>\n>\n> “请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据\n\n# HTTP实体数据\n\n## 数据类型与编码\n\n- 请求头\n\n```nginx\n# 客户端告诉服务器，客户端可以接受什么样的数据，\nAccept: text/html,application/xml,image/webp,image/png\n\n# 字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示\nAccept-Charset: gbk, utf-8\n\n# 客户端支持的压缩格式\nAccept-Encoding: gzip,deflate,br\t# 如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；\n\n# 标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型\nAccept-Language: zh-CN, zh, en\n```\n\n> 1. gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；\n> 2. deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；\n> 3. br：一种专门为 HTTP 优化的新压缩算法（Brotli）。\n\n- 响应头\n\n```nginx\n# 服务器告诉客户端，实际传输的数据类型,\nContent-Type: text/html\n# 字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示\nContent-Type: text/html; charset=utf-8\n\n# 实际使用的压缩格式\nContent-Encoding: gzip\t# 如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。\n\n# 告诉客户端实体数据使用的实际语言类型\nContent-Language: zh-CN\n```\n\n> 现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段\n\n- 内容协商质量值\n\n> 权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。\n\n```nginx\nAccept: text/html,application/xml;q=0.9,*/*;q=0.8\n\n# 表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。\n```\n\n- 内容协商的结果\n\n> 内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个**Vary**字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：\n\n```nginx\nVary: Accept-Encoding,User-Agent,Accept\n# 这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文\n```\n\n# 分块传输\n\n```http\n# 报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送\nTransfer-Encoding: chunked\n```\n\n- 分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“**Content-Length**”里给出确切的长度，所以也只能用 chunked 方式分块发送\n- “Transfer-Encoding: chunked”和“Content-Length”这两个字段是**互斥的**，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked\n\n## 分块传输的编码规则\n\n<img src=\"h15.png\" width=\"650\"/>\n\n> 1. 每个分块包含两个部分，长度头和数据块；\n> 2. 长度头是以 CRLF（回车换行，即\\r\\n）结尾的一行明文，用 16 进制数字表示长度；\n> 3. 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；\n> 4. 最后用一个长度为 0 的块表示结束，即“0\\r\\n\\r\\n”。\n\n## 范围请求（range requests）\n\n- 允许客户端在请求头里使用专用字段来表示只获取文件的一部分\n- 非必须\n- 服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”\n- 服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能\n- 请求头**Range**是 HTTP 范围请求的专用字段，格式是“**bytes=x-y**”，其中的 x 和 y 是以字节为单位的数据范围\n- x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节\n- Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：\n\n> - “0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；\n> - “10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；\n> - “-1”是文档的最后一个字节，相当于“99-99”；\n> - “-10”是从文档末尾倒数 10 个字节，相当于“90-99”。\n\n- 服务器收到 Range 字段后，需要做四件事\n\n> 第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码**416**，意思是“你的范围请求有误，我无法处理，请再检查一下”。\n>\n> 第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“**206 Partial Content**”，和 200 的意思差不多，但表示 body 只是原数据的一部分。\n>\n> 第三，服务器要添加一个响应头字段**Content-Range**，告诉片段的实际偏移量和资源的总大小，格式是“**bytes x-y/length**”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。\n>\n> 最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。\n\n- 常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：\n\n> - 先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；\n> - 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；\n> - 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。\n\n## 多段数据\n\n- 一次性获取多个片段数据，这种情况需要使用一种特殊的 MIME 类型：“**multipart/byteranges**”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记\n\n<img src=\"h16.png\" width=\"650\"/>\n\n<br>\n\n- http交给tcp进行传输的时候本来就会分块，那http分块的意义是什么呢？\n\n> 在http层是看不到tcp的，它不知道下层协议是否会分块，下层是否分块对它来说没有意义，不关心。\n\n> 在http里一个报文必须是完整交付，在处理大文件的时候就很不方便，所以就要分块，在http层面方便处理。\n\n> chunked主要是在http的层次来解决问题。\n\n\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---","tags":["http","network"],"categories":["http","network"]},{"title":"《HTTP协议原理+实践》syudy notes","url":"/2020/06/13/《HTTP协议原理-实践》syudy-notes/","content":"\n# 学习备注\n\n1、缓存这块，后续可以再学习一遍，把实战的内容实践一遍。也可以深入研究一下\n\n2、缓存到之后的内容包括csp，理解的比较浅，后序遇到，可以深入理解一下\n\n---\n\n# 前言\n\n> 1. 学习了慕课网的《HTTP协议原理+实践》课程，本篇文章是学习笔记。以便温习\n> 2. 相关的基础知识讲解比较浅，可以参考其它文章\n\n# HTTP基础\n\n## 浏览器输入URL后HTTP请求的完整过程\n\n<img src=\"WechatIMG243.png\" />\n\n## 5层网络模型\n\n<img src=\"WechatIMG244.png\" />\n\n> 1. 物理层：定义物理设备如何传输数据\n> 2. 数据链路层：在通信的实体间建立数据链路连接\n> 3. 网络层：为数据在节点之间传输创建逻辑链路\n> 4. 传输层：向客户端提供可靠的端到端服务；向高层屏蔽了下层数据传输细节\n> 5. 应用层：为软件提供服务；构建于TCP协议之上；屏蔽网络传输细节\n\n## 三次握手时序图\n\n<img src=\"WechatIMG253.png\" />\n\n\n\n# HTTP各种特性总览 & 实践\n\n## 创建一个简单的web服务\n\n```javascript\n/* use node.js */\nconst http = require(\"http\");\n\nhttp.createServer((req,res) => {\n    console.log(\"req.url\",req.url);\n    res.end(\"test\");\n\n}).listen(9090);\n```\n\n\n\n## CORS\n\n- 浏览器 为了保证服务端安全（保证数据不被恶意篡改 ），默认不允许跨域\n\n### CORS演示\n\nserver-8001.js\n\n```javascript\nconst http = require(\"http\");\nconst fs = require(\"fs\");\n\nhttp.createServer((req,res) => {\n    console.log(\"request come\",req.url);\n\n    // read file\n    const html = fs.readFileSync(\"test.html\",\"utf8\");\n    res.writeHead(200,{\n        \"Content-Type\":\"text/html\"\n    });\n\n    res.end(html);\n}).listen(8001);\n\nconsole.log(\"server listening on 8001\");\n```\n\nserver-9001.js\n\n```javascript\nconst http = require('http')\n\nhttp.createServer(function (request, response) {\n  console.log('request come', request.url)\n\n  response.writeHead(200, {\n    // 'Access-Control-Allow-Origin': 'http://127.0.0.1:8888',\n    'Access-Control-Allow-Origin': '*',// 设置允许所有服务跨域\n    // 'Access-Control-Allow-Headers': 'X-Test-Cors', // 设置允许跨域的自定义头\n    // 'Access-Control-Allow-Methods': 'POST, PUT, DELETE',// 设置允许跨域的方法\n    // 'Access-Control-Max-Age': '1000'\n  })\n  response.end('123')\n}).listen(9001)\n\nconsole.log('server listening on 9001')\n```\n\ntest.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <script>\n        var xhr = new XMLHttpRequest()\n        xhr.open('GET', 'http://127.0.0.1:9001/')\n        xhr.send()\n      </script>\n</body>\n</html>\n```\n\n### 浏览器跨域限制\n\n- <font color=\"red\" >浏览器在发送请求的时候并不知道这个服务是否是跨域的，**还是会发送请求，接收内容**。在接收返回数据的时候会看到请求头部中没有 `'Access-Control-Allow-Origin'` 请求头,并且没有设置为允许的话，就会把请求内容忽略掉，并报错。</font>\n\n### CORS解决方案 \n\n#### jsonp\n\ntest.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n    \n</body>\n<!-- cors1 -->\n\t<script src=\"http://127.0.0.1:8887/\" ></script>\n</html>\n```\n\n- 原理\n\n> **利用了 link、script、img标签上面的src或ref是允许跨域的这个原理**\n\n#### Access-Control-Allow-Origin\n\n服务端添加请求头：Access-Control-Allow-Origin\n\n```javascript\n/*允许所有服务跨域*/\n'Access-Control-Allow-Origin':'*'\n\n/*只允许某个域名跨域，不能设置多个值，可以通过判断来实现*/\n'Access-Control-Allow-Origin':'http://www.baidu.com'\n```\n\n\n\n### CORS预请求\n\n- 浏览器默认不允许跨域，但是浏览器会发送请求，并且数据有返回。因为安全策略问题，把请求返回忽略了，并报错\n- CORS限制时，会发送`预请求`验证\n\n### CORS限制\n\n#### 请求`method`限制\n\n- 默认允许跨域的method：post、head、get（这三个方法不用发送预请求）。其它方法默认不允许跨域，且会发送`预请求`\n- 解决方案\n\n```javascript\n/* 添加请求头 'Access-Control-Allow-Methods'，填写对应的方法 如下 */\n'Access-Control-Allow-Methods': 'POST, PUT, DELETE'\n```\n\n#### `Content-Type`限制\n\n- 默认允许跨域的Content-Type：\n\n```javascript\ntext/plain\n\nmultipart/form-data\n\napplication/x-www-form-urlencoded\n```\n\n- 其它Content-Type需要预请求\n\n#### 请求头限制\n\n- 自定义请求头是不被允许的\n\n允许或不被允许的请求头，请参考 https://fetch.spec.whatwg.org/#cors-safelisted-request-header\n\n- 解决方案\n\n```javascript\n/* 允许我们自定义的请求头CORS */\n'Access-Control-Allow-Headers': 'X-Test-Cors'\n```\n\n####Access-Control-Max-Age \n\n```javascript\n/* 数字（单位：秒）代表 允许跨域的时间，在该时间内，不用发送预请求*/\n'Access-Control-Max-Age': '1000' \n```\n\n## 缓存\n\n- public：所经过的路径中的客户端、代理服务器、源服务器等（任何地方）都可以（对返回内容）进行缓存\n- private：发起请求的请求方可以缓存\n- no-cache：需要服务端验证\n- no-store：任何地方都不可以缓存\n- no-transform：告诉代理服务器，不要缓存\n\n### 缓存到期\n\n`max-age=<seconds>`缓存过期时间\n\n`s-maxage=<seconds>`\t代替 `max-age=<seconds>`，但只有在代理服务器中才可以生效。如果两者都设置了，则代替`max-age=<seconds>`\n\n`max-stale=<seconds>`在请求方使用，如果`max-age=<seconds>`到期，缓存过期了，依然可以在`max-stale=<seconds>`时间内使用过期缓存\n\n### 重新验证\n\n`must-revalidate`，用在客户端，`max-age=<seconds>`到期后，必须去源服务器重新获取数据\n\n`proxy-revalidate`，同上，只用在代理服务器上\n\n### 缓存流程\n\n<img src=\"WechatIMG286.png\" />\n\n### 缓存验证\n\n`last-modified` 上次修改时间，主要配合`if-modified-since` 和`if-unmodified-since`使用\n\n> 对比上次修改时间，以验证资源是否需要更新\n\n`Etag`数据签名，配合`if-match`和`if-non-match`\n\n> 对比资源签名，判断是否使用缓存\n\n## Cookie\n\n> 通过 `Set-Cookie`设置<br>\n>\n> 下次请求会自动带上<br>\n>\n> 健值对，可以设置多个\n>\n> `max-age`和`expires`设置过期时间\n>\n> secure只在https的时候发送\n>\n> HttpOnly无法通过document.cookie访问\n>\n> 可以设置二级域名下共享cookie\n\n### 代码演示\n\n- Server.js\n\n```javascript\nconst http = require('http')\nconst fs = require('fs')\n\nhttp.createServer(function (request, response) {\n  console.log('request come', request.url)\n\n  if (request.url === '/') {\n    const html = fs.readFileSync('test.html', 'utf8')\n    response.writeHead(200, {\n      'Content-Type': 'text/html',\n      'Set-Cookie': ['id=123; max-age=2', 'abc=456;HttpOnly']\n    })\n    response.end(html)\n  }\n\n}).listen(8888)\n\nconsole.log('server listening on 8888')\n```\n\n- Test.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <div>Content</div>\n</body>\n<script>\n  console.log(document.cookie)\n</script>\n</html>\n```\n\n\n\n## 长连接\n\n```javascript\nconnection:\"close\"\nconnection:\"keep-alive\"\n```\n\n## 数据协商\n\n- 客户端\n\n```javascript\nAccept\nAccept-Encoding\nAccept-Language\nUser-Agent\n```\n\n- 服务端\n\n```javascript\nContent-Type\nContent-Encoding\nContent-Language\n```\n\n## 跳转\n\n- 301 和 302 的区别\n\n> 302:客户端还是会访问原站\n>\n> 301:客户端会尽可能的缓存，不访问原站\n\n## 资源限制\n\n限制资源获取，制定资源类型\n\n`Content-Security-Policy`\n\n`Security-Policy-Report-Only`\n\n# 使用Nginx实战HTTP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n","tags":["http","network"],"categories":["http","network"]},{"title":"Linux common commands","url":"/2020/06/05/Linux-common-commands/","content":"\n```linxu\n# 查看防火墙状态\nsystemctl status firewalld\n\n# 开启防火墙\nsystemctl start firewalld\n\n# 关闭防火墙\nsystemctl stop firewalld.service\n\n# 重启网络\nservice network restart\n```\n\n\n\n","tags":["Linux","terminal"],"categories":["Linux","terminal"]},{"title":"Nginx common commands","url":"/2020/06/05/Nginx-common-commands/","content":"\n```linux\n# nginx修改配置文件后，检查配置文件是否正确\n# -t 验证配置文件是否正确 -c 指定配置文件的路径\nnginx -t -c /etc/nginx/nginx.conf\nnginx -tc /etc/nginx/nginx.conf\n\n# 重载Nginx服务\nnginx -s reload -c /etc/nginx/nginx.conf\n\nsystemctl start nginx.service\nsystemctl stop nginx.service\nsystemctl restart nginx.service\n```\n\n","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"mac terminal use","url":"/2020/06/05/mac-terminal-use/","content":"\n\n\n# mac terminal use\n\n```linux\n# mac use terminal upload file，上传文件夹到linux目录，需要添加参数 -p\nscp -r -P 22 /Users/sorozy/Documents/study/ root@192.168.2.243:/opt/app/code/\n\n# 上传文件到linux某个目录\nscp -P 22 /Users/sorozy/Documents/study/* root@192.168.2.243:/opt/app/code/\n\nscp -P 22 /Users/sorozy/Documents/study/access.txt root@192.168.2.243:/opt/app/code/\n```\n\n\n\n\n\n","tags":["terminal","mac"],"categories":["terminal"]},{"title":"《Nginx入门到实践－Nginx中间件》study notes","url":"/2020/05/30/《Nginx入门到实践－Nginx中间件》study-notes/","content":"\n> 需要了解cdn\n>\n> 相关模块后续需要深入学习\n>\n> 深入了解跨站访问\n>\n> 正向代理 需要动手实现一下\n\n---\n\n# Nginx简介及起步\n\n## Nginx简介\n\n- 高效、可靠的web服务中间件\n\n  > 高效：支持海量的并发请求<br>\n  >\n  > 可靠：Nginx的服务是可靠运行的<br>\n  >\n  > 开源\n\n## 为什么选择Nginx\n\n（1）IO多路复用epoll\n\n（2）轻量级：\n\n> 功能模块少<br>\n>\n> 代码模块化\n\n（3）cpu亲和\n\n（4）sendfile\n\n## 环境调试准备\n\n### 四项确认\n\n（1）确认系统网络（连接到公网）\n\n```linux\nping www.baidu.com\n```\n\n（2）确认yum源可用\n\n```linux\n# 列出gcc相关yum源\nyum list|grep gcc\n```\n\n（3）确认关闭iptables规则 （规则会对验证HTTP服务造成影响）\n\n```linux\n# 查看是否有iptables规则\niptables -L\niptables -t nat -L\n\n# 关闭规则\niptables -F\niptables -t nat -L\n```\n\n（4）确认停用selinux\n\n```linux\n# 查看SELinux状态，如果SELinux status参数为enabled即为开启状态\ngetenforce\n\n# 临时关闭（不用重启机器）\nsetenforce 0\n\n#设置SELinux 成为permissive模式\n#setenforce 1 设置SELinux 成为enforcing模式\n\n# 修改配置文件需要重启机器\n# 修改/etc/selinux/config 文件\n# 将SELINUX=enforcing改为SELINUX=disabled\n\n```\n\n### 两项安装\n\n```linux\n# -y 不需要确认\nyum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake\n\nyum -y install wget httpd-tools vim\n```\n\n### 一次初始化目录\n\n```linux\n# /opt目录下\nmkdir app download logs work backup\n\napp\t\t# 软件、应用、代码\nbackup\t\t# 备份文件\ndownload\t# 下载内容\nlogs\t\t# 自定义日志\nwork\t\t# shell脚本\n```\n\n## Nginx install\n\n- 基于yum源（这种方式不需要源码一个个编译，加入package参数。这种方式效率高）\n\n```linux\ncd /etc/yum.repos.d\n\ntouch nginx.repo\n\nvim /etc/yum.repos.d/nginx.repo\n\n[nginx-stable]\nname=nginx stable repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=1\nenabled=1\ngpgkey=https://nginx.org/keys/nginx_signing.key\nmodule_hotfixes=true\n\nyum install nginx\n\n# 查看版本\nnginx -v\n\n查看编译参数\nnginx -V\n```\n\n## Nginx目录详解\n\n <img src=\"1.png\" width=\"650\"/><br>\n\n <img src=\"2.png\" width=\"650\"/><br>\n\n <img src=\"3.png\" width=\"650\"/><br>\n\n <img src=\"4.png\" width=\"650\"/><br>\n\n <img src=\"5.png\" width=\"650\"/><br>\n\n <img src=\"6.png\" width=\"650\"/><br>\n\n <img src=\"7.png\" width=\"650\"/><br>\n\n <img src=\"8.png\" width=\"650\"/><br>\n\n <img src=\"9.png\" width=\"650\"/><br>\n\n <img src=\"10.png\" width=\"650\"/><br>\n\n <img src=\"11.png\" width=\"650\"/><br>\n\n## Nginx安装编译参数\n\n<img src=\"WechatIMG84.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG85.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG86.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG87.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG88.png\" width=\"650\"/><br>\n\n## Nginx start/stop/resart\n\n```linux\nsystemctl start nginx.service\nsystemctl stop nginx.service\nsystemctl restart nginx.service\n```\n\n# Nginx基础\n\n## Nginx默认配置语法\n\n### nginx.conf（分三大块）\n\n```linux\nuser  nginx;\t# 设置nginx服务的系统使用用户\nworker_processes  1;\t# 工作进程数\n\nerror_log  /var/log/nginx/error.log warn;\t# nginx的错误日志\npid        /var/run/nginx.pid;\t# nginx服务启动时候pid\n# （1）以上是全局、服务模块配置\n\nevents {\n    worker_connections  1024;\t# 每个进程允许最大连接数\n    use  1;\t#\t工作进程数\n}\n# （2）以上是事件模块\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\t\t\n\t\t# 包含该文件\n    include /etc/nginx/conf.d/*.conf;\n}\n# （3）以上是http模块\n```\n\n### default.conf\n\n```linux\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log     main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```\n\n## Nginx日志\n\n- error.log\n\n  > 处理HTTP请求的错误状态\n  >\n  > 以及Nginx错误运行的状态 \n\n- access_log\n\n  > 记录每一次请求的访问状态\n  >\n  > 分析请求\n\n### log_formate\n\n- Lof_formate配置语法\n\n<img src=\"WechatIMG91.png\" width=\"650\"/><br>\n\n## Nginx变量\n\n<img src=\"WechatIMG92.png\" width=\"650\"/><br>\n\n\n\n## 常用命令\n\n```linux\n# -t 检查配置文件的正确与否\n# -c 路径检查\nnginx -t -c /etc/nginx/nginx.conf\nnginx -tc /etc/nginx/nginx.conf\n\n# 重载服务\nnginx -s reload -c /etc/nginx/nginx.conf\n\nps -aux|grep nginx\n\nsystemctl start nginx.service\nsystemctl stop nginx.service\nsystemctl restart nginx.service\n```\n\n## Nginx模块\n\n- Nginx官方模块\n- Nginx第三方模块\n\n---\n\n### http_stub_status_module\n\n<img src=\"WechatIMG93.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG94.png\" width=\"650\"/><br>\n\n- 实战\n\n```linux\n# vim /etc/nginx/conf.d/default.conf 增加如下内容\nlocation /mystatus {\n   stub_status;\n}\n\n# 访问 http://192.168.2.243/mystatus\n\nActive connections: 3 \t# nginx当前活跃的连接数\nserver accepts handled requests\n 10 10 9 \t# nginx处理的握手次数 连接数 总的请求数\nReading: 0 Writing: 1 Waiting: 2 \t# 当前正在读的数量 正在写的数量 等待总数量（开启长连接时）\n```\n\n---\n\n### random_index_module\n\n<img src=\"WechatIMG95.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG96.png\" width=\"650\"/><br>\n\n- 实战\n\n```html\n# /opt/app/code 新建 1.html 2.html 3.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n</head>\n<body style=\"background-color: red;\">\n</body>\n</html>\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n</head>\n<body style=\"background-color: blue;\">\n</body>\n</html>\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n</head>\n<body style=\"background-color: pink;\">\n</body>\n</html>\n```\n\n<br>\n\n```linux\n# vim /etc/nginx/conf.d/default.conf 修改增加如下内容\n\nlocation / {\n        root   /opt/app/code;\t# 不会展示隐藏文件\n        random_index on;\n       \t#index  index.html index.htm;\n}\n\n# 重载nginx服务\nsystemctl reload nginx.service\n\n访问 http://192.168.2.243 即可看到效果\n```\n\n---\n\n### http_sub_module\n\n<img src=\"WechatIMG97.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG98.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG99.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG100.png\" width=\"650\"/><br>\n\n- 实战\n\n```linux\nlocation / {\n        root   /opt/app/code;\n        index  index.html index.htm;\n\t\t\t\tsub_filter 'sorozy' 'isShelter';\t# 用后面的字符串替换前面的字符串\n\t\t\t\tsub_filter_once off;\t# 全局匹配，默认是 on 则只替换第一个匹配项目\n}\n\n```\n\n## Nginx请求限制\n\n### 连接频率限制 limit_conn_module\n\n<img src=\"WechatIMG161.png\" width=\"650\"/><br>\n\n### 请求频率限制 limit_req_module\n\n<img src=\"WechatIMG162.png\" width=\"650\"/><br>\n\n\n\n## Nginx的访问控制\n\n### 基于IP的访问控制 http_access_module\n\n<img src=\"WechatIMG166.png\" width=\"650\"/><br>\n\n- 实战\n\n```linux\nmv default.conf access_module.conf\n\nvim access_module.conf\n\n# 不允许本机ip访问\nlocation ~ ^/admin.html {\n  root   /opt/app/code;\n  deny 192.168.200;\n  allow all;\n  index  index.html index.htm;\n}\n\n# 只允许本机ip访问\nlocation ~ ^/admin.html {\n  root   /opt/app/code;\n  allow 192.168.2.200; # 这里也可以写成ip段\n  deny all;\n  index  index.html index.htm;\n}\n\n\n```\n\n- http_acces_module 局限性（后续再深入理解）\n\n### 基于用户的信任登录 http_auth_basic_module\n\n<img src=\"WechatIMG169.png\" width=\"650\"/><br>\n\n- 实战\n\n```linux\n# 需要安装 htpasswd\n[root@localhost nginx]# htpasswd -c ./auth_conf admin1\n\nlocation ~ ^/admin.html {\n  root   /opt/app/code;\n  auth_basic \"auth access test ! input your password\";\n  auth_basic_user_file /etc/nginx/auth_conf;\n  index  index.html index.htm;\n}\n```\n\n- http_auth_basic_module局限性（后续再深入了解）\n\n> 用户信息依赖文件方式\n>\n> 操作管理机械，效率低下\n\n解决方案\n\n<img src=\"WechatIMG170.png\" width=\"650\"/><br>\n\n# 基于Nginx的中间件架构\n\n> 1. 静态资源WEB服务\n> 2. 代理服务\n> 3. 负载均衡调度器SLB\n> 4. 动态缓存 \n\n## 静态资源web服务\n\n- 静态资源类型\n\n<img src=\"WechatIMG171.png\" width=\"650\"/><br>\n\n> 需要了解cdn\n\n### 静态资源\n\n<img src=\"WechatIMG173.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG174.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG175.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG176.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG177.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG178.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG179.png\" width=\"650\"/><br>\n\n- 实战\n\n```linux\nserver {\n    listen       80;\n    # server_name  116.62.103.228  ;\n    server_name 192.168.2.243 jeson.imooc.com;\n    sendfile on;\n    #charset koi8-r;\n    access_log  /var/log/nginx/log/static_access.log  main;\n\n    \n    location ~ .*\\.(jpg|gif|png)$ {\n        gzip on;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n        root  /opt/app/code/images;\n    }\n\n    location ~ .*\\.(txt|xml)$ {\n        gzip on;\n        gzip_http_version 1.1;\n        gzip_comp_level 1;\n        gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n        root  /opt/app/code/doc;\n    }\n\n    location ~ ^/download {\n        gzip_static on;\n        tcp_nopush on;\n        root /opt/app/code;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504 404  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```\n\n### 缓存\n\n<img src=\"WechatIMG180.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG181.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG182.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG183.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG184.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG185.png\" width=\"650\"/><br>\n\n### 跨站\n\n<img src=\"WechatIMG191.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG192.png\" width=\"650\"/><br>\n\n- 允许跨站\n\n```linux\nlocation ~ .*\\.(htm|html)$ {\n        add_header Access-Control-Allow-Origin *; \n        add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n        #expires 24h;\n        root  /opt/app/code;\n}\n```\n\n### 防盗链\n\n<img src=\"WechatIMG193.png\" width=\"650\"/><br>\n\n## 代理服务\n\n<img src=\"WechatIMG108.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG109.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG110.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG111.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG113.png\" width=\"650\"/><br>\n\n### 反向实战\n\n```linux\n# 环境准备\n# linux开启防火墙，关闭8080端口（8080端口不放行）开启80端口，80端口放行\n\n# /etc/nginx/conf.d 目录下 添加两个配置文件 fx_proxy.conf realserver.conf\n\n# fx_proxy.conf 配置\nserver {\n    listen       80;\n    server_name  localhost jeson.t.imooc.io;\n\n    #charset koi8-r;\n    access_log  /var/log/nginx/test_proxy.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n    \n    # 反向代理核心配置\n    location ~ /test_proxy.html$ {\n        proxy_pass http://127.0.0.1:8080;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\nserver {\n    listen       8080;\n    server_name  localhost jeson.t.imooc.io;\n\n    #charset koi8-r;\n    access_log  /var/log/nginx/server.access.log  main;\n\n\t\t# 注意在该目录下 /opt/app/code2 放入html文件\n    location / {\n        root   /opt/app/code2;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n# 结果\n# http://172.20.94.55:8080/test_proxy.html 不可访问\n# http://172.20.94.55/test_proxy.html 可访问\n```\n\n### 正向代理实战（待完成）\n\n## 负载均衡\n\n\n\n\n\n\n\n---\n\n","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"hexo 常见操作","url":"/2020/05/26/hexo-常见操作/","content":"\n- hexo常用命令\n\n```shell\n# 建立文章草稿\nhexo new draft <title>\n\n# 本机预览草稿\nhexo S --draft\n\n# 将草稿发布为正式文章\nhexo P <filename>\n\n# 生成静态文件\nhexo generate\n\n# 部署\nhexo deploy\n\n# 生成后部署\nhexo g -d\n\n```\n\n<br>\n\n- hexo链接到站内文章指定锚点\n\n```markdown\n<a href=\"{% post_path 'hexo blog' %}#安装\">hexo 安装</a>\n\n<a href=\"{% post_path '《图解HTTP》read notes' %}#编码提升传输速率\">http的编码提升传输速率</a>\n```\n\n<a href=\"{% post_path '《图解HTTP》read notes' %}#编码提升传输速率\">http的编码提升传输速率</a>\n\n<br>\n\n- hexo添加多个categories\n\n```markdown\ncategories:\n\t- [algorithm]\n\t- [data-structure]\n```\n\n<br>\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"Nginx study notes","url":"/2020/05/25/Nginx-study-notes/","content":"\n\n\n# Nginx install & start\n\n## install dependencies\n\n- install pcre\n\n```shell\n# 这里我选择下载到 /usr/src\nwget https://ftp.pcre.org/pub/pcre/pcre-8.37.tar.gz\n\n# 解压\ntar -xvf pcre-8.37.tar.gz\n\n# 进入解压后的主目录（pcre-8.37）执行下面的命令\n./configure\n\n# 执行 ./configure时候，可能会报错（没有c、c++的支持），则安装相关依赖即可\n# 安装c依赖\nyum -y install gcc\n# 安装c++依赖\nyum install -y gcc gcc-c++\n\n# 进入主目录（pcre-8.37）执行下面命令\nmake && make install\n\n# 至此，安装完成，执行下面命令，查看版本\npcre-config --version\n```\n\n- install other dependencies\n\n```shell\n# zlib openssl\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n## install Nginx\n\n```shell\n# 准备好nginx包\n\n# 解压nginx-xx.tar.zg包\ntar -xvf [nginx-xx.tar.zg]\n\n# 进入解压目录，执行\n./configure\n\n# 进入解压目录，执行\nmake && make install\n```\n\n## start Nginx\n\n```shell\n# nginx安装完成后，会在 /usr/local/ 目录下生成一个nginx文件夹\n\n# 进入 /usr/local/nginx/sbin 执行\n./nginx\n\n# 至此，nginx启动，访问ip可以看到welcome页面，（注意开启端口，或关闭防火墙）\n```\n\n","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"《图解HTTP》read notes","url":"/2020/05/22/《图解HTTP》read notes/","content":"\n[TOC]\n\n# 了解web及网络基础\n\n## HTTP\n\n（HyperText Transfer Protocol）\n\n- 通常使用的网络协议是TCP/IP 协议族上运作的，HTTP是其内部的一个子集\n-  TCP/IP 分层好处：把各层之间的接口设计好，其内部就可以自由改动\n\n\n\n##  TCP/IP协议分层\n\n|              分层               |                             作用                             |             备注              |\n| :-----------------------------: | :----------------------------------------------------------: | :---------------------------: |\n|             应用层              |             决定了向用户提供应用服务时通信的活动             |                               |\n|             传输层              |     对上层应用层，提供处于网络连接中两台计算机的数据传输     | 有两个性质不同的协议TCP、 UDP |\n|      网络层（网络互联层）       | 处理在网络上流动的数据包<br/>（数据包是网络传输的最小单位）<br/>规定了通过怎样的路径到达对方计算机，并把数据包传送给对方 |                               |\n| 链路层（数据链路层/网络接口层） |                    处理连接网络的硬件部分                    |                               |\n\n\n\n## IP（Internet Protocol）\n\n- 位于网络层\n- 作用：把各种数据包传送给对方\n- 重要条件\n\n> IP地址：指明了节点被分配到的地址\n>\n> MAC地址：指网卡所属的固定地址\n>\n> IP地址可以和MAC地址配对，IP可变换，MAC地址基本不会改变\n\n\n\n## ARP协议\n\nIP间的通信依赖MAC地址\n\nARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对方的MAC地址\n\n\n\n## TCP协议\n\n- 提供可靠的字节流服务\n\n> 为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理\n>\n> 能够把数据准确可靠的传送给对方\n\n- 为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否到达对方\n- 为了准确无误把数据送达对方，采用了三次握手策略\n\n\n\n## DNS（Domain Name System）\n\nDNs协议提供从域名查找IP，或逆向从IP反查域名的服务\n\n\n\n## URI（统一资源标识符）\n\n用字符串标识某一互联网资源\n\n\n\n### URI格式\n\n\n\n## URL\n\n> 表示资源的地点\n\n\n\n# 简单的HTTP协议\n\n## 请求报文构成\n\n<img src=\"tjhttp-req-bw.png\" width=\"650\"/>\n\n\n\n## 响应报文构成\n\n<img src=\"1590118989509-4d5d74da-3a96-4576-8000-18dfc9d51ffd.png\" width=\"650\"/>\n\n\n\n## HTTP是无状态协议\n\n> 对发送过的请求或响应不做持久化处理\n>\n> 为了期望保持状态功能，引入了cookie技术\n\n\n\n## HTTP方法\n\n<img src=\"1590123329116-9aaf96d8-f801-49c4-a844-210cb8f3063d.png\" width=\"650\"/>\n\n- HTTP/1.1的PUT/DELETE方法不带验证机制，任何人都可以上传文件，存在安全问题，一般网站不使用该方法，若配合web应用程序的验证机制，或架构设计采用REST标准的同类web网站，则可能开放使用PUT/DELETE方法\n\n\n\n## 持久连接（HTTP keep-alive）\n\n> 持久连接的好处在于：减少了tcp连接的重复建立和断开所造成的额外开销，减轻了服务器的负载\n>\n> 在HTTP/1.1中，默认都是持久连接\n>\n> 持久连接使得多数请求以管线化方式发送成为可能，不用等待响应亦可发送下一个请求。能够做到同时并行发送多个请求\n\n\n\n## 使用cookie的状态管理\n\n<img src=\"1590124489186-9d978bd8-67a8-44c0-aec8-a38d00bb277c.png\" width=\"650\"/>\n\n\n\n### cookie交互场景下，请求报文与响应报文\n\n<img src=\"1590124671111-ee605c31-15b1-4eef-9664-656829873298.png\" width=\"650\"/>\n\n<img src=\"1590124686480-814917fe-0d61-4ae3-8ed2-1618159890cd.png\" width=\"650\"/>\n\n\n\n### 编码提升传输速率\n\n- 常见的编码方式\n\n> - gzip\n> - compress\n> - deflate\n> - identity（不进行编码）\n\n\n\n### 获取部分内容的范围请求\n\n- 使用首部字段的Range来指定资源的byte范围\n\n- 5001 ～ 10000 字节\n\n```http\nRange: bytes=5001-10000\n```\n\n- 从5001字节之后全部的\n\n```http\nRange: bytes=5001-\n```\n\n- 从一开始3000字节和5000-7000字节的多重范围\n\n```http\nRange: bytes=-3000,5000-7000\n```\n\n\n\n## 内容协商返回最合适的内容\n\n- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源\n\n- 内容协商技术类型\n\n> 服务器驱动协商\n>\n> 客户端驱动协商\n>\n> 透明协商\n\n\n\n# 返回结果的HTTP状态码\n\n## 状态码分类\n\n| 状态码 |               类别               |          原因短语          |\n| :----: | :------------------------------: | :------------------------: |\n|  1xx   |  Informational（信息性状态码）   |     接收的请求正在处理     |\n|  2xx   |      Success（成功状态码）       |      请求正常处理完毕      |\n|  3xx   |   Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |\n|  4xx   | Client Error（客户端错误状态码） |     服务器无法处理请求     |\n|  5xx   | Server Error（服务器错误状态码） |     服务器处理请求出错     |\n\n\n\n### 2xx\n\n|   状态码 原因短语   |           简单说明            |\n| :-----------------: | :---------------------------: |\n|       200 OK        | Informational（信息性状态码） |\n|   204 No Content    | 请求处理成功，但没有资源返回  |\n| 206 Partial Content |  Redirection（重定向状态码）  |\n\n\n\n### 3xx\n\n|    状态码 原因短语     |           简单说明            |\n| :--------------------: | :---------------------------: |\n| 301 Moved Permanently  |        资源URL已经更行        |\n|       302 Found        | 请求处理成功，但没有资源返回  |\n|     303 See Other      | 客户端应当采用GET方法获取资源 |\n|    304 Not Modified    | 资源已找到，但未符合条件请求  |\n| 307 Temporary Redirect |          临时重定向           |\n\n\n\n### 4xx\n\n| 状态码 原因短语  |             简单说明             |\n| :--------------: | :------------------------------: |\n| 400 Bad Request  |      请求报文中存在语法错误      |\n| 401 Unauthorized | 请求需要有通过HTTP认证的认证信息 |\n|  403 Forbidden   |         访问被服务器拒绝         |\n|  404 Not Found   |        服务器上未找到资源        |\n\n\n\n### 5xx\n\n|      状态码 原因短语      |                   简单说明                   |\n| :-----------------------: | :------------------------------------------: |\n| 500 Internal Server Error |         服务器在执行请求时发生了错误         |\n|  503 Service Unavailable  | 服务器处于超负荷或停机维护状态，无法处理请求 |\n\n# HTTP 协作的web服务器\n\n## 代理\n\n- 使用代理服务器的理由\n\n> 利用缓存技术，减少网络带宽的流量\n>\n> 组织内部对特定网站的访问控制\n>\n> 以获取访问日志为主要目的\n\n- 代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文\n\n- 缓存代理\n\n> 预先将资源缓存在代理服务器上\n\n- 透明代理\n\n> 不对报文做任何加工\n\n\n\n## 网关\n\n- 使通信线路上的服务器提供非http协议服务\n- 提高通信安全性，在客户端和网关的通信线路上加密以确保连接安全\n\n\n\n## 隧道\n\n- 建立起与其它服务器的通信线路\n\n\n\n# HTTP首部\n\n- 首部内容较多\n- 后续学习会补上相关笔记\n\n\n\n# 确保安全的HTTPS\n\n## HTTP的缺点和不足\n\n> 通信使用明文（不加密），内容可能会被窃听\n>\n> 不验证通信方的身份，因此有可能遭遇伪装\n>\n> 无法证明报文的完整性，所以有可能已遭篡改\n\n- TCP/IP是可能被窃听的网络\n\n## 防窃听保护信息的几种对策\n\n- 通信的加密\n\n  > 通过和SSL或TSL的组合使用（HTTPS），加密HTTP的通信内容\n\n- 内容的加密\n\n- HTTPS是身披SSL外壳的HTTP\n\n  > HTTPS:只是HTTP通信接口部分用SSL和TSL协议代替而已\n\n\n\n### HTTP安全通信机制\n\n- 待整理完成\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<br>\n\n<br>\n\n\n\n\n\n","tags":["http","network","read-notes"],"categories":["http","network","read-notes"]},{"title":"DataStructure & Algorithm - Array","url":"/2020/05/04/DataStructure-Algorithm-Array/","content":"\n# Array介绍\n\n- <font color=red >数组（Array）是一种**线性表**数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据</font>\n- 数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”\n\n\n\n- 连续的内存空间和相同类型的数据\n\n> **根据下标随机访问的时间复杂度为 O(1)**\n>\n> 要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作\n\n\n\n- 低效的“插入”和“删除”\n\n> O(n)\n>\n> 插入改进：直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置\n>\n> 删除改进：记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移\n\n\n\n- ArrayList\n\n（1）最大的优势就是可以将很多数组操作的细节封装起来，支持动态扩容\n\n（2）完全不需要关心底层的扩容逻辑\n\n（3）扩容操作涉及内存申请和数据搬移，比较耗时，最好在创建 ArrayList 的时候事先指定数据大小\n\n（4）Java ArrayList 无法存储基本类型\n\n\n\n- 为何数组从0开始编号\n\n> “下标”最确切的定义应该是“偏移（offset）”\n>\n> a[0]就是偏移为 0 的位置，也就是首地址\n>\n> 原因：减少一次减法指令\n\n```java\na[i]_address = base_address + i * data_type_size\n```\n\n\n\n- 线性表（Linear List）\n\n> 数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向\n>\n> 线性表数据结构：数组，链表、队列、栈等\n\n- 非线性表\n\n> 二叉树、堆、图等\n>\n> 在非线性表中，数据之间并不是简单的前后关系\n\n# implement dynamic array\n\n```java\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["data-structure","algorithm"],"categories":["data-structure","algorithm"]},{"title":"DataStructure & Algorithm - complexity analysis","url":"/2020/05/04/DataStructure-Algorithm-complexity-analysis/","content":"\n- 复杂度分析是整个算法学习的精髓\n\n# 为什么需要复杂度分析？\n\n（1）测试结果非常依赖测试环境\n\n（2）测试结果受数据规模的影响很大\n\n> 我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。\n>\n> 时间、空间复杂度分析方法\n\n# 大 O 复杂度表示法\n\n（1）<font color=red>**代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**</font>\n\n```shell\nT(n)=O(f(n))\n```\n\n（2）<font color=red>**大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度**</font>\n\n（3）在采用大 O 标记复杂度的时候，可以忽略系数，即 `O(Cf(n)) = O(f(n))`\n\n# 时间复杂度分析\n\n（1）只关注循环执行次数最多的一段代码\n\n（2）加法法则：总复杂度等于量级最大的那段代码的复杂度\n\n（3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n> 并不用刻意去记忆。复杂度分析这个东西关键在于“熟练”。你只要多看案例，多分析，就能做到“无招胜有招”\n\n# 几种常见时间复杂度实例分析\n\n- 粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2^n) 和 O(n!)\n\n- 时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题\n\n|   复杂度量级   |          | 说明                                                         |\n| :------------: | :------: | :----------------------------------------------------------- |\n|   常数复杂度   |   O(1)   | 代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1) <br>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1) |\n|   对数复杂度   | O(log n) | O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn) |\n| 线性时间复杂度 |   O(n)   |                                                              |\n|      平⽅      |  O(n^2)  |                                                              |\n|      ⽴方      |  O(n^3)  |                                                              |\n|      指数      |  O(2^n)  |                                                              |\n|      阶乘      |  O(n!)   |                                                              |\n\n## O(logn)、O(nlogn)\n\n```java\n i=1;\n while (i <= n)  {\n   i = i * 2;\n }\n```\n\n## O(m+n)、O(m*n)\n\n- 代码的复杂度由两个数据的规模来决定\n\n```java\nint cal(int m, int n) {\n  int sum_1 = 0;\n  int i = 1;\n  for (; i < m; ++i) {\n    sum_1 = sum_1 + i;\n  }\n\n  int sum_2 = 0;\n  int j = 1;\n  for (; j < n; ++j) {\n    sum_2 = sum_2 + j;\n  }\n\n  return sum_1 + sum_2;\n}\n```\n\n# 空间复杂度分析\n\n- 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系\n- 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多，掌握以上即可\n\n```java\n// 整段代码的空间复杂度就是 O(n)\n\nvoid print(int n) {\n  int i = 0;\n  int[] a = new int[n];\n  for (i; i <n; ++i) {\n    a[i] = i * i;\n  }\n\n  for (i = n-1; i >= 0; --i) {\n    print out a[i]\n  }\n}\n```\n\n# 大O 复杂度曲线\n\n<img src=\"big_O_chart.png\" width=\"650\"/>\n\n# 时间复杂度分析方法\n\n## 代码在不同情况下的不同时间复杂度\n\n- 最好情况时间复杂度（best case time complexity）<br>\n\n- 最坏情况时间复杂度（worst case time complexity）<br>\n\n- 平均情况时间复杂度（average case time complexity）<br>\n\n- 均摊时间复杂度（amortized time complexity）\n\n\n\n- 均摊时间复杂度\n\n> 对应的分析方法，摊还分析（或者叫平摊分析）<br>\n>\n> 摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度<br>\n>\n> 均摊时间复杂度就是一种特殊的平均时间复杂度<br>\n\n> 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度\n","tags":["data-structure","algorithm"],"categories":["data-structure","algorithm"]}]