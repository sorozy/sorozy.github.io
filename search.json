[{"title":"理解MySQL运行原理","url":"/2021/03/18/理解MySQL运行原理/","content":"\n# 初识MySQL\n\n## MySQL的客户端／服务器架构\n\n- 服务器程序<span style=\"color:red\">直接和我们存储的数据打交道</span>\n\n- `MySQL`服务器程序的进程也被称为`MySQL数据库实例`，简称`数据库实例`。\n\n- 启动的`MySQL`服务器进程的默认名称为`mysqld`， 而我们常用的`MySQL`客户端进程的默认名称为`mysql`\n\n## Linux下MySQL（mysql-5.6.39.tar.gz）的编译安装\n\n- 备注： 建议使用mysql-5.6.x 低版本的源码包，高版本在cmake过程中会报错\n\n（1）卸载系统自带的mariadb && 卸载安装过的旧版本MySQL\n\n```shell\n# 卸载系统自带的mariadb\nrpm -qa | grep mariadb\nrpm -e --nodeps 文件名\n\n# 卸载安装过的旧版本MySQL\nrpm -qa | grep mysql\nrpm -e --nodeps 文件名\n\n# 删除mysql目录\nfind / -name mysql\nrm -rf [mysql的相关目录]\n```\n\n（2）创建mysql用户和用户组\n\n```shell\n# 新增mysql用户组，添加mysql用户，并将mysql用户添加至用户组\ngroupadd   mysql && useradd -r -g mysql mysql\n```\n\n（3）创建数据库所需目录\n\n```shell\nmkdir -p  /usr/local/mysql /home/mysql/data /home/mysql/logs /home/mysql/temp\n```\n\n（4）添加环境变量使mysql命令生效\n\n```shell\nvim  /etc/profile\n\n# mysql env param\nPATH=/usr/local/mysql/bin:/usr/local/mysql/lib:$PATH\nexport PATH\n\n# 刷新环境变量配置文件\nsource  /etc/profile\n```\n\n（5）安装mysql依赖包\n\n```shell\nyum install -y make cmake gcc gcc-c++ bison bison-devel ncurses ncurses-devel antoconf automake\n```\n\n（6）上传MySQL源码包\n\n```shell\n# mkdir -p /usr/local/src [如没有则创建]\n# 上传（下载）源码包到 /usr/local/src 目录下，并解压\n\ncd /usr/local/src && wget http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.39.tar.gz && tar -zxvf mysql-5.6.39.tar.gz\n\n```\n\n（7）MySQL安装前属性设置\n\n```shell\ncd /usr/local/src/mysql-5.6.39 && cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_UNIX_ADDR=/usr/local/mysql/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_DATADIR=/home/mysql/data -DMYSQL_USER=mysql -DMSLQ_TCP_PORT=3306 -DENABLE_DOWNLOADS=1\n\n# 需要留意 结果是否有报错信息\n```\n\n（8）编译 && 安装\n\n```shell\n# cd /usr/local/src/mysql-5.6.39 && make && make install && make clean\n\ncd /usr/local/src/mysql-5.6.39\n\n# 编译\nmake\n# 安装\nmake install \n# 清除安装文件\nmake clean\n```\n\n（9）修改目录权限\n\n```shell\n# 将 /usr/local/mysql 目录 和 /home/mysql 目录的权限设为 mysql用户所有\n\nchown -Rf mysql:mysql /usr/local/mysql && chown -Rf mysql:mysql /home/mysql\n```\n\n（10）MySQL初始化\n\n```shell\n# 进入mysql安装/usr/local/mysql目录执行数据库的 初始化脚本并生成my.cnf文件。用于mysql自带的 数据库 和 表的初始化 \n\n# 将/home/data目录  作为数据存放的目录\n\ncd /usr/local/mysql && scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/home/mysql/data\n```\n\n（11）将my.cnf 文件的所属权限改成 mysql用户\n\n- 特别注意\n\n> 在默认系统中 /etc 目录下也会有一个 my.cnf文件  ，当mysql服务启动时会默认 先读取/etc/my.cnf 文件  ，如果/etc/my.cnf 不存在则会到 mysql的安装目录下读取 my.cnf文件  ，因此需将 /etc/my.cnf 文件 改成其他名字 ，否则会干扰到mysql安装目录下的my.cnf文件 \n\n<span style=\"color:red\">但是在生产环境上 建议使用 /etc/my.cnf 文件 </span>\n\n```shell\nchown -Rf mysql:mysql /usr/local/mysql/my.cnf\n```\n\n```shell\n# 编辑my.cnf文件   将所有内容删除\n\nvim /etc/my.cnf\n```\n\n```mysql\n[client]\nport = 3306\nsocket = /usr/local/mysql/mysql.sock\n\n[mysqld]\ncharacter-set-server = utf8\ncollation-server  = utf8_general_ci\nskip-external-locking\nskip-name-resolve\nport = 3306\nbasedir = /usr/local/mysql\ndatadir = /home/mysql/data\ntmpdir = /home/mysql/temp \nsocket = /usr/local/mysql/mysql.sock\nlog-error = /home/mysql/logs/mysql_error.log\npid-file  = /home/mysql/mysql.pid\nopen_files_limit  = 10240\nback_log = 600\nmax_connections=500\nmax_connect_errors = 6000\nwait_timeout=605800\nmax_allowed_packet = 32M\nsort_buffer_size = 4M\njoin_buffer_size  = 4M\nthread_cache_size = 300 \nquery_cache_type = 1\nquery_cache_size = 256M\nquery_cache_limit = 2M\nquery_cache_min_res_unit  = 16k\ntmp_table_size = 256M\nmax_heap_table_size = 256M\nkey_buffer_size = 256M\nread_buffer_size = 1M\nread_rnd_buffer_size = 16M\nbulk_insert_buffer_size  = 64M\nlower_case_table_names=1\ndefault-storage-engine = INNODB\ninnodb_buffer_pool_size  = 512M\ninnodb_log_buffer_size  = 32M\ninnodb_log_file_size  = 128M\ninnodb_flush_method  = O_DIRECT\nthread_concurrency = 32\nlong_query_time=  2\nslow-query-log  = on\nslow-query-log-file  = /home/mysql/logs/mysql-slow.log  \n\nskip-grant-tables\n\n[mysqldump]\nquick\nmax_allowed_packet = 32M\n\n[mysqld_safe]\nlog-error=/var/log/mysqld.log\npid-file=/var/run/mysqld/mysqld.pi　　\n```\n\n（12）复制mysql启动服务脚本 至 /etc/init.d目录下\n\n```shell\ncp /usr/local/mysql/support-files/mysql.server  /etc/init.d/mysql\n```\n\n（13）启动、停止、重启mysql 服务\n\n```shell\nservice mysql start\n\nservice mysql stop\n\nservice mysql restart\n```\n\n（14）其它设置\n\n```shell\n# 设置mysql 服务开机自动开启\nchkconfig mysql on\n\n# 设置mysql数据库root用户本地登录密码   （这里设置的密码为 root）\nmysqladmin -u root password 'root'\n```\n\n## 启动MySQL服务器程序\n\n- mysqld\n\n`mysqld`这个可执行文件就代表着`MySQL`服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。\n\n- mysqld_safe\n\n`mysqld_safe`是一个启动脚本，它会间接的调用`mysqld`，而且还顺便启动了另外一个监控进程，这个监控进程在服务器进程挂了的时候，可以帮助重启它。另外，使用`mysqld_safe`启动服务器程序时，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。\n\n- mysql.server\n\n\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"《Linux实战技能100讲》study notes","url":"/2021/03/04/《Linux实战技能100讲》study-notes/","content":"\n# 学习备注\n\n> 打包和压缩的命令还需要再熟悉一下\n>\n> vim 这块 ，老师讲到的内容需要自己复习 试着做一遍，\n>\n> 要熟悉各个命令的正确使用方式，以及 查看相关帮助\n>\n> 特殊权限这块 了解的还不够深入\n\n# 学习内容综述\n\n1. linux背景介绍\n2. 系统操作\n3. 服务管理\n4. shell 脚本\n5. 文本操作\n6. 常用服务搭建\n\n# linux命令行常用光标移动快捷键\n\n```shell\nctrl+a : 跳到本行的行首\nctrl+e : 跳到行尾s\n```\n\n# Linux 系统目录结构\n\n```shell\nll /\n```\n\n\n\n<img src=\"WechatIMG1131.png\" width=\"500px\" />\n\n- 树状目录结构\n\n<img src=\"WechatIMG1132.jpeg\" width=\"500px\" />\n\n## 常见目录介绍\n\n- /根目录\n\n- /root：root用户家目录。该目录为系统管理员，也称作超级权限者的用户主目录。\n\n- /home/username：普通用户的家目录\n\n- /etc： 配置文件目录\n\n- /bin：命令目录\n\n- /sbin：管理命令目录\n\n- /usr/bin /usr/sbin：系统预装的其它命令\n\n  \n\n# 万能的帮助命令\n\n## man\n\n```shell\n# man 是 manual（手册） 的缩写\nman [命令名称]\n\n# 查看某个章节的帮助\nman [number] [命令名称]\n\nman -a [命令名称]\n```\n\n## help\n\n```shell\n# 内部命令使用help帮助\nhelp cd\n\n# 外部命令使用help\nls --help\n\n# 查看命令类别\ntype cd\ntype ls\n```\n\n## info\n\n- Info帮助比help更详细，作为help的补充\n\n```shell\ninfo ls\n```\n\n# 文件管理\n\n- Linux 中，一切皆文件\n\n```shell\npwd\n\n# 更改当前操作目录 path 可以使用相对路径或绝对路径\ncd [path]\ncd ..\ncd -\n\n\nls [option] [file or dir] [file or dir]\n-l 长格式显示文件\n-a 显示隐藏文件\n-r 逆序显示 (默认名字逆向)\n-t 按照时间顺序显示\n-R 递归显示\n```\n\n```shell\nmkdir [dir1] [dir2]\n\n# -p 建立多级目录\nmkdir -p /a/b/c/d\n\n# 只能删除空的目录\nrmdir [dir]\n\n# -r 删除非空目录\nrm -r [dir]\n\n# -f 无需确认（提示）就删除\nrm -rf [dir]\n```\n\n```shell\n# 复制目录 需要 -r\n# -v 显示复制过程 -p 保留原有时间 -a 保留权限，保留属主，保留修改时间等文件属性\ncp -r [源文件] [目标目录]\n\ntouch \n\n# 重命名 / 移动 (可以使用通配符)\nmv\n```\n\n```shell\n# 文本内容显示到终端\ncat\n\n# 查看文件开头，可以指定查看几行\nhead -[number]\n\n# 查看文件结尾 ，常用参数 -f 文件内容更新后，显示内容同步更新\ntail -f -[number]\n\nmore\n\nless\n\nwc 统计文件内容信息\n```\n\n## 打包和压缩\n\n- 最早的linux备份介质是磁带，使用的命令是`tar`\n- 可以打包后的磁带文件进行压缩存储，压缩的命令是`gzip`和`bzip2`\n- 经常使用的扩展名是 `.tar.gz` `.tar.bz2` `.tgz`\n\n```shell\n# linux 下分成两步 打包 和 压缩\ntar\nc 打包\nx 解包\nf 指定操作类型为文件\n\n# 打包并压缩\ntar cfz /opt/php.tar.gz /opt/php\n\n# 解包\ntar xf /opt/php.tar /opt\n```\n\n# vi / vim\n\n## 四种模式\n\n- 正常模式\n- 插入模式\n- 命令模式\n- 可视模式\n\n```shell\nyy #复制光标所在的当前行\n\np # 粘贴\n\n# 复制3行\n3 yy\n\ny$ 复制光标到当前行尾的内容\n\n# 剪切\ndd\nd$\n\n# 撤销\nu\n\n# 对撤销的内容重做\nctrl + r\n\n单个字符的删除\nx\n显示行号\n:set \n移动光标到指定行 如 7 + G\ng 移动到第一行\nG 移动到最后一行\n^ 进入光标所在行行首\n$ 进入光标所在行行尾\n:w file_save_path 保存文件\n:! 执行临时的linux命令\n查找\n/待查找的字符 移动下一个单词 n 上一个 N\n:%s/old/new/g 全局替换\n:3,5s/old/new 3-5行内进行替换，没有g就单次替换\n:s/old/new 当前行替换\n:set nu\n:set nonu\n\nvim /etc/vimrc 修改vim的配置文件\n\n```\n\n# 用户和用户组管理\n\n```shell\n# 新建用户\nuseradd wilson\n\n# 查看是否有该用户\nid wilson\n\n# 用户记录到该文件\ntail -10 /etc/passwd\n\n# 用户密码相关的文件\ntail -10 /etc/shadow\n\n# 设置用户密码\npasswd wilson\n\n# 删除用户 家目录会保留\nuserdel wilson\n# 删除用户 && 删除用户家目录\nuserdel  -r wilson\n\n# 修改用户属性\nusermod wilson\nman usermod\n\n# 添加用户组\ngroupadd\n\ngroupdel\n\n# 修改用户组\nusermod -g [group_name] [user_name]\n# 新建用户 并添加用户组\nuseradd -g [group_name] [user_name]\n\n# \nchage\n\n\n# 临时切换用户\nsu - [user_name]\n\n\nsudo\n# su 和 sudo 这块还需要了解\n# su 切换用户身份\n# sudo 赋予普通用户有管理员的权限\n\n# 例如 给user3 添加权限\n\nvisudo\nuser3 ALL=/usr/sbin/shutdown -c\n\n# 之后user3 就有了shutodown -c 的权限\n```\n\n- 用户和用户组的配置文件\n\n```shell\n# /etc/passwd /etc/group /etc/shadow\n```\n\n- /etc/passwd 用户配置文件\n\n```shell\n# 内容有7个字段\n# 字段1 username \n# 字段2 x 登录是否需要密码 ，x 表示需要，取掉x表示登录时候不需要密码\n# 字段3 和 字段4 用户的 uid 和 gid ，即用户唯一标识id 和 用户组标识id ，linux靠uid区分用户，而不是username\n# 字段5 注释 \n# 字段6 用户家目录\n# 字段7 用户命令解释器 ，/sbin/nologin 表示用户无法登录终端\nuser3:x:1000:1001::/home/user3:/bin/bash\n```\n\n- /etc/shadow 保存用户和用户密码相关信息\n\n```shell\n# 字段1 用户名称\n# 字段2 用户加密过的密码，即使密码相同，加密后的密码字符串也不相同\n# \nuser3:$6$j0BJLzBS$IRogEslSRhgBNLjk6fskENBxFTtq3eQCq3WwKklYhc0f2lgr/sxNshIpxstNhwRyvhxy9ONtJmiGJO/BMM2qA1:18705:0:99999:7:::\n```\n\n- /etc/group 和用户组相关的配置文件\n\n```shell\n# 字段1 用户组名称 \n# 字段2 用户登录是否需要密码验证\n# 字段3 gid 用户组id\n# 字段4 其它组设置\nsystemd-journal:x:190:\n```\n\n# 文件目录权限\n\n- 查看文件目录权限\n\n<img src=\"001.png\" />\n\n- 文件类型\n\n> \\- 普通文件\n>\n> d 目录文件\n>\n> b 块特殊文件\n>\n> c 字符特殊文件\n>\n> l 符号链接\n>\n> f 命名管道\n>\n> s 套接字文件\n\n- 文件权限表示方法\n\n> - 字符权限表示方法\n>\n> r 读\n>\n> w 写\n>\n> x 可执行\n>\n> - 数字权限表示方法（用8进制表示的）\n>\n> r = 4\n>\n> w = 2\n>\n> x = 1\n\n<img src=\"002.png\" />\n\n- 目录权限表示方法\n\n> x 进入目录\n>\n> rx 显示目录内的文件名\n>\n> wx 修改目录内的文件名\n\n- 修改权限命令\n\n```shell\n# 修改文件 目录权限\nchmod \nchmod u+x /tmp/testfile\nchmod 755 /tmp/test/file\n\n# 更改 属主 属组\nchown\n\n# 单独修改属组\nchgrp\n\n```\n\n- 特殊权限\n\n<img src=\"003.png\" />\n\n# 网络管理\n\n\n\n# 软件包的管理和使用\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["linux"],"categories":["linux"]},{"title":"《Redis入门指南》study notes","url":"/2021/02/26/《Redis入门指南》study-notes/","content":"\n# 备注\n\n> 有空了 好好学习一下正则表达式\n\n\n\n# 简介\n\nRedis是一个开源的、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同场景下的缓存与存储要求。同时Redis的诸多高层级功能使其可以胜任消息队列、任务队列等不同的角色\n\nRedis REmotes DIctionary Server （远程字典服务器）\n\n## 特性\n\n### 存储结构\n\n以字典结构存储数据，并允许其它应用通过TCP协议读写字典中的内容。\n\nRedis支持的键值数据类型如下\n\n- 字符串类型\n- 散列类型\n- 列表类型\n- 集合类型\n- 有序集合类型\n\n### 内存存储与持久化\n\nRedis将所有数据存储在内存中\n\nRedis提供了对持久化的支持：将内存中的数据异步写入硬盘\n\n### 功能丰富\n\n为键设置生存时间（Time To Live，TTL），生存时间到期后键会自动被删除\n\n可以限定数据占用的最大内存空间，在数据达到空间限制后，按照一定规则自动淘汰不需要的键\n\n*列表类型键可以用来实现队列，并支持阻塞式读取，可以很容易的实现一个高性能的优先队列*\n\n*Redis还支持“发布/订阅”的消息模式，可以基于此构建聊天室等系统*\n\n### 简单稳定\n\n# Install & start & stop\n\n```shell\nyum install wget gcc-c++ -y && mkdir -p /opt/soft && cd /opt/soft &&\twget https://mirrors.huaweicloud.com/redis/redis-3.0.7.tar.gz && tar -zxvf redis-3.0.7.tar.gz && ln -s redis-3.0.7 redis && cd redis && make && make install\n```\n\n## Redis可执行文件说明\n\n| 文件名           | 说明              |\n| ---------------- | ----------------- |\n| redis-server     | redis服务器       |\n| redis-cli        | redis命令行客户端 |\n| redis-benchmark  | redis性能测试工具 |\n| redis-check-aof  | AOF文件修复工具   |\n| redis-check-dump | RDB文件检查工具   |\n| redis-sentinel   | sentinel服务器    |\n\n## start\n\n### 直接启动\n\n```shell\nredis-server\n\nredis0-server --port 6380\n```\n\n### 通过初始化脚本启动\n\n\n\n## stop\n\n```shell\n# 正确停止redis\nredis-cli SHUTDOWN\n```\n\n# 通用命令\n\n```shell\nkeys pattern\n\nexists foo\n\ntype key\n```\n\n# 数据类型\n\n## 字符串\n\n```shell\nset key value\n\nget key\n```\n\n\n\n\n\n\n\n\n\n","tags":["database","redis"],"categories":["redis"]},{"title":"《趣谈网络协议》study notes","url":"/2021/02/08/《趣谈网络协议》study-notes/","content":"\n \n\n# 各个层网络协议\n\n## 协议三要素\n\n语法、语义、顺序\n\n## 网络数据包结构\n\nMac头 Ip头 Tcp头 Http头 数据体\n\n## 网络五层模型\n\n| 分层模型 |     简介     | 协议                                 |\n| :------: | :----------: | ------------------------------------ |\n|  应用层  |     连接     | DHCP HTTP HTTPS RTMP P2P DNS GTP RPC |\n|  传输层  |     定位     | UDP TCP                              |\n|  网络层  |     路由     | ICMP IP OSPF BGP IPSec GRE           |\n|  链路层  | 会话连接机制 | ARP VLAN STP                         |\n|  物理层  | 数据封装格式 | 网络跳线                             |\n\n## Q1\n\n当网络包到达一个城关的时候，可以通过路由表得到下一个城关的IP地址，直接通过IP地址找就可以了，为什么还要通过本地的MAC地址呢？\n\n> 1. mac地址是唯一的，为什么可以修改?想想身份证，身份证号是唯一的，不能改变的，但是可以造价。mac地址全球唯一，它是固化在网卡里的。网卡毕竟是个硬件，需要软件支持，既操作系统识别。重点来了，操作系统识别出来的mac地址是可以更改的，它只不过是一个字符串。我们常说的修改mac指的是修改电脑中记录的既注册表中的记录。\n> 2. 有了mac地址为什么还要有ip地址。举个例子，身份证号是你的唯一标识，不会重复，一落户就有（网卡一出厂就有mac）。现在我要和你通信（写信给你），地址用你的姓名+身份证，信能送到你手上吗?明显不能！身份证号前六位能定位你出生的县。mac地址前几位也可以定位生产厂家。但是你出生后会离开这个县（哪怕在这个县，也不能具体找到你）。所以一般写个人信息就要有出生地和现居地址了。\n\n> ip是网络层使用的 mac是链路层使用的 ip包最终还是要通过物理链接和mac地址进行交互的\n\n","tags":["network"],"categories":["network"]},{"title":"linux study notes","url":"/2021/01/23/linux-study-notes/","content":"\n```shell\n\n\n\n```\n\n","tags":["linux"],"categories":["linux"]},{"title":"read notes","url":"/2021/01/20/read-notes/","tags":["readnotes"],"categories":["readnotes"]},{"title":"Java - Log","url":"/2021/01/20/Java-Log/","content":"\n","tags":["java","log"],"categories":["java","log"]},{"title":"Tomcat study notes","url":"/2021/01/17/Tomcat-study-notes/","content":"\n# 学习备注\n\n```\nsession 和 cockie技术底层需要了解一下\n\n```\n\n\n\n# Tomcat学习基础及前置知识\n\n## 为什么要学习Tomcat\n\n```\n（1）Servlet 技术是 Web 开发的原点，几乎所有的 Java Web 框架（比如 SpringMVC）都是基于 Servlet 的封装，SpringMVC 应用本身就是一个 Servlet，而 Tomcat 和 Jetty 这样的 Web 容器，负责加载和运行 Servlet。\n\n（2）Tomcat 和 Jetty 中用到不少 Java 高级技术，比如 Java 多线程并发编程、Socket 网络编程以及反射等等。\n\n（3）通过对 Tomcat 和 Jetty 源码的学习，可以学会在什么样的场景下去用这些技术，这一点至关重要。\n\n（4）Tomcat 和 Jetty 作为工业级的中间件，它们的设计非常优秀，比如面向接口编程、组件化、骨架抽象类、一键式启停、对象池技术以及各种设计模式，比如模板方法、观察者模式、责任链模式等。可以模仿它们并把这些设计思想运用到实际的工作中。提高系统设计能力。\n\n（5）弄懂了 Tomcat 和 Jetty，Java Web 开发对你来说就已经毫无“秘密”可言。并且你能体会到大神们是如何设计 Tomcat 和 Jetty 的，体会他们如何思考问题、如何写代码。比如怎样设计服务端程序的 I/O 和线程模型、怎样写高性能高并发程序、Spring 的 IoC 容器为什么设计成这个样子、设计一个中间件或者框架有哪些套路等…这些都能快速增加你的经验值。\n```\n\n<img src=\"e213f384983f5420884aa085b27eded8.jpg\" />\n\n## web 概念\n\n（1）软件架构\n\n\t1. C/S： 客户端/服务器端 ------------> QQ , 360 ....\n\t\n\t2. B/S： 浏览器/服务器端 ------------> 京东， 网易 ， 淘宝 ， 传智播客官网\n\n\n（2）资源分类\n\n\t1. 静态资源： 所有用户访问后，得到的结果都是一样的，称为静态资源。静态资源可以直接被浏览器解析。\n\t\t* 如： html,css,JavaScript，jpg\n\t\t\n\t2. 动态资源: 每个用户访问相同资源后，得到的结果可能不一样 , 称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器，通过浏览器进行解析。\n\t\t* 如：servlet/jsp,php,asp....\n\n\n（3）网络通信三要素\n\n\t1. IP：电子设备(计算机)在网络中的唯一标识。\n\t\n\t2. 端口：应用程序在计算机中的唯一标识。 0~65536\n\t\n\t3. 传输协议：规定了数据传输的规则\n\t\t\n\t\t1. 基础协议：\n\t\t\t\n\t\t\t1. tcp : 安全协议，三次握手。 速度稍慢\n\t\t\t\n\t\t\t2. udp：不安全协议。 速度快\n## 常见的web服务器\n\n```\n1). webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\n\n2). webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\n\n3). JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\n\n4). Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。\n```\n\n## Web 容器是什么？\n\n```\nSun 公司推出了 Servlet 技术。你可以把 Servlet 简单理解为运行在服务端的 Java 小程序，但是 Servlet 没有 main 方法，不能独立运行，因此必须把它部署到 Servlet 容器中，由容器来实例化并调用 Servlet。\n\nTomcat 和 Jetty 就是一个 Servlet 容器。为了方便使用，它们也具有 HTTP 服务器的功能，因此 Tomcat 或者 Jetty 就是一个“HTTP 服务器 + Servlet 容器”，我们也叫它们 Web 容器。**\n\n其他应用服务器比如 JBoss 和 WebLogic，它们不仅仅有 Servlet 容器的功能，也包含 EJB 容器，是完整的 Java EE 应用服务器。Tomcat 和 Jetty 算是一个轻量级的应用服务器。\n\n我们希望运行服务的 Web 容器也是轻量级的，Web 容器本身应该消耗较少的内存和 CPU 资源，并且由应用本身来启动一个嵌入式的 Web 容器，而不是通过 Web 容器来部署和启动应用，这样可以降低应用部署的复杂度。\n\nTomcat 它本身也是 Spring Boot 默认的嵌入式 Servlet 容器。最新版本 Tomcat 和 Jetty 都支持 Servlet 4.0 规范。\n```\n\n- 内嵌方式运行servlet容器?\n\n```\n比如SpringBoot直接调用Web容器的提供的API去创建一个Web容器（HTTP服务器和Servlet容器），同时你的程序注册一个Servlet到Servlet容器中，比如SpringMVC的DispatcherServlet，这样请求到达时，Servlet容器负责调用你的Servlet。\n```\n\n## HTTP协议\n\n### HTTP 的本质\n\nHTTP 协议是浏览器与服务器之间的数据传送协议。作为应用层协议，HTTP 是基于 TCP/IP 协议来传递数据的（HTML 文件、图片、查询结果等），**HTTP 协议不涉及数据包（Packet）传输，主要规定了客户端和服务器之间的通信格式**。\n\n**HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式**\n\n- 浏览器\n\n```\n（1）与服务器建立 Socket 连接。\n（2）生成请求数据并通过 Socket 发送出去。\n```\n\n### HTTP 工作原理\n\n<img src=\"f5bd0c7840160d5a121c191e7e54b4ca.jpg\" />\n\n- Tomcat 和 Jetty 为了提高服务的能力和并发度，往往会将自己要做的几个事情并行化，具体来说就是使用多线程的技术。\n\n### HTTP 请求响应实例\n\n- **当 HTTP 请求数据到达 Tomcat 后，Tomcat 会把 HTTP 请求数据字节流解析成一个 Request 对象，这个 Request 对象封装了 HTTP 所有的请求信息。接着 Tomcat 把这个 Request 对象交给 Web 应用去处理，处理完后得到一个 Response 对象，Tomcat 会把这个 Response 对象转成 HTTP 格式的响应数据并发送给浏览器。**\n\n### Cookie 技术\n\nCookie 本质上就是一份存储在用户本地的文件，里面包含了每次请求中都需要传递的信息。\n\n### Session 技术\n\nSession 可以理解为服务器端开辟的存储空间，里面保存了用户的状态\n\n在 Java 中，是 Web 应用程序在调用 HttpServletRequest 的 getSession 方法时，由 Web 容器（比如 Tomcat）创建的。作为 Web 容器，Tomcat 负责创建和管理 Session，并提供了多种持久化方案来存储 Session。\n\n### qa：很多公司喜欢绕过容器，直接在应用中将会话数据存入中间件中？\n\n现在的web容器都支持将session存储在第三方中间件（如redis）中，为什么很多公司喜欢绕过容器，直接在应用中将会话数据存入中间件中？\n\n```\n用Web容器的Session方案需要侵入特定的Web容器，用Spring Session可能比较简单，不需要跟特定的Servlet容器打交道。\n\n这正是Spring喜欢做的事情，它使得程序员甚至感觉不到Servlet容器的存在，可以专心开发Web应用。但是Spring到底做了什么，Spring Session是如何实现的，我们还是有必要了解了解~\n\n其实它是通过Servlet规范中的Filter机制拦截了所有Servlet请求，偷梁换柱，将标准的Servlet请求对象包装了一下，换成它自己的Request包装类对象，这样当程序员通过包装后的Request对象的getSession方法拿Session时，是通过Spring拿Session，没Web容器什么事了。\n```\n\n## Servlet规范和Servlet容器\n\n浏览器发给服务端的是一个 HTTP 格式的请求，HTTP 服务器收到这个请求后，需要调用服务端程序来处理，所谓的服务端程序就是你写的 Java 类，一般来说不同的请求需要由不同的 Java 类来处理。\n\n那么问题来了，HTTP 服务器怎么知道要调用哪个 Java 类的哪个方法呢。最直接的做法是在 HTTP 服务器代码里写一大堆 if else 逻辑判断：如果是 A 请求就调 X 类的 M1 方法，如果是 B 请求就调 Y 类的 M2 方法。但这样做明显有问题，因为 HTTP 服务器的代码跟业务逻辑耦合在一起了，如果新加一个业务方法还要改 HTTP 服务器的代码。\n\n那该怎么解决这个问题呢？我们知道，面向接口编程是解决耦合问题的法宝，于是有一伙人就定义了一个接口，各种业务类都必须实现这个接口，这个接口就叫 Servlet 接口，有时我们也把实现了 Servlet 接口的业务类叫作 Servlet。\n\n但是这里还有一个问题，对于特定的请求，HTTP 服务器如何知道由哪个 Servlet 来处理呢？Servlet 又是由谁来实例化呢？显然 HTTP 服务器不适合做这个工作，否则又和业务类耦合了。\n\n于是，还是那伙人又发明了 Servlet 容器，Servlet 容器用来加载和管理业务类。HTTP 服务器不直接跟业务类打交道，而是把请求交给 Servlet 容器去处理，Servlet 容器会将请求转发到具体的 Servlet，如果这个 Servlet 还没创建，就加载并实例化这个 Servlet，然后调用这个 Servlet 的接口方法。因此 Servlet 接口其实是 Servlet 容器跟具体业务类之间的接口。下面我们通过一张图来加深理解。\n\n<img src=\"dfe304d3336f29d833b97f2cfe8d7801.jpg\" />\n\n图的左边表示 HTTP 服务器直接调用具体业务类，它们是紧耦合的。再看图的右边，HTTP 服务器不直接调用业务类，而是把请求交给容器来处理，容器通过 Servlet 接口调用业务类。因此 Servlet 接口和 Servlet 容器的出现，达到了 HTTP 服务器与业务类解耦的目的。\n\n**而 Servlet 接口和 Servlet 容器这一整套规范叫作 Servlet 规范**。Tomcat 和 Jetty 都按照 Servlet 规范的要求实现了 Servlet 容器，同时它们也具有 HTTP 服务器的功能。作为 Java 程序员，如果我们要实现新的业务功能，只需要实现一个 Servlet，并把它注册到 Tomcat（Servlet 容器）中，剩下的事情就由 Tomcat 帮我们处理了。\n\n### Servlet 接口\n\nServlet 接口定义了下面五个方法：\n\n```java\npublic interface Servlet {\n  // Servlet 容器在加载 Servlet 类的时候会调用 init 方法,我们可能会在 init 方法里初始化一些资源，比如 Spring MVC 中的 DispatcherServlet，就是在 init 方法里创建了自己的 Spring 容器\n    void init(ServletConfig config) throws ServletException;\n    \n  \n  // ServletConfig 的作用就是封装 Servlet 的初始化参数。你可以在web.xml给 Servlet 配置参数，并在程序里通过 getServletConfig 方法拿到这些参数\n    ServletConfig getServletConfig();\n    \n  \n  \t// ServletRequest 用来封装请求信息，ServletResponse 用来封装响应信息，因此本质上这两个类是对通信协议的封装。\n  // 比如 HTTP 协议中的请求和响应就是对应了 HttpServletRequest 和 HttpServletResponse 这两个类。可以通过 HttpServletRequest 来获取所有请求相关的信息，包括请求路径、Cookie、HTTP 头、请求参数等。此外，我们还可以通过 HttpServletRequest 来创建和获取 Session。而 HttpServletResponse 是用来封装 HTTP 响应的。\n    void service(ServletRequest req, ServletResponse res）throws ServletException, IOException;\n    \n                 \n    String getServletInfo();\n    \n                 \n    // servlet容器卸载的时候会调用 destroy 方法，可以在destroy 方法里释放这些资源\n    void destroy();\n}\n```\n\n- Servlet 规范提供了 GenericServlet 抽象类，我们可以通过扩展它来实现 Servlet。虽然 Servlet 规范并不在乎通信协议是什么，但是大多数的 Servlet 都是在 HTTP 环境中处理的，因此 Servet 规范还提供了 HttpServlet 来继承 GenericServlet，并且加入了 HTTP 特性。这样我们通过继承 HttpServlet 类来实现自己的 Servlet，只需要重写两个方法：doGet 和 doPost。\n\n### Servlet 容器\n\n- 工作流程\n\n当客户请求某个资源时，HTTP 服务器会用一个 ServletRequest 对象把客户的请求信息封装起来，然后调用 Servlet 容器的 service 方法，Servlet 容器拿到请求后，根据请求的 URL 和 Servlet 的映射关系，找到相应的 Servlet，如果 Servlet 还没有被加载，就用反射机制创建这个 Servlet，并调用 Servlet 的 init 方法来完成初始化，接着调用 Servlet 的 service 方法来处理请求，把 ServletResponse 对象返回给 HTTP 服务器，HTTP 服务器会把响应发送给客户端。\n\n<img src=\"b70723c89b4ed0bccaf073c84e08e115.jpg\" />\n\n### Web 应用\n\n- Servlet 是怎么注册到 Servlet 容器中的呢？\n\n一般来说，我们是以 Web 应用程序的方式来部署 Servlet 的，而根据 Servlet 规范，Web 应用程序有一定的目录结构，在这个目录下分别放置了 Servlet 的类文件、配置文件以及静态资源，Servlet 容器通过读取配置文件，就能找到并加载 Servlet。\n\n- Web 应用的目录结构大概是下面这样的：\n\n```\n| -  MyWebApp\n      | -  WEB-INF/web.xml        -- 配置文件，用来配置Servlet等\n      | -  WEB-INF/lib/           -- 存放Web应用所需各种JAR包\n      | -  WEB-INF/classes/       -- 存放你的应用类，比如Servlet类\n      | -  META-INF/              -- 目录存放工程的一些信息\n```\n\n**Servlet 规范里定义了 ServletContext 这个接口来对应一个 Web 应用**。Web 应用部署好后，Servlet 容器在启动时会加载 Web 应用，并为每个 Web 应用创建唯一的 ServletContext 对象。你可以把 ServletContext 看成是一个全局对象，一个 Web 应用可能有多个 Servlet，这些 Servlet 可以通过全局的 ServletContext 来共享数据，这些数据包括 Web 应用的初始化参数、Web 应用目录下的文件资源等。由于 ServletContext 持有所有 Servlet 实例，你还可以通过它来实现 Servlet 请求的转发。\n\n### 扩展机制\n\n- Servlet 规范提供了两种扩展机制：Filter 和 Listener\n\nFilter 是过滤器，这个接口允许你对请求和响应做一些统一的定制化处理，比如你可以根据请求的频率来限制访问，或者根据国家地区的不同来修改响应内容。过滤器的工作原理是这样的：Web 应用部署完成后，Servlet 容器需要实例化 Filter 并把 Filter 链接成一个 FilterChain。当请求进来时，获取第一个 Filter 并调用 doFilter 方法，doFilter 方法负责调用这个 FilterChain 中的下一个 Filter。\n\n\n\nListener 是监听器，这是另一种扩展机制。当 Web 应用在 Servlet 容器中运行时，Servlet 容器内部会不断的发生各种事件，如 Web 应用的启动和停止、用户请求到达等。 Servlet 容器提供了一些默认的监听器来监听这些事件，当事件发生时，Servlet 容器会负责调用监听器的方法。当然，你可以定义自己的监听器去监听你感兴趣的事件，将监听器配置在web.xml中。比如 Spring 就实现了自己的监听器，来监听 ServletContext 的启动事件，目的是当 Servlet 容器启动时，创建并初始化全局的 Spring 容器。\n\n- Filter 是干预过程的，它是过程的一部分，是基于过程行为的。\n\n- Listener 是基于状态的，任何行为改变同一个状态，触发的事件是一致的。\n\n\n\n**Servlet 本质上是一个接口，实现了 Servlet 接口的业务类也叫 Servlet。Servlet 接口其实是 Servlet 容器跟具体 Servlet 业务类之间的接口。Servlet 接口跟 Servlet 容器这一整套规范叫作 Servlet 规范，而 Servlet 规范使得程序员可以专注业务逻辑的开发，同时 Servlet 规范也给开发者提供了扩展的机制 Filter 和 Listener。**\n\n##  Tomcat 目录结构\n\n| **目录**    | **目录下文件**             | **说明**                                                     |\n| ----------- | -------------------------- | ------------------------------------------------------------ |\n| **bin**     | /                          | 存放Tomcat的启动、停止等批处理脚本文件                       |\n|             | startup.bat , startup.sh   | 用于在windows和linux下的启动脚本                             |\n|             | shutdown.bat , shutdown.sh | 用于在windows和linux下的停止脚本                             |\n| **conf**    | /                          | 用于存放Tomcat的相关配置文件                                 |\n|             | Catalina                   | 用于存储针对每个虚拟机的Context配置                          |\n|             | context.xml                | 用于定义所有web应用均需加载的Context配置，如果web应用指定了自己的context.xml ，该文件将被覆盖 |\n|             | catalina.properties        | Tomcat 的环境变量配置                                        |\n|             | catalina.policy            | Tomcat 运行的安全策略配置                                    |\n|             | logging.properties         | Tomcat 的日志配置文件， 可以通过该文件修改Tomcat  的日志级别及日志路径等 |\n|             | server.xml                 | Tomcat 服务器的核心配置文件                                  |\n|             | tomcat-users.xml           | 定义Tomcat默认的用户及角色映射信息配置                       |\n|             | web.xml                    | Tomcat 中所有应用默认的部署描述文件， 主要定义了基础Servlet和MIME映射。 |\n| **lib**     | /                          | Tomcat 服务器的依赖包                                        |\n| **logs**    | /                          | Tomcat 默认的日志存放目录                                    |\n| **webapps** | /                          | Tomcat 默认的Web应用部署目录                                 |\n| **work**    | /                          | Web 应用JSP代码生成和编译的临时目录                          |\n\n## Tomcat历史\n\n1） Tomcat 最初由Sun公司的软件架构师 James Duncan Davidson 开发，名称为 “JavaWebServer”。\n\n2） 1999年 ，在 Davidson 的帮助下，该项目于1999年于apache 软件基金会旗下的 JServ 项目合并，并发布第一个版本（3.x）, 即是现在的Tomcat，该版本实现了Servlet2.2 和 JSP 1.1 规范 。\n\n3） 2001年，Tomcat 发布了4.0版本， 作为里程碑式的版本，Tomcat 完全重新设计了其架构，并实现了 Servlet 2.3 和 JSP1.2规范。\n\n\n\n目前 Tomcat 已经更新到 10.x版本 ， 但是目前企业中的Tomcat服务器， 主流版本还是 7.x 和 8.x ， 所以本课程是基于 8.5 版本进行讲解。\n\n# Tomcat 系统架构\n\n## **总体架构**\n\n<img src=\"WechatIMG925.png\" width=\"800px\"/>\n\n- tomcat有两个非常重要的功能需要完成\n\n（1）和客户端浏览器进行交互，进行socket通信，将字节流和Request/Response等对象进行转换\n\n（2）Servlet容器处理业务逻辑\n\n<img src=\"WechatIMG926.png\" width=\"800px\"/>\n\n- Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理。\n\n**连接器，负责对外交流:** 处理Socket连接，负责网络字节流与Request和Response对象的转化; \n\n**容器，负责内部处理:**加载和管理Servlet，以及具体处理Request请求;\n\n","tags":["tomcat"],"categories":["tomcat"]},{"title":"SpringMVC study notes","url":"/2021/01/14/SpringMVC-study-notes/","content":"\n# 学习备注\n\n> Controller 接收请求参数，这块，复杂类型的参数一定都走一遍。可以参考java工程师2019版本的代码\n>\n\n# SpringMVC 概述\n\n## SpringMVC 核心内容\n\n```\n1.SpringMVC 概述\n2.SpringMVC 的 HelloWorld\n3.使用 @RequestMapping 映射请求\n4.映射请求参数 & 请求头\n5.处理模型数据\n6.视图和视图解析器\n7.RESTful CRUD\n8.SpringMVC 表单标签 &处理静态资源\t\n9.数据转换 & 数据格式化 & 数据校验\n10.处理 JSON：使用 HttpMessageConverter\n11.国际化 \n12.文件的上传\n13.使用拦截器 \n14.异常处理\n15.SpringMVC 运行流程\n16.在 Spring 的环境下使用 SpringMVC\n17.SpringMVC 对比 Struts2\n```\n\n## SpringMVC概述\n\n```\n（1）Spring 为展现层提供的基于 MVC 设计理念的优秀的 Web 框架，是目前最主流的 MVC 框架之一。\n（2）Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。\n（3）Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。\n（4）支持 REST 风格的 URL 请求。\n（5）采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性\n```\n\n## 是什么\n\n```\n一种轻量级的、基于MVC的Web层应用框架。偏前端而不是基于业务逻辑层。\n是Spring框架的一个后续产品。\n```\n\n## 能干什么\n\n```\n天生与Spring框架集成，如：(IOC,AOP)\n支持Restful风格\n进行更简洁的Web层开发\n支持灵活的URL到页面控制器的映射\n非常容易与其他视图技术集成，如:Velocity、FreeMarker等等。\n因为模型数据不存放在特定的API里，而是放在一个Model里(Map数据结构实现，因此很容易被其他框架使用)\n非常灵活的数据验证、格式化和数据绑定机制、能使用任何对象进行数据绑定，不必实现特定框架的API\n更加简单、强大的异常处理\n对静态资源的支持\n支持灵活的本地化、主题等解析\n```\n\n## 怎么玩\n\n```\n（1）将Web层进行了职责解耦，也就和struts2一样，基于请求-响应模型\n\n（2）常用主要组件\n  DispatcherServlet：前端控制器\n  Controller：处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理\n  HandlerMapping ：请求映射到处理器，找谁来处理，如果映射成功返回一个HandlerExecutiongChain对象（包含一个Handler处理器(页面控制器)对象、多个HandlerInterceptor拦截器对象） \n  ViewResolver : 视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体的View,进行这种策略模式，很容易更换其他视图技术；\n      如InternalResourceViewResolver将逻辑视图名映射为JSP视图\n  LocalResolver：本地化、国际化\n  MultipartResolver：文件上传解析器\n  HandlerExceptionResolver：异常处理器\n```\n\n\n\n# SpringMVC HelloWorld\n\n## （1）创建web项目工程，导包\n\n```\nspring-aop-4.0.0.RELEASE.jar\nspring-beans-4.0.0.RELEASE.jar\nspring-context-4.0.0.RELEASE.jar\nspring-core-4.0.0.RELEASE.jar\nspring-expression-4.0.0.RELEASE.jar\ncommons-logging-1.1.3.jar\nspring-web-4.0.0.RELEASE.jar\nspring-webmvc-4.0.0.RELEASE.jar\n```\n\n## （2）写配置\n\n- web.xml（配置DispatcherServlet）\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\">\n  \n  <display-name>1.SpringMVC_helloworld</display-name>\n  <welcome-file-list>\n    <welcome-file>index.jsp</welcome-file>\n  </welcome-file-list>\n  \n  <!-- SpringMVC思想是有一个前端控制器能拦截所有请求，并智能派发;\n  \t这个前端控制器是一个servlet；应该在web.xml中配置这个servlet来拦截所有请求\n   -->\n   <!-- The front controller of this Spring Web application, \n   responsible for handling all application requests -->\n\t<servlet>\n\t\t<servlet-name>springDispatcherServlet</servlet-name>\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n\t\t\n\t\t<init-param>\n      <!-- \n      如果不指定配置文件位置？/WEB-INF/springDispatcherServlet-servlet.xml\n      如果不指定也会默认去找一个文件；/WEB-INF/springDispatcherServlet-servlet.xml\n      就在web应用的/WEB-INF、下创建一个名叫   前端控制器名-servlet.xml\n\t\t\t-->\n\t\t\t<!-- contextConfigLocation:指定SpringMVC配置文件位置 -->\n\t\t\t<param-name>contextConfigLocation</param-name>\n\t\t\t<param-value>classpath:springmvc.xml</param-value>\n\t\t</init-param>\n\t\t<!-- servlet启动加载，servlet原本是第一次访问创建对象；\n\t\tload-on-startup:服务器启动的时候创建对象；值越小优先级越高，越先创建对象；\n\t\t -->\n\t\t<load-on-startup>0</load-on-startup>\n\t</servlet>\n\n\t<!-- Map all requests to the DispatcherServlet for handling -->\n\t<servlet-mapping>\n\t\t<servlet-name>springDispatcherServlet</servlet-name>\n\t\t\n    <!-- \n        /：拦截所有请求，不拦截jsp页面，*.jsp请求\n        /*：拦截所有请求，拦截jsp页面，*.jsp请求            \n        处理*.jsp是tomcat做的事；所有项目的小web.xml都是继承于大web.xml\n        DefaultServlet是Tomcat中处理静态资源的？\n            除过jsp，和servlet外剩下的都是静态资源；\n            index.html：静态资源，tomcat就会在服务器下找到这个资源并返回;\n            我们前端控制器的/禁用了tomcat服务器中的DefaultServlet          \n        \n        1）服务器的大web.xml中有一个DefaultServlet是url-pattern=/\n        2）我们的配置中前端控制器 url-pattern=/\n                静态资源会来到DispatcherServlet（前端控制器）看那个方法的RequestMapping是这个index.html\n        3）为什么jsp又能访问；因为我们没有覆盖服务器中的JspServlet的配置\n        4） /*  直接就是拦截所有请求；我们写/；也是为了迎合后来Rest风格的URL地址\n    -->\n\t\t<url-pattern>/</url-pattern>\n\t</servlet-mapping>\n  \n</web-app>\n```\n\n- springmvc.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n\n\t<!-- 扫描所有组件 -->\n\t<context:component-scan base-package=\"com.atguigu\"></context:component-scan>\n\t\n\t<!-- 配置一个视图解析器 ；能帮我们拼接页面地址-->\n\t<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<property name=\"prefix\" value=\"/WEB-INF/pages/\"></property>\n\t\t<property name=\"suffix\" value=\".jsp\"></property>\n\t</bean>\n</beans>\n```\n\n## （3）测试（编写业务类并测试）\n\n```java\n/**\n * 1、告诉SpringMVC这是一个处理器，可以处理请求\n * \t\t@Controller：标识哪个组件是控制器\n */\n@Controller\npublic class MyFirstController {\n\t/**\n\t * \t @RequestMapping:告诉SpringMVC这个方法处理什么请求；\n\t *   /代表从当前项目下开始；处理当前项目下的hello请求\n\t */\n\t@RequestMapping(\"/hello\")\n\tpublic String myfirstRequest(){\n\t\tSystem.out.println(\"请求收到了....正在处理中\");\n\t\t//视图解析器自动拼串；\n//\t\t<property name=\"prefix\" value=\"/WEB-INF/pages/\"></property>\n//\t\t<property name=\"suffix\" value=\".jsp\"></property>\n\t\t//   (前缀)/WEB-INF/pages/+返回值(success)+后缀（.jsp）\n\t\treturn \"success\";\n\t}\n\n}\n```\n\n## HelloWorld 运行流程细节\n\n```\n （1）客户端点击链接会发送 `http://localhost:8080/hello` 请求\n （2）来到tomcat服务器；\n （3）SpringMVC的前端控制器收到所有请求；\n （4）来看请求地址和@RequestMapping标注的哪个匹配，来找到到底使用那个类的哪个方法来处理\n （5）前端控制器找到了目标处理器类和目标方法，直接利用返回执行目标方法；\n （6）方法执行完成以后会有一个返回值；SpringMVC认为这个返回值就是要去的页面地址\n （7）拿到方法返回值以后；用视图解析器进行拼串得到完整的页面地址；\n （8）拿到页面地址，前端控制器帮我们转发到页面；\n```\n\n- SpringMVC处理示意图\n\n<img src=\"WechatIMG361.png\" width=\"800px\" />\n\n# @RequestMapping\n\n```java\n@Controller\npublic class HelloController {\n  /*\n  @RequestMapping(\"/hello01\") 就是告诉SpringMVC；这个方法用来处理什么请求；\n \t\t这个/是可以省略，即使省略了，也是默认从当前项目下开始；习惯加上比较好（该注解也可以使用在类上）\n  */\n\t@RequestMapping(\"/hello01\")\n\tpublic String nihao(){\n\t\treturn \"success\";\n\t}\n\t\n\t@RequestMapping(\"/hello\")\n\tpublic String myfirstRequest(){\n\t\tSystem.out.println(\"请求收到了....正在处理中\");\n\t\t//视图解析器自动拼串；\n//\t\t<property name=\"prefix\" value=\"/WEB-INF/pages/\"></property>\n//\t\t<property name=\"suffix\" value=\".jsp\"></property>\n\t\t//   (前缀)/WEB-INF/pages/+返回值(success)+后缀（.jsp）\n\t\treturn \"success\";\n\t}\n}\n```\n\n```java\n/**\n * 为当前类所有的方法的请求地址指定一个基准路径\n */\n@RequestMapping(\"/haha\")\n@Controller\npublic class RequestMappingTestController {\t\n\t/**\n\t * RequestMapping的其他属性\n\t * method：限定请求方式、\n\t * \t\tHTTP协议中的所有请求方式：\n\t * \t\t\t【GET】, HEAD, 【POST】, PUT, PATCH, DELETE, OPTIONS, TRACE\n\t * \t\tGET、POST\n\t * \t\tmethod=RequestMethod.POST：只接受这种类型的请求，默认是什么都可以；\n\t * \t\t\t不按规定的请求方式访问会报错：4xx:都是客户端错误\n\t * \t\t\t\t405 - Request method 'GET' not supported\n\t *\n\t * params：规定请求参数\n\t * params 和 headers支持简单的表达式：\n\t * \t\t\teg：params={\"username\"}:\n\t * \t\t\t\t发送请求的时候必须带上一个名为username的参数；没带都会404\n\t * \n\t * \t\t\teg:params={\"!username\"}\n\t * \t\t\t\t发送请求的时候必须不携带上一个名为username的参数；带了都会404\n\t \n\t * \t\tparam1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1\n\t * \t\t\teg：params={\"username!=123\"}\n\t * \t\t\t\t发送请求的时候;携带的username值必须不是123(不带username或者username不是123)\n\t * \n\t * \t\t{“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2 的两个请求参数，且 param1 参数的值必须为 value1\n\t * \t\t\teg:params={\"username!=123\",\"pwd\",\"!age\"}\n\t * \t\t\t\t请求参数必须满足以上规则；\n\t * \t\t\t\t请求的username不能是123，必须有pwd的值，不能有age\n\t *\n\t * headers：规定请求头；也和params一样能写简单的表达式\n\t * \t\n\t * consumes：只接受内容类型是哪种的请求，规定请求头中的Content-Type\n\t * produces：告诉浏览器返回的内容类型是什么，给响应头中加上Content-Type:text/html;charset=utf-8\n\t */\n\t@RequestMapping(value=\"/handle02\",method=RequestMethod.POST)\n\tpublic String handle02(){\n\t\tSystem.out.println(\"handle02...\");\n\t\treturn \"success\";\n\t}\n\t\n\t@RequestMapping(value=\"/handle03\",params={\"username!=123\",\"pwd\",\"!age\"})\n\tpublic String handle03(){\n\t\tSystem.out.println(\"handle03....\");\n\t\treturn \"success\";\n\t}\n\t\n\t/**\n\t * User-Agent：浏览器信息；\n\t * 让火狐能访问，让谷歌不能访问\n\t * \n\t * 谷歌：\n\t * User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\n\t * 火狐;\n\t * User-Agent\tMozilla/5.0 (Windows NT 6.3; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0\n\t * @return\n\t * \n\t */\n\t@RequestMapping(value=\"/handle04\",headers={\"User-Agent=Mozilla/5.0 (Windows NT 6.3; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0\"})\n\tpublic String handle04(){\n\t\tSystem.out.println(\"handle04....\");\n\t\treturn \"success\";\n\t}\n}\n```\n\n```java\n/**\n * \t@RequestMapping模糊匹配功能\n\n * URL地址可以写模糊的通配符：\n * \t？：能替代任意一个字符\n * \t*：能替代任意多个字符，和一层路径\n * \t**：能替代多层路径\n */\n@Controller\npublic class RequestMappingTest {\n\t/**\n\t * ?匹配一个字符,0个多个都不行;\n\t * \t\t模糊和精确多个匹配情况下，精确优先\n\t * @return\n\t */\n\t@RequestMapping(\"/antTest0?\")\n\tpublic String antTest02(){\n\t\tSystem.out.println(\"antTest02...\");\n\t\treturn \"success\";\n\t}\n\t\n\t/**\n\t *   *匹配任意多个字符\n\t */\n\t@RequestMapping(\"/antTest0*\")\n\tpublic String antTest03(){\n\t\tSystem.out.println(\"antTest03...\");\n\t\treturn \"success\";\n\t}\n\t\n\t/**\n\t *  *：匹配一层路径\n\t * @return\n\t */\n\t@RequestMapping(\"/a/*/antTest01\")\n\tpublic String antTest04(){\n\t\tSystem.out.println(\"antTest04...\");\n\t\treturn \"success\";\n\t}\n\t\n\t@RequestMapping(\"/a/**/antTest01\")\n\tpublic String antTest05(){\n\t\tSystem.out.println(\"antTest05...\");\n\t\treturn \"success\";\n\t}\n}\n```\n\n## @PathVariable\n\n- 匹配路径上占位符的值\n\n```java\n\t//路径上可以有占位符：  占位符 语法就是可以在任意路径的地方写一个{变量名}\n\t//   /user/admin    /user/leifengyang\n\t// 路径上的占位符只能占一层路径\n\t@RequestMapping(\"/user/{id}\")\n\tpublic String pathVariableTest(@PathVariable(\"id\")String id){\n\t\tSystem.out.println(\"路径上的占位符的值\"+id);\n\t\treturn \"success\";\n\t}\n```\n\n# Rest\n\n```java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\npublic class BookController {\n\t/**\n\t * 处理查询图书请求\n\t * @param id\n\t * @return\n\t */\n\t@RequestMapping(value=\"/book/{bid}\",method=RequestMethod.GET)\n\tpublic String getBook(@PathVariable(\"bid\")Integer id) {\n\t\tSystem.out.println(\"查询到了\"+id+\"号图书\");\n\t\treturn \"success\";\n\t}\n\t\n\t/**\n\t * 图书删除\n\t * @param id\n\t * @return\n\t */\n\t@RequestMapping(value=\"/book/{bid}\",method=RequestMethod.DELETE)\n\tpublic String deleteBook(@PathVariable(\"bid\")Integer id) {\n\t\tSystem.out.println(\"删除了\"+id+\"号图书\");\n\t\treturn \"success\";\n\t}\n\n\t/**\n\t * 图书更新\n\t * @return\n\t */\n\t@RequestMapping(value=\"/book/{bid}\",method=RequestMethod.PUT)\n\tpublic String updateBook(@PathVariable(\"bid\")Integer id) {\n\t\tSystem.out.println(\"更新了\"+id+\"号图书\");\n\t\treturn \"success\";\n\t}\n\n\t@RequestMapping(value=\"/book\",method=RequestMethod.POST)\n\tpublic String addBook() {\n\t\tSystem.out.println(\"添加了新的图书\");\n\t\treturn \"success\";\n\t}\n}\n```\n\n## 从页面发起PUT、DELETE形式的请求? Spring提供了对Rest风格的支持\n\n（1）SpringMVC中有一个Filter；他可以把普通的请求转化为规定形式的请求；配置这个filter;\n\n```xml\n<!--SpringMVC中有一个Filter；他可以把普通的请求转化为规定形式的请求；配置这个filter; -->\t\n<filter>\n\t\t<filter-name>HiddenHttpMethodFilter</filter-name>\n\t\t<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n\t</filter>\n\t<filter-mapping>\n\t\t<filter-name>HiddenHttpMethodFilter</filter-name>\n\t\t<url-pattern>/*</url-pattern>\n\t</filter-mapping>\n```\n\n（2）如何发其他形式请求？\n\n- 按照以下要求：\n\n1、创建一个post类型的表单 \n\n2、表单项中携带一`_method的`参数\n\n3、这个`_method`的值就是DELETE、PUT\n\n```html\n<!-- 发送DELETE请求 -->\n<form action=\"book/1\" method=\"post\">\n\t<input name=\"_method\" value=\"delete\"/>\n\t<input type=\"submit\" value=\"删除1号图书\"/>\n</form><br/>\n\n<!-- 发送PUT请求 -->\n<form action=\"book/1\" method=\"post\">\n\t<input name=\"_method\" value=\"put\"/>\n\t<input type=\"submit\" value=\"更新1号图书\"/>\n</form><br/>\n```\n\n- 高版本Tomcat；Rest支持有点问题\n\n解决方案\n\n<img src=\"WechatIMG928.png\" />\n\n# 请求参数/数据绑定\n\n```java\n@Controller\npublic class HelloController {\n\n\t/**\n\t * SpringMVC如何获取请求带来的各种信息 默认方式获取请求参数： 直接给方法入参上写一个和请求参数名相同的变量。这个变量就来接收请求参数的值；\n\t * 带：有值，没带：null；\n\t * \n\t * @RequestParam：获取请求参数的；参数默认是必须带的；\n\t * @RequestParam(\"user\")String username username =\n\t *                             request.getParameter(\"user\")\n\t * \n\t * @PathVariable(\"user\") \n\t *                       /book/【{user}pathvariable】?【user=admin(requestparam)\n\t *                       】\n\t * \n\t *                       value:指定要获取的参数的key required:这个参数是否必须的\n\t *                       defaultValue:默认值。没带默认是null；\n\t * \n\t * \n\t * @RequestHeader：获取请求头中某个key的值； request.getHeader(\"User-Agent\")；\n\t * @RequestHeader(\"User-Agent\")String userAgent userAgent =\n\t *                                    request.getHeader(\"User-Agent\")\n\t *                                    如果请求头中没有这个值就会报错； \n\t *                                    value() required() defaultValue()\n\t * \n\t * @CookieValue：获取某个cookie的值； 以前的操作获取某个cookie； Cookie[] cookies =\n\t *                            request.getCookies(); for(Cookie c:cookies){\n\t *                            if(c.getName().equals(\"JSESSIONID\")){ String\n\t *                            cv = c.getValue(); } }\n\t * value()\n\t * required()\n\t * defaultValue()\n\t */\n\t@RequestMapping(\"/handle01\")\n\tpublic String handle02(\n\t\t\t@RequestParam(value = \"user\", required = false, defaultValue = \"你没带\") String username,\n\t\t\t@RequestHeader(value = \"AHAHA\", required = false, defaultValue = \"她也没带\") String userAgent,\n\t\t\t@CookieValue(value=\"JSESSIONID\",required=false)String jid) {\n\t\tSystem.out.println(\"这个变量的值：\" + username);\n\t\tSystem.out.println(\"请求头中浏览器的信息：\" + userAgent);\n\t\tSystem.out.println(\"cookie中的jid的值\"+jid);\n\t\treturn \"success\";\n\t}\n\t\n\t/**\n\t * 如果我们的请求参数是一个POJO；\n\t * SpringMVC会自动的为这个POJO进行赋值？\n\t * 1）、将POJO中的每一个属性，从request参数中尝试获取出来，并封装即可；\n\t * 2）、还可以级联封装；属性的属性\n\t * 3）、请求参数的参数名和对象中的属性名一一对应就行\n\t * \n\t * \n\t * 提交的数据可能有乱码：\n\t * 请求乱码：\n\t * \t\tGET请求：改server.xml；在8080端口处URIEncoding=\"UTF-8\"\n\t * \t\tPOST请求：\n\t * \t\t\t在第一次获取请求参数之前设置\n\t * \t\t\trequest.setCharacterEncoding(\"UTF-8\");\n\t * \t\t\t自己写一个filter；SpringMVC有这个filter\n\t * \t\t\t\n\t * 响应乱码：\n\t * \t\tresponse.setContentType(\"text/html;charset=utf-8\")\n\t * @param book\n\t * @return\n\t */\n\t@RequestMapping(\"/book\")\n\tpublic String addBook(Book book){\n\t\tSystem.out.println(\"我要保存的图书：\"+book);\n\t\treturn \"success\";\n\t}\n\t\n\t/**\n\t * SpringMVC可以直接在参数上写原生API;\n\t * \n\t * HttpServletRequest\n\t * HttpServletResponse\n\t * HttpSession\n\t * \n\t * \n\t * java.security.Principal\n\t * Locale：国际化有关的区域信息对象\n\t * InputStream：\n\t * \t\tServletInputStream inputStream = request.getInputStream();\n\t * OutputStream：\n\t * \t\tServletOutputStream outputStream = response.getOutputStream();\n\t * Reader：\n\t * \t\tBufferedReader reader = request.getReader();\n\t * Writer：\n\t * \t\tPrintWriter writer = response.getWriter();\n\t * \t\t\n\t * @throws IOException \n\n\t * \n\t * \n\t */\n\t@RequestMapping(\"/handle03\")\n\tpublic String handle03(HttpSession session,\n\t\t\tHttpServletRequest request,HttpServletResponse response) throws IOException {\n\t\trequest.setAttribute(\"reqParam\", \"我是请求域中的\");\n\t\tsession.setAttribute(\"sessionParam\", \"额我是Session域中的\");\n\t\t\n\t\treturn \"success\";\n\t}\n\n}\n\n```\n\n## 数据绑定\n\n- 使用controller方法参数接收\n\n- 使用java bean接收数据\n\n（1）简单数据\n\n（2）复杂数据\n\n> array\n>\n> list\n>\n> java bean\n>\n> list\\<Object\\>\n\n- 全局String转Date - 配置\n\n```java\npackage com.study.springmvc.converter;\n\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.format.annotation.DateTimeFormat;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class MyDateConverter implements Converter<String, Date> {\n    @Override\n    public Date convert(String s) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        try {\n            Date d = sdf.parse(s);\n            return d;\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}\n```\n\napplicationContext.xml 做如下配置\n\n```xml\n   <!--启用Spring MVC的注解开发模式-->\n    <mvc:annotation-driven conversion-service=\"conversionService\"/>\n    \n    \n    <bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n        <property name=\"converters\">\n            <set>\n                <bean class=\"com.study.springmvc.converter.MyDateConverter\" />\n            </set>\n        </property>\n    </bean>\n    \n```\n\n\n\n# 解决中文乱码\n\n（1）get请求乱码\n\n```shell\n# tomcat server.xml 增加 URLEncoding=UTF-8\n# tomcat8 默认 utf-8编码\n```\n\n（2）post请求乱码\n\n```shell\n# web.xml 配置配置CharacterEnchodingFilter\n\n    <filter>\n        <filter-name>charactorFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>charactorFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n```\n\n（3）response响应乱码\n\nspringContext.xml 中做如下配置\n\n```xml\n    <!--启用Spring MVC的注解开发模式-->\n    <mvc:annotation-driven conversion-service=\"conversionService\">\n        <mvc:message-converters>\n    <!--解决中文乱码问题-->\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                <property name=\"supportedMediaTypes\">\n                    <list>\n                        <value>text/html;charset=utf-8</value>\n                    </list>\n                </property>\n            </bean>\n        </mvc:message-converters>\n    </mvc:annotation-driven>\n```\n\n\n\n---\n\n\n\n","tags":["SpringMVC"],"categories":["SpringMVC"]},{"title":"Spring5 study notes","url":"/2021/01/13/Spring5-study-notes/","content":"\n# Spring框架概述\n\n## Spring框架内容概览\n\n（1）spring框架概述\n\n（2）IOC容器\n\n> IOC 底层原理\n>\n> IOC 接口(BeanFactory) \n>\n> IOC 操作 Bean 管理(基于 xml) \n>\n> IOC 操作 Bean 管理(基于注解)\n\n（3）AOP\n\n（4）JdbcTemplate\n\n（5）事务管理\n\n（6）Spring5新特性\n\n## Spring框架概述\n\n1、Spring 是轻量级的开源的 JavaEE 框架\n\n2、Spring 可以解决企业应用开发的复杂性\n\n3、Spring 有两个核心部分:IOC 和 Aop\n\n (1)IOC:控制反转，把创建对象过程交给 Spring 进行管理\n\n (2)Aop:面向切面，不修改源代码进行功能增强\n\n4、Spring 特点\n\n (1)方便解耦，简化开发\n\n (2)Aop 编程支持\n\n (3)方便程序测试\n\n (4)方便和其他框架进行整合\n\n (5)方便进行事务操作\n\n (6)降低 API 开发难度\n\n# IOC\n\n## IOC(概念和原理)\n\n1、什么是 IOC\n\n(1)控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理\n\n(2)使用 IOC 目的：为了耦合度降低\n\n2、IOC 底层原理\n\n(1)xml 解析、工厂模式、反射\n\n## IOC(BeanFactory 接口)\n\n","tags":["spring"],"categories":["spring"]},{"title":"《剑指Java自研框架，决胜Spring源码》study notes","url":"/2021/01/13/《剑指Java自研框架，决胜Spring源码》study-notes/","content":"\n# 概述与环境准备\n\n## 学习说明\n\n- 提升自己的核心竞争力才是关键\n\n> 快读读懂他人的，甚至大神级的框架代码\n>\n> 设计出让自己变得不可替代的技术方案\n>\n> 切入点：读懂spring框架的核心源码，锻炼框架的设计能力\n\n> 通过自研框架模拟spring的设计\n\n- 学习方法\n\n> 使用ide跟着调试\n>\n> 大致理解的基础上继续坚持学习\n\n- 目的\n\n> 了解自研框架的总体架构设计\n>\n> 了解spring的总体架构以及学习路径\n\n- 特点/优点\n\n> 详尽的文档\n>\n> 快速方便的集成项目用到的技术\n\n## Spring简史与介绍\n\n- spring设计初衷\n\n> 可以采用Spring构造任何程序，而不局限于web程序\n>\n> 轻量级：最少的侵入，与应用程序低耦合，接入成本低\n>\n> 最直观的感受：基于POJO，构建出稳健而强大的应用\n\n- 为各大技术领域提供服务支持\n\n## Spring架构介绍\n\n<img src=\"WechatIMG339.jpeg\" width=\"800px\" />\n\n### spring-core\n\n- 包含框架基本的核心工具类，其它组件都要使用到这个包里的类\n- 定义并提供资源的访问方式\n\n### spring-beans：spring主要面向bean编程（BOP）\n\n- bean定义\t（BeanFactory）\n- bean解析\n- bean创建\n\n### spring-context\n\n- 为spring提供运行时环境，保存对象的状态\n- 扩展了BeanFactory （ApplicationContext）\n\n### spring-aop：最小化的动态代理实现\n\n- jdk动态代理\n- Cglib\n- 只能使用运行时织入，仅支持方法级编织，仅支持方法执行切入点\n\n### spring-aspectj + spring-instrument ： Full AspectJ\n\n## Spring源码下载编译\n\n- 环境准备：jdk 11、maven 3.6、idea、Gradle（需要了解使用Gradle）\n- ","tags":["spring","源码分析"],"categories":["spring","源码分析"]},{"title":"docker study notes","url":"/2021/01/10/docker-study-notes/","content":"\n# docker简介\n\n## 为什么会有docker出现\n\n- 一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验\n\n- Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。\n\n- 环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。\n\n- 传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。\n\n## docker历史\n\n2010年，几个的年轻人，就在美国成立了一家公司 `dotcloud`\n\n做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！\n\nLinux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。\n\n他们将自己的技术（容器化技术）命名就是 Docker\n\nDocker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！\n\n2013年，Docker开源！\n\n越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！\n\n2014年4月9日，Docker1.0发布！\n\ndocker为什么这么火？十分的轻巧！\n\n在容器技术出来之前，我们都是使用虚拟机技术！\n\n\n\n## docker理念\n\n- Docker是基于Go语言实现的云开源项目。\n\n- Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。\n\n- Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作\n\n**解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。**\n\n## docker可以做什么\n\n### 之前的虚拟机技术\n\n虚拟机（virtual machine）就是带环境安装的一种解决方案。\n\n它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。\n\n- 虚拟机的缺点：\n\n（1）资源占用多\n\n（2）冗余步骤多\n\n（3）启动慢\n\n虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！\n\n### 容器虚拟化技术\n\n由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。\n\n<font color=red>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</font>\n\n- Docker 和传统虚拟化方式的不同之处\n\n> 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；\n>\n> 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便\n>\n> 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。\n>\n> Docker十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！\n\n### 开发/运维（DevOps）\n\n- 一次构建，随处运行\n\n> 更快速的应用交付和部署\n>\n> 更便捷的升级和扩缩容\n>\n> 更简单的系统运维\n>\n> 更高效的计算资源利用\n\n# docker深入\n\n## docker的基本组成\n\n- images\n\n- container\n\n- repository\n\n> 需要正确的理解仓储/镜像/容器这几个概念:\n>\n>  Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\n>\n> image 文件生成的容器实例，本身也是一个文件，称为镜像文件。\n>\n>  一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器\n>\n> 至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。\n\n## docker安装\n\n- 环境准备：centos7\n\n```shell\n# 确定是centos7及以上版本\ncat /etc/redhat-release\nuname -r\n\n# 需要的话，需要安装gcc相关内容\n\n\n# 更新yum软件包索引\nyum makecache fast\n\n```\n\n- [安装内容参考官网](https://docs.docker.com/engine/install/centos/)\n\n```shell\n# 启动docker\nsystemctl start docker\n\n# 测试是否安装成功\ndocker version\n\ndocker info\n```\n\n- 配置镜像加速\n\n```shell\nmkdir /etc/docker\n\nvi /etc/docker/daemon.json\n\n# 填写加速镜像的内容\n #网易云\n\n{\"registry-mirrors\": [\"http://hub-mirror.c.163.com\"] }\n\n #阿里云\n{\n  \"registry-mirrors\": [\"https://｛自已的编码｝.mirror.aliyuncs.com\"]\n}\n\nsystemctl daemon-reload\n\nsystemctl restart docker\n```\n\n## docker卸载\n\n```shell\n# 具体可以参考官网\nsystemctl stop docker \n\nsudo yum remove docker-ce docker-ce-cli containerd.io\n\nsudo rm -rf /var/lib/docker\n```\n\n## hello-world\n\n```shell\ndocker run hello-world\n```\n\n- run做了什么\n\n<img width=\"800px\" src=\"WechatIMG888.jpeg\" />\n\n## docker底层原理\n\n### docker是怎么工作的\n\nDocker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。\n\n<img width=\"800px\" src=\"WechatIMG889.png\" />\n\n### 为什么docker比VM快\n\nGuestOS： VM（虚拟机）里的的系统（OS） HostOS：物理机里的系统（OS）\n\n（1）docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。\n\n（2）docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟\n\n<img width=\"800px\" src=\"WechatIMG890.png\" />\n\n<img width=\"800px\" src=\"WechatIMG891.png\" />\n\n# docker常用命令\n\n## 帮助命令\n\n```shell\ndocker version\ndocker info\ndocker --help\ndocker [命令] --help\n```\n\n## 镜像命令\n\n（1）docker imgaes（列出本地主机上的镜像）\n\n```shell\n# -a :列出本地所有的镜像（含中间映像层）\n# -q :只显示镜像ID。\n# --digests :显示镜像的摘要信息\n# --no-trunc :显示完整的镜像信息\n\ndocker image -a -q --digests --no-trunc\n```\n\n（2）docker search（查找镜像）\n\n```shell\n# 列出点赞数超过30的tomcat\ndocker search --filter=stars=30 tomcat\n```\n\n（3）docker pull（下载镜像）\n\n```shell\ndocker pull [image_name:TAG]\n```\n\n（4）docker rmi（删除镜像）\n\n```shell\ndocker rmi [image_id | image_name:TAG]\n\n# -f 强制删除，包括正在运行的镜像\ndocker rmi -f [image_id | image_name:TAG]\n\n# 删除多个镜像\ndocker rmi -f 镜像名1:TAG 镜像名2:TAG\n\n# 删除所有镜像\ndocker rmi -f $(docker images -qa)\n\n```\n\n## 容器命令\n\n（1）新建并启动容器\n\n```shell\n# --name=\"容器新名字\": 为容器指定一个名称；\n# -d: 后台运行容器，并返回容器ID，也即启动守护式容器；\n# -i：以交互模式运行容器，通常与 -t 同时使用；\n# -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n# -P: 随机端口映射；\n# -p: 指定端口映射，有以下四种格式\n      # ip:hostPort:containerPort\n      # ip::containerPort\n      # hostPort:containerPort\n      # containerPort\n# -d\t\t\t\t\t#后台方式运行\ndocker run [options] [image_name | image_id] \n\ndocker run -it -p 81:80 nginx\n```\n\n（2）列出当前所有正在运行的容器\n\n```shell\n# -a :列出当前所有正在运行的容器+历史上运行过的\n# -l :显示最近创建的容器。\n# -n：显示最近n个创建的容器。\n# -q :静默模式，只显示容器编号。\n# --no-trunc :不截断输出。\n\ndocker ps [options]\n```\n\n（3）退出容器\n\n```shell\n# 容器退出\nexit\n\n# 容器不停止退出\n# control + p + q\n```\n\n（4）启动容器 / 重启容器\n\n```shell\ndocker start [container_id | container_name]\n\ndocker restart [container_id | container_name]\n```\n\n（5）停止容器 / 强制停止容器\n\n```shell\ndocker stop [container_id | container_name]\n\ndocker kill [container_id | container_name]\n```\n\n（6）删除已停止的容器\n\n```shell\ndocker rm [container_id | container_name]\n\ndocker rm -f $(images ps -aq)\n\ndocker ps -a -q | xargs docker rm\n```\n\n## 其它重要命令\n\n### 启动守护式容器\n\n```shell\ndocker run -d [container_name]\n```\n\n> \\#使用镜像centos:latest以后台模式启动一个容器\n>\n> docker run -d centos\n>\n>  \n>\n> 问题：然后docker ps -a 进行查看, 会发现容器已经退出\n>\n> 很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.\n>\n> 容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。\n>\n>  \n>\n> 这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如\n>\n> service nginx start\n>\n> 但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,\n>\n> 这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.\n>\n> 所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行\n\n### 查看日志\n\n```shell\ndocker run -d centos /bin/sh -c \"while true;do echo hello zzyy;sleep 2;done\"\n\n# -t 加入时间戳 -f 跟随最新的日志打印 --tail number 显示最后的number条日志\ndocker logs -f -t --tail number [container_id]\n```\n\n### 查看容器内运行的进程\n\n```shell\ndocker top [container_id]\n```\n\n### 查看容器内部细节\n\n```shell\ndockerc inspect [container_id]\n```\n\n### 进入正在运行的容器并以命令行交互\n\n```shell\ndocker exec -it [container_id] /bin/bash\n\ndocker attach [container_id]\n```\n\n- 二者的区别\n\n> exec：是在容器中打开新的终端，并且可以启动新的进程；\n>\n> attach：直接进入容器启动命令的终端，不会启动新的进程\n\n### 从容器内拷贝文件到主机上\n\n```shell\ndocker cp  容器ID:容器内路径 目的主机路径\n```\n\n## 常用命令\n\n```shell\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像\n\ncommit    Create a new image from a container changes   # 提交当前容器为新的镜像\n\ncp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    Create a new container                        # 创建一个新的容器，同 run，但不启动容器\n\ndiff      Inspect changes on a container's filesystem   # 查看 docker 容器变化\n\nevents    Get real time events from the server          # 从 docker 服务获取容器实时事件\n\nexec      Run a command in an existing container        # 在已存在的容器上运行命令\n\nexport    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   Show the history of an image                  # 展示一个镜像形成历史\n\nimages    List images                                   # 列出系统当前镜像\n\nimport    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      Display system-wide information               # 显示系统相关信息\n\ninspect   Return low-level information on a container   # 查看容器详细信息\n\nkill      Kill a running container                      # kill 指定 docker 容器\n\nload      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器\n\nlogout    Log out from a Docker registry server          # 从当前 Docker registry 退出\n\nlogs      Fetch the logs of a container                 # 输出当前容器日志信息\n\nport      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口\n\npause     Pause all processes within a container        # 暂停容器\n\nps        List containers                               # 列出容器列表\n\npull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   Restart a running container                   # 重启运行的容器\n\nrm        Remove one or more containers                 # 移除一个或者多个容器\n\nrmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       Run a command in a new container              # 创建一个新的容器并运行一个命令\n\nsave      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]\n\nsearch    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像\n\nstart     Start a stopped containers                    # 启动容器\n\nstop      Stop a running containers                     # 停止容器\n\ntag       Tag an image into a repository                # 给源中镜像打标签\n\ntop       Lookup the running processes of a container   # 查看容器中运行的进程信息\n\nunpause   Unpause a paused container                    # 取消暂停容器\n\nversion   Show the docker version information           # 查看 docker 版本号\n\nwait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\n```\n\n# docker实战之部署nginx、tomcat、elasticsearch\n\n## 部署nginx\n\n```shell\ndocker search nginx\ndocker pull nginx\ndocker run --name mynginx -p 90:80 nginx\ndocker exec -it mynginx /bin/bash\nwhereis nginx\n```\n\n## 部署tomcat\n\n```shell\ndocker run --name mytomcat -p 8090:8080 tomcat\ndocker exec -it mytomcat /bin/bash\nwhereis tomcat\n```\n\n## 部署es\n\n```shell\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch\n```\n\n# Portainer 可视化面板安装\n\n- **portainer**：Docker图形化界面管理工具！提供一个后台面板供我们操作！\n\n```shell\ndocker run -d -p 8080:9000 \\\n--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n```\n\nRancher(CI/CD再用)\n\n# 镜像原理之联合文件系统\n\n## 镜像是什么\n\n镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。\n\n所有应用，直接打包docker镜像，就可以直接跑起来！\n\n## **如何得到镜像**\n\n- 从远程仓库下载\n- 别人拷贝给你\n- 自己制作一个镜像 DockerFile\n\n## Docker镜像加载原理\n\n- UnionFs （联合文件系统）\n\n> UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像\n> 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\n\n- Docker镜像加载原理\n\n> docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\n> boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。\n> rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。\n\n- 平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？\n\n> 对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.\n>\n> 虚拟机是分钟级别，容器是秒级！\n\n## 分层理解\n\n- **思考：为什么Docker镜像要采用这种分层的结构呢？**\n\n> 最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。\n\n## commit镜像\n\n```shell\ndocker commit -m=\"sorozy-centos-mysql\" -a=\"sorozy\" 容器id 目标镜像名:[版本TAG]\n```\n\n# Docker容器数据卷\n\n## 是什么\n\n> 先来看看Docker的理念：\n>\n> 将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的.容器之间希望有可能共享数据 \n>\n> Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，\n>\n> 那么当容器删除后，数据自然也就没有了。\n>\n> **为了能保存数据在docker中我们使用卷。**\n\n- 一句话：有点类似我们Redis里面的rdb和aof文件\n\n## 能干嘛\n\n>  卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性;\n>\n>  卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷\n>\n> 特点：\n>\n> 1：数据卷可在容器之间共享或重用数据\n>\n> 2：卷中的更改可以直接生效\n>\n> 3：数据卷中的更改不会包含在镜像的更新中\n>\n> 4：数据卷的生命周期一直持续到没有容器使用它为止\n\n- 容器的持久化\n\n- 容器间继承+共享数据\n\n## 数据卷 - 容器内添加\n\n### 直接命令添加\n\n```shell\n docker run -it -v /宿主机绝对路径目录:/容器内目录      镜像名\n \n # 查看数据卷是否挂载成功\n docker inspect 容器ID\n \n # 带权限：只读\n  docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名\n```\n\n- 容器停止退出后，主机修改后数据依然同步\n\n### DockerFile添加\n\n```shell\n# （1）根目录下新建mydocker文件夹并进入\n\n# 可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷\nVOLUME[\"/dataVolumeContainer\",\"/dataVolumeContainer2\",\"/dataVolumeContainer3\"]\n\n# file构建\n# volume test\nFROM centos\nVOLUME [\"/dataVolumeContainer1\",\"/dataVolumeContainer2\"]\nCMD echo \"finished,--------success1\"\nCMD /bin/bash\n\n```\n\n- 说明：\n\n  出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。\n\n  由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。\n\n## 踩坑\n\nDocker挂载主机目录Docker访问出现cannot open directory .: Permission denied\n\n解决办法：在挂载目录后多加一个--privileged=true参数即可\n\n\n\n\n\n---\n\n\n\n\n\n\n\n","tags":["docker"],"categories":["docker"]},{"title":"《系统学习Docker 践行DevOps理念》study notes","url":"/2021/01/09/《系统学习Docker-践行DevOps理念》study-notes/","content":"\n# 容器技术和Docker简介\n\n## 传统项目部署\n\n- 部署非常慢\n- 成本高\n- 资源浪费\n- 难于迁移和扩展\n- 可能会被限定硬件厂商\n\n## 虚拟化技术的优点\n\n- 资源池 - 一个物理机的资源被分配到不同的虚拟机里\n- 易扩展 - 直接增加物理机或者虚拟机即可\n- 易上云 - AWS, GCP, 阿里云等\n\n- 但是虚拟化具有一定的局限性: 虚拟机是一个完整的操作系统, 需要分配资源, 当虚拟机数量增多时, 操作系统本身消耗的资源势必增多\n\n## 使用容器解决了什么问题呢?\n\n- 解决了开发和运维的矛盾\n- 在开发和运维之间搭建桥梁, 帮助实现 DevOps\n\n## 容器的定义:\n\n- 对软件和其依赖的标准化打包\n- 应用之间的相互隔离\n- 共享同一个 OS Kernel\n- 可以运行在很多主流 OS 上\n\n## 容器和虚拟机的区别\n\n<img src=\"WechatIMG907.png\" />\n\n> Docker Machine: 自动在虚拟机上安装 Docker 环境的工具\n\n# Docker环境准备\n\n- docker安装：略（参考官网）\n\n## docker machine\n\n### 简介\n\nDocker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。\n\nDocker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker","tags":["docker"],"categories":["docker"]},{"title":"《玩转Java并发工具，精通JUC，成为并发多面手》study notes","url":"/2021/01/06/《玩转Java并发工具，精通JUC，成为并发多面手》study-notes/","content":"\n# 学习备注\n\n> test\n\n\n\n# 并发工具类 - 分类\n\n（1）为了并发安全：互斥同步、非互斥同步、无同步方案\n\n（2）管理线程、提高效率\n\n（3）线程协作\n\n# 线程池 - 治理线程的法宝\n\n## 为什么要使用线程池\n\n- 问题一：反复创建线程（传统创建线程的方式）开销大\n\n- 问题二：过多的线程会占用太多内存\n\n解决思路：\n\n> 用少量的线程，避免内存占用过多\n>\n> 让这部分线程都保持工作，且可以反复执行任务，避免生命周期的损耗\n\n## 线程池的好处\n\n（1）加快响应速度\n\n（2）合理利用CPU和内存\n\n（3）统一管理\n\n## 线程池适用场合\n\n（1）服务器接收到大量请求时，使用线程池技术非常合适，它可以大大减少线程的创建和销毁次数，提高服务器工作效率\n\n（2）实际开发中，如果需要创建5个以上的线程，则可以使用线程池来管理\n\n## 创建和停止线程池\n\n### 线程池构造函数及其参数\n\n- ThreadPoolExecutor提供了四个构造函数\n\n```java\n//五个参数的构造函数\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue)\n\n//六个参数的构造函数-1\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory)\n\n//六个参数的构造函数-2\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          RejectedExecutionHandler handler)\n\n//七个参数的构造函数\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n- 在ThreadPoolExecutor类中有4个构造函数，最终调用的是如下函数：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n```\n\n- 线程池构造函数参数\n\n|    参数名     |           类型           | 含义                                                         |\n| :-----------: | :----------------------: | ------------------------------------------------------------ |\n| corePoolSize  |           int            | 该线程池中核心线程数最大值                                   |\n|  maxPoolSize  |           int            | 该线程池中线程总数最大值                                     |\n| keepAliveTime |           long           | 该线程池中非核心线程闲置超时时长                             |\n|   workQueue   |      BlockingQueue       | 该线程池中的任务队列：维护着等待执行的Runnable对象           |\n| threadFactory |      ThreadFactory       | 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名 |\n|    handler    | RejectedExecutionHandler | 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略 |\n\n- **corePoolSize**\n\n> `corePoolSize`指的是核心线程数：线程池在完成初始化后，默认情况下，线程池中并没有任何线程。线程池会等到有新任务到来时再去创建新线程执行任务\n>\n> 线程池可能会在核心线程数的基础上增加一些线程，但这些新增加的线程数有一些上限，不能超过最大量`maxPoolSize`\n>\n> 线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程\n>\n> 核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉\n\n- **keepAliveTime**\n\n> 如果线程池当前的线程数大于corePoolSize,那么如果多余的线程的空闲时间大于keepAliveTime，它们就会被终止。\n>\n> keepAliveTime参数的使用可以减少线程数过多冗余时的资源消耗。\n>\n> 如果设置allowCoreThreadTimeOut = true，则会作用于核心线程\n\n- **threadFactory**\n\n> 新的线程由ThreadFactory创建，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。\n>\n> 通常情况下直接使用defaultThreadFactory就行。\n\n- **workQueue**\n\n> - **直接交接（SynchronousQueue）**：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现<线程数达到了maximumPoolSize而不能新建线程>的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大\n> - **无界队列（LinkedBlockingQueue）**：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize\n> - **有界队列（ArrayBlockingQueue）**：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误\n> - **DelayQueue：**队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务\n\n### 添加线程规则\n\n（1）如果线程数小于`corePoolSize`，即使其它线程处于空闲状态，也会创建一个新线程来运行新任务\n\n（2）如果线程数大于或等于`corePoolSize`但少于`maxPoolSize`，则将任务放入队列\n\n（3）如果队列已满，并且线程数小于`maxPoolSize`，则创建一个新线程来运行任务\n\n（4）如果队列已满，并且线程数大于或等于`maxPoolSize`，则拒绝该任务\n\n- 是否需要增加线程的判断顺序是\n\n  `corePoolSize` ->`workQueue` -> `maxPoolSize`\n\n### 增减线程的特点\n\n（1）将`corePoolSize`和`maxPoolSize`设置为相同的值，那么就会创建固定大小的线程池。\n\n（2）线程池希望保持更少的线程数，并且只有在负载变得很大时才会增加它。\n\n（3）如果将线程池的`maxPoolSize`参数设置为很大的值，例如Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务。\n\n（4）只有在队列满了的时候才会去创建大于`corePoolSize`的线程，所以如果使用了无界队列（如：LinkedBlockingQueue）就不会创建到超过`corePoolSize`的线程数。\n\n### 线程池应该手动创建还是自动创建\n\n手动创建更好，因为这样可以让我们更加了解线程池的运行规则，避免资源耗尽的风险\n\n### 直接调用JDK封装好的线程池会带来的问题\n\n- newFixedThreadPool\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\nnewFixedThreadPool线程池通过传入相同的corePoolSize和maxPoolSize可以保证线程数量固定，0L的keepAliveTime表示时刻被销毁，workQueue使用的是无界队列。\n\n这样潜在的问题就是当处理任务的速度赶不上任务提交的速度的时候，就可能会让大量任务堆积在workQueue中，从而引发OOM异常。\n\n- 演示newFixedThreadPool内存溢出问题\n\n```java\n/**\n * 演示newFixedThreadPool线程池OOM问题\n */\npublic class FixedThreadPoolOOM {\n\n    private static ExecutorService executorService = Executors.newFixedThreadPool(1);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            executorService.execute(new SubThread());\n        }\n    }\n}\n\nclass SubThread implements Runnable {\n\n    @Override\n    public void run() {\n        try {\n            //延长任务时间\n            Thread.sleep(1000000000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```shell\n# 更改JVM参数\n-Xmx8m -Xmx8m\n```\n\n\n\n\n\n","tags":["java","concurrent"],"categories":["java","concurrent"]},{"title":"Java - Concurrenct","url":"/2021/01/06/Java-Concurrent/","content":"\n# 学习备注\n\n> 方法三 FutureTask 配合 Thread 需要再理解\n\n\n\n# 环境准备与知识预备\n\n- 函数式编程、lambda 有一定了解\n\n- 使用 **Jdk8**；采用了 **slf4j** 打印日志；采用了 **lombok**  简化 java bean 编写\n\n- pom.xml 依赖如下\n\n```xml\n    <properties>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.10</version>\n        </dependency>\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n    </dependencies>\n```\n\n- logback.xml 配置如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration\n        xmlns=\"http://ch.qos.logback/xml/ns/logback\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://ch.qos.logback/xml/ns/logback logback.xsd\">\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>%date{HH:mm:ss} [%t] %logger - %m%n</pattern>\n        </encoder>\n    </appender>\n    <logger name=\"c\" level=\"debug\" additivity=\"false\">\n        <appender-ref ref=\"STDOUT\"/>\n    </logger>\n    <root level=\"ERROR\">\n        <appender-ref ref=\"STDOUT\"/>\n    </root>\n</configuration>\n```\n\n# 进程与线程\n\n## 进程\n\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在 指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的\n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程\n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程(例如记事本、画图、浏览器 等)，也有的程序只能启动一个实例进程(例如网易云音乐、360 安全卫士等)\n\n## 线程\n\n- 一个进程之内可以分为一到多个线程\n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行\n- Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器\n\n## 进程 VS 线程\n\n- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集\n- 进程拥有共享的资源，如内存空间等，供其内部的线程共享\n- 进程间通信较为复杂\n  - 同一台计算机的进程通信称为 IPC(Inter-process communication)\n  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP\n- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量\n- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低\n\n## 并行与并发\n\n- 单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片(windows 下时间片最小约为 15 毫秒)分给不同的程序使用，只是由于 cpu 在线程间(时间片很短)的切换非常快，人类感 觉是 同时运行的 。总结为一句话就是: 微观串行，宏观并行 ，一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent\n\n\n\n- 引用 Rob Pike 的一段描述:\n\n> 并发(concurrent)是同一时间应对(dealing with)多件事情的能力\n>\n> 并行(parallel)是同一时间动手做(doing)多件事情的能力\n\n### 应用之异步调用\n\n- 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程\n- tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程\n- ui 程序中，开线程进行其他操作，避免阻塞 ui 线程\n\n### 应用之提高效率\n\n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n- 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活\n- 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的\n  - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分(参考后文的【阿姆达尔定律】)\n  - 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义\n- IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化\n\n# Java 线程\n\n## 创建和运行线程\n\n### 方法一 直接使用 Thread\n\n```java\n// 构造方法的参数是给线程指定名字，推荐\nThread t1 = new Thread(\"t1\") {\n  @Override\n  public void run() {\n    log.debug(Thread.currentThread().getName());\n  }\n};\nt1.start();\n```\n\n### 方法二 使用 Runnable 配合 Thread\n\n- Thread 代表线程;Runnable 可运行的任务(线程要执行的代码)\n\n```java\n// Java 8 以后可以使用 lambda 精简代码\nThread t1 = new Thread(()->log.debug(\"hello word\"),\"t1\");\nt1.start();\n```\n\n### Thread 与 Runnable 的关系\n\n- 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了\n- 方法一是重写了run方法，方法二是调用了Runnable的run方法\n- 用 Runnable 更容易与线程池等高级 API 配合\n- 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活\n\n### 方法三 FutureTask 配合 Thread\n\n- FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n        // 创建任务对象\n        FutureTask<Integer> task3 = new FutureTask<>(() -> {\n            log.debug(\"hello\");\n            return 100;\n        });\n        // 参数1 是任务对象; 参数2 是线程名字，推荐\n        new Thread(task3, \"t3\").start();\n        // 主线程阻塞，同步等待 task 执行完毕的结果\n        Integer result = null;\n        try {\n            result = task3.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n        log.debug(\"结果是:{}\", result);\n```\n\n## 查看进程\n\n```shell\nps -ef\nps -ef | grep java\ntop\n\njps # 命令查看所有 Java 进程\n\ntop -H -p [pid]\n```\n\n## jconsole 远程监控配置\n\n- 需要以如下方式运行你的 java 类\n\n```shell\n java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 - Dcom.sun.management.jmxremote.authenticate=是否认证 java类\n```\n\n```shell\njava -Djava.rmi.server.hostname=10.2.14.107 -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false - Dcom.sun.management.jmxremote.authenticate=false TestInLinux\n```\n\n# 线程运行原理\n\n## 栈与栈帧\n\n JVM 中由堆、栈、方法区所组成，其中栈内存是给线程用的，每个线程启动后，虚拟 机就会为其分配一块栈内存\n\n- 每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存\n- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法\n\n## 线程上下文切换(Thread Context Switch)\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码\n\n- 线程的 cpu 时间片用完\n\n- 垃圾回收\n\n- 有更高优先级的线程需要运行\n\n- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法\n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器(Program Counter Register)，它的作用是记住下一条 jvm 指令的执行地址，是线程私有的\n\n- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等\n- Context Switch 频繁发生会影响性能\n\n# 常见方法\n\n|      方法名      | static |                           功能说明                           | 注意                                                         |\n| :--------------: | :----: | :----------------------------------------------------------: | :----------------------------------------------------------- |\n|     start()      |        |      启动一个新线 程，在新的线程 运行 run 方法 中的代码      | start 方法只是让线程进入就绪，里面代码不一定立刻 运行(CPU 的时间片还没分给它)。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException |\n|      run()       |        |                   新线程启动后会调用的方法                   | 如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为 |\n|      join()      |        |                      等待线程运行结 束                       |                                                              |\n|   join(long n)   |        |              等待线程运行结 束,最多等待 n 毫秒               |                                                              |\n|     getId()      |        |                     获取线程长整型 的 id                     | id 唯一                                                      |\n|    getName()     |        |                          获取线程名                          |                                                              |\n| setName(String)  |        |                          修改线程名                          |                                                              |\n|  getPriority()   |        |                        获取线程优先级                        |                                                              |\n| setPriority(int) |        |                        修改线程优先级                        | java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率 |\n|    getState()    |        |                         获取线程状态                         | Java 中线程状态是用 6 个 enum 表示，分别为: NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED |\n| isInterrupted()  |        |                        判断是否被打断                        | 不会清除 打断标记                                            |\n|    isAlive()     |        |                 线程是否存活(还没有运行完毕)                 |                                                              |\n|   interrupt()    |        |                           打断线程                           | 如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标记 ;如果打断的正在运行的线程，则会设置 打断标 记 ;park 的线程被打断，也会设置 打断标记 |\n|  interrupted()   | static |                   判断当前线程是 否被打断                    | 会清除 打断标记                                              |\n|                  | static |                                                              |                                                              |\n| currentThread()  |        |                   获取当前正在执 行的线程                    |                                                              |\n|  sleep(long n)   |        | 让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程 |                                                              |\n|     yield()      | static |            提示线程调度器让出当前线程对 CPU的使用            | 主要是为了测试和调试                                         |\n\n## run vs start\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程\n\n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n##  sleep 与 yield\n\n- sleep\n\n（1）调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态(阻塞)\n\n（2）其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException\n\n（3）睡眠结束后的线程未必会立刻得到执行\n\n（4）建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性\n\n- yield\n\n（1）调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程\n\n（2）具体的实现依赖于操作系统的任务调度器\n\n## 线程优先级\n\n线程优先级会提示(hint)调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n----","tags":["java","concurrenct"],"categories":["java","concurrenct"]},{"title":"DataStructure & Algorithm - Queue","url":"/2021/01/05/DataStructure-Algorithm-Queue/","content":"\n### Queue分类\n\n> 形式上：普通队列 循环队列 Deque、 Priority Queue\n>\n> 概念上： 循环队列 阻塞队列 并发队列\n\n# Implement Queue by my dynamic array\n\n"},{"title":"DataStructure & Algorithm - Stack","url":"/2021/01/05/DataStructure-Algorithm-Stack/","content":"\n\n\n# 栈的应用\n\n- 编辑器\n- 程序调用系统栈\n\n\n\n# Implement Stack by my dynamic array\n\n```java\npublic interface Stack<E> {\n    boolean isEmpty();\n    int getSize();\n    void push(E e);\n    E pop();\n    E peek();\n}\n```\n\n```java\n\npublic class Array<E> {\n\n    private E[] data;\n    private int size;\n\n    // 构造函数，传入数组的容量capacity构造Array\n    public Array(int capacity){\n        data = (E[])new Object[capacity];\n        size = 0;\n    }\n\n    // 无参数的构造函数，默认数组的容量capacity=10\n    public Array(){\n        this(10);\n    }\n\n    // 获取数组的容量\n    public int getCapacity(){\n        return data.length;\n    }\n\n    // 获取数组中的元素个数\n    public int getSize(){\n        return size;\n    }\n\n    // 返回数组是否为空\n    public boolean isEmpty(){\n        return size == 0;\n    }\n\n    // 在index索引的位置插入一个新元素e\n    public void add(int index, E e){\n\n        if(index < 0 || index > size)\n            throw new IllegalArgumentException(\"Add failed. Require index >= 0 and index <= size.\");\n\n        if(size == data.length)\n            resize(2 * data.length);\n\n        for(int i = size - 1; i >= index ; i --)\n            data[i + 1] = data[i];\n\n        data[index] = e;\n\n        size ++;\n    }\n\n    // 向所有元素后添加一个新元素\n    public void addLast(E e){\n        add(size, e);\n    }\n\n    // 在所有元素前添加一个新元素\n    public void addFirst(E e){\n        add(0, e);\n    }\n\n    // 获取index索引位置的元素\n    public E get(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Get failed. Index is illegal.\");\n        return data[index];\n    }\n\n    public E getLast(){\n        return get(size-1);\n    }\n\n    public E getFirst(){\n        return get(0);\n    }\n\n    // 修改index索引位置的元素为e\n    public void set(int index, E e){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Set failed. Index is illegal.\");\n        data[index] = e;\n    }\n\n    // 查找数组中是否有元素e\n    public boolean contains(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return true;\n        }\n        return false;\n    }\n\n    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1\n    public int find(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return i;\n        }\n        return -1;\n    }\n\n    // 从数组中删除index位置的元素, 返回删除的元素\n    public E remove(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Remove failed. Index is illegal.\");\n\n        E ret = data[index];\n        for(int i = index + 1 ; i < size ; i ++)\n            data[i - 1] = data[i];\n        size --;\n        data[size] = null; // loitering objects != memory leak\n\n        if(size == data.length / 4 && data.length / 2 != 0)\n            resize(data.length / 2);\n        return ret;\n    }\n\n    // 从数组中删除第一个元素, 返回删除的元素\n    public E removeFirst(){\n        return remove(0);\n    }\n\n    // 从数组中删除最后一个元素, 返回删除的元素\n    public E removeLast(){\n        return remove(size - 1);\n    }\n\n    // 从数组中删除元素e\n    public void removeElement(E e){\n        int index = find(e);\n        if(index != -1)\n            remove(index);\n    }\n\n    @Override\n    public String toString(){\n\n        StringBuilder res = new StringBuilder();\n        res.append(String.format(\"Array: size = %d , capacity = %d\\n\", size, data.length));\n        res.append('[');\n        for(int i = 0 ; i < size ; i ++){\n            res.append(data[i]);\n            if(i != size - 1)\n                res.append(\", \");\n        }\n        res.append(']');\n        return res.toString();\n    }\n\n    // 将数组空间的容量变成newCapacity大小\n    private void resize(int newCapacity){\n\n        E[] newData = (E[])new Object[newCapacity];\n        for(int i = 0 ; i < size ; i ++)\n            newData[i] = data[i];\n        data = newData;\n    }\n}\n```\n\n```java\npublic class ArrayStack<E> implements Stack<E> {\n\n    private Array<E> array;\n\n    public ArrayStack(int capacity) {\n        array = new Array<>(capacity);\n    }\n\n    public ArrayStack() {\n        array = new Array<>();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return array.isEmpty();\n    }\n\n    @Override\n    public int getSize() {\n        return array.getSize();\n    }\n\n    @Override\n    public void push(E e) {\n        array.addLast(e);\n    }\n\n    @Override\n    public E pop() {\n        return array.removeLast();\n    }\n\n    @Override\n    public E peek() {\n        return array.getLast();\n    }\n\n    @Override\n    public String toString() {\n        StringBuffer res = new StringBuffer();\n        res.append(\" Stack : [\");\n        for (int i = 0; i < array.getSize(); i++) {\n            res.append(array.get(i));\n            if (i !=array.getSize()-1 ){\n                res.append(\",\");\n            }\n        }\n        res.append(\"] top\");\n        return res.toString();\n    }\n}\n```\n\n# leetcode\n\n## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        if (s.length() == 0 ) {\n            return false;\n        }\n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(' || c=='[' || c== '{'){\n                stack.push(c);\n            }else {\n                if (stack.isEmpty()){\n                    return false;\n                }\n                char topChar = stack.pop();\n                if (c ==')' && topChar != '('){\n                    return false;\n                }\n                if (c ==']' && topChar != '['){\n                    return false;\n                }\n                if (c =='}' && topChar != '{'){\n                    return false;\n                }\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n\n\n\n\n155,232,844,224,682,496.\n\n","tags":["algorithm","data-structure"],"categories":["algorithm","data-structure"]},{"title":"工作&学习 - 方法","url":"/2020/12/24/工作-学习-方法/","content":"\n# TODO LIST\n\n## 为什么要TODO LIST\n\n（1）记不住 \n\n（2）拎不清\n\n（3）被打断\n\n## TODOLIST 原理就像是CPU时间片 \n\n（1）事件\n\n（2）状态\n\n（3）优先级 \n\n==》 进展 \n\n## 方法\n\n（1）番茄工作法（每工作一段时间就休息一下）\n\n（2）有效的时间管理\n\n（3）养成习惯\n\n## 设置目标\n\n（1）设置小目标，细化目标，每阶段需要做的事情（可有明确收获）","tags":["study"],"categories":["study"]},{"title":"《MySQL数据库集群-PXC方案》study notes","url":"/2020/12/23/《MySQL数据库集群-PXC方案》study-notes/","content":"\n# 学习备注\n\n> 1.\n\n\n\n# 环境搭建\n\n## 环境准备\n\n> centOS 7\n>\n> Jdk7\n\n## 离线安装Percona\n\n```shell\ncd /home\n```\n\n```shell\n# 下载 Percona安装包 然后解压缩\n# https://www.percona.com/downloads/Percona-Server-5.7/LATEST/\nwget https://downloads.percona.com/downloads/Percona-Server-5.7/Percona-Server-5.7.22-22/binary/redhat/7/x86_64/Percona-Server-5.7.22-22-rf62d93c-el7-x86_64-bundle.tar\n\ntar -xvf Percona-Server-5.7.22-22-rf62d93c-el7-x86_64-bundle.tar\n# 删除已经用不到的压缩包\nrm -rf Percona-Server-5.7.22-22-rf62d93c-el7-x86_64-bundle.tar\n\n\n# 此时我们也需要下载 jemalloc\n# https://cbs.centos.org/koji/taskinfo?taskID=709\nwget https://cbs.centos.org/kojifiles/work/tasks/709/709/jemalloc-3.6.0-8.el7.centos.x86_64.rpm\n\n# 进入RPM安装文件目录（/home），执行下面的脚本\nyum localinstall *.rpm\n```\n\n## 管理MySQL服务\n\n```shell\nsystemctl start mysqld\nsystemctl stop mysqld\nsystemctl restart mysqld\n```\n\n## 开放防火墙端口\n\n```shell\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\nfirewall-cmd --reload\n```\n\n## 修改MySQL配置文件\n\n```shell\nvi /etc/my.cnf\n```\n\n```mysql\n[mysqld]\ncharacter_set_server = utf8\nbind-address = 0.0.0.0\n#跳过DNS解析\nskip-name-resolve\n```\n\n```shell\nsystemctl restart mysqld\n```\n\n## 禁止开机启动MySQL\n\n```mysql\nchkconfig mysqld off\n```\n\n## 初始化MySQL数据库\n\n* 查看MySQL初始密码\n\n  ```shell\n  cat /var/log/mysqld.log | grep \"A temporary password\"\n  ```\n\n* 修改MySQL密码\n\n  ```mysql\n  SET PASSWORD FOR root@localhost=PASSWORD('Abc_123456');\n  ```\n\n- MySQL7设置简单密码会报错，经过如下设置后即可设置简单密码\n\n  ```mysql\n  set global validate_password_policy=0;\n  set global validate_password_length=1;\n  \n  SET PASSWORD FOR root@localhost=PASSWORD('111111');\n  ```\n\n* 创建远程管理员账户\n\n  ```sql\n  CREATE USER 'admin'@'%' IDENTIFIED BY '111111';\n  GRANT all privileges ON *.* TO 'admin'@'%';\n  FLUSH PRIVILEGES;\n  ```\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"《扛得住的MySQL数据库架构》study notes","url":"/2020/12/18/《扛得住的MySQL数据库架构》study-notes/","content":"\n# 影响数据库的因素\n\n- sql查询速度\n- 服务器硬件\n- 网卡流量\n- 磁盘IO\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"《ZooKeeper分布式专题与Dubbo微服务入门》study notes","url":"/2020/12/18/《ZooKeeper分布式专题与Dubbo微服务入门》study-notes/","content":"\n# 学习备注\n\n> 1. \n\n\n\n# ZooKeeper简介\n\n- 中间件，提供协调服务\n- 作用于分布式系统，发挥其优势，可以为大数据服务\n- 支持Java，提供Java和C语言的客户端api\n\n## 什么是分布式系统\n\n- 很多台计算机组成一个整体，一个整体一致对外并且处理同一请求\n- 内部的每台计算机都可以相互通信（rest/rpc）\n- 客户端到服务端的一次请求到响应结束会经历很多台计算机\n\n## ZooKeeper特性\n\n- 一致性：数据一致性，数据按照顺序分批入库\n- 原子性：事物要么成功要么失败，不会局部化\n- 单一视图：客户端连接集群中任意一zk节点，数据都是一致的\n- 可靠性：每次对zk的操作状态都会保存在服务端\n- 实时性：客户端可以读取到zk服务端的最新数据\n\n\n\n# 安装/配置/启动\n\n## jdk安装\n\n```shell\n# 上传 jdk-8u271-linux-x64.tar.gz 到 /home\ntar -zxvf jdk-8u271-linux-x64.tar.gz\n\nmv jdk1.8.0_271 jdk8\n\nmv jdk8 /usr\n\nvim /etc/profile\n\n# 添加如下配置\nexport JAVA_HOME=/usr/jdk8\nexport CLASSPATH=.:${JAVA_HOME}/jre/lib/rt.jar:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar\nexport PATH=$PATH:${JAVA_HOME}/bin\n\nsource /etc/profile\n\njava -version\n```\n\n## ZooKeeper安装\n\n```shell\ncd /home\n\nwget http://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz\n\ntar -zxvf zookeeper-3.4.11.tar.gz\n\nmv zookeeper-3.4.11 zookeeper\n\nmv zookeeper /usr/local/\n\nvim /etc/profile\n\n# 添加如下配置\nexport ZOOKEEPER_HOME=/usr/local/zookeeper\nexport PATH=$PATH:$ZOOKEEPER_HOME/bin\n\nsource /etc/profile\n```\n\n## ZooKeeper主要目录结构\n\n- bin：主要的一些运行命令\n- conf：存放配置文件，其中我们需要修改zk.cfg\n- contrib：附加的一些功能\n- dist-maven：mvn编译后的目录\n- dos：文档\n- lib：需要依赖的jar包\n- recipes：案例demo代码\n- src：源码\n\n## zoo.cfg配置\n\n<img width=\"800px\" src=\"1.png\" />\n\n<img width=\"800px\" src=\"2.png\" />\n\n```shell\ncd conf\n\ncp zoo_sample.cfg zoo.cfg\n\nvim zoo.cfg\n```\n\n```shell\n# The number of milliseconds of each tick\ntickTime=2000\n# The number of ticks that the initial\n# synchronization phase can take\ninitLimit=10\n# The number of ticks that can pass between\n# sending a request and getting an acknowledgement\nsyncLimit=5\n# the directory where the snapshot is stored.\n# do not use /tmp for storage, /tmp here is just\n# example sakes.\ndataDir=/usr/local/zookeeper/dataDir\ndataLogDir=/usr/local/zookeeper/dataLogDir\n# the port at which the clients will connect\nclientPort=2181\n# the maximum number of client connections.\n# increase this if you need to handle more clients\n#maxClientCnxns=60\n#\n# Be sure to read the maintenance section of the\n# administrator guide before turning on autopurge.\n#\n# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance\n#\n# The number of snapshots to retain in dataDir\n#autopurge.snapRetainCount=3\n# Purge task interval in hours\n# Set to \"0\" to disable auto purge feature\n#autopurge.purgeInterval=1\n```\n\n```shell\ncd zookeeper\n\nmkdir dataDir dataLogDir\n```\n\n## 启动\n\n```shell\ncd /bin\n\nzkServer.sh start\n\nzkServer.sh restart\n\nzkServer.sh stop\n```\n\n# 基本数据模型\n\n## 数据模型介绍\n\n<img width=\"800px\" src=\"WechatIMG294.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG295.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG296.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG297.png\" /><br>\n\n## 作用体现\n\n<img width=\"800px\" src=\"WechatIMG298.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG299.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG300.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG301.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG302.png\" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["zookeeper","dubbo"],"categories":["zookeeper","dubbo"]},{"title":"DesignPatterns - 工厂模式","url":"/2020/12/17/DesignPatterns-工厂模式/","content":"\n# 简单工厂模式\n\n## 基本介绍\n\n（1）简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式\n\n（2）简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为\n\n（3）在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式\n\n```java\n\n```\n\n# 工厂方法模式\n\n## 基本介绍\n\n（1）工厂方法模式设计方案:将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现\n\n（2）工厂方法模式:定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例 化推迟到子类\n\n","tags":["design-patterns"],"categories":["design-patterns"]},{"title":"DesignPatterns - 建造者模式","url":"/2020/12/17/DesignPatterns-建造者模式/","content":"\n","tags":["design-patterns"],"categories":["design-patterns"]},{"title":"DesignPatterns - 原型模式","url":"/2020/12/16/DesignPatterns-原型模式/","content":"\n# 基本介绍\n\n（1）原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 \n\n（2） 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节 \n\n（3）工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象**.clone**()\n\n# 原型模式原理结构图-uml 类图\n\n<img width=\"800px\" src=\"WechatIMG253.png\" />\n\n（1）Prototype：原型类，声明一个克隆自己的接口 \n\n（2）ConcretePrototype：具体的原型类, 实现一个克隆自己的操作 \n\n（3）Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）\n\n# 克隆羊问题\n\n现在有一只羊tom，姓名为: tom, 年龄为:1，颜色为:白色，请编写程序创建和 tom 羊 属性完全相同的 10只羊\n\n## 传统方式\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        // 传统的方法\n        Sheep sheep = new Sheep(\"tom\", 1, \"白色\");\n        Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n        Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n        Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n        Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); \n      \n        System.out.println(sheep);\n        System.out.println(sheep2);\n        System.out.println(sheep3);\n        System.out.println(sheep4);\n        System.out.println(sheep5);\n    }\n}\n```\n\n- 传统的方式的优缺点\n\n（1）优点是比较好理解，简单易操作\n\n（2）在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低\n\n（3）总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活\n\n- 改进的思路分析\n\n> 思路：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制 一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 => 原型模式 \n\n## 原型模式解决克隆羊问题\n\n```java\npublic class Sheep implements Cloneable {\n\n    private String name;\n    private int age;\n    private String color;\n    private String addr = \"新疆羊\";\n    private Sheep friend;// 是对象, 克隆会如何处理, 默认是浅拷贝\n\n    public Sheep(String name, int age, String color) {\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n//    @Override\n//    public String toString() {\n//        return \"Sheep : [name = \"+name+\",age = \"+age+\",color = \"+color+\"]\";\n//    }\n\n\n    @Override\n    public String toString() {\n        return \"Sheep{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", color='\" + color + '\\'' +\n                \", addr='\" + addr + '\\'' +\n                '}';\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        Sheep sheep =null;\n        try {\n            sheep = (Sheep) super.clone();\n        } catch (CloneNotSupportedException e) {\n            System.out.println(e.getMessage());\n        }\n        return sheep;\n    }\n}\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Sheep sheep1 = new Sheep(\"1\",18,\"red\");\n        try {\n            Sheep sheep2 = (Sheep) sheep1.clone();\n            Sheep sheep3 = (Sheep) sheep1.clone();\n            Sheep sheep4 = (Sheep) sheep1.clone();\n\n            System.out.println(sheep1);\n            System.out.println(sheep2);\n            System.out.println(sheep3);\n            System.out.println(sheep4);\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 原型模式在 Spring 框架中源码分析\n\n- Spring 中原型 bean 的创建，就是原型模式的应用\n\n# 浅拷贝和深拷贝\n\n## 浅拷贝\n\n（1）对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象\n\n（2）对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行 引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成 员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值\n\n（3）浅拷贝是使用默认的 clone()方法来实现 `sheep = (Sheep) super.clone(); `\n\n## 深拷贝\n\n（1）复制对象的所有基本数据类型的成员变量值\n\n（2）为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象**(**包括对象的引用类型**)**进行拷贝\n\n（3）深拷贝实现方式1:重写**clone**方法来实现深拷贝\n\n（4）深拷贝实现方式2:通过对象序列化实现深拷贝(推荐) \n\n```java\npublic class DeepCloneableTarget implements Serializable, Cloneable {\n    \n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String cloneName;\n\n\tprivate String cloneClass;\n\n\tpublic DeepCloneableTarget(String cloneName, String cloneClass) {\n\t\tthis.cloneName = cloneName;\n\t\tthis.cloneClass = cloneClass;\n\t}\n\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\treturn super.clone();\n\t}\n}\n```\n\n```java\npublic class DeepProtoType implements Serializable, Cloneable{\n\tpublic String name; //String 属性\n\tpublic DeepCloneableTarget deepCloneableTarget;// 引用类型\n\tpublic DeepProtoType() {\n\t\tsuper();\n\t}\n\n\t//深拷贝 方式一 通过clone方法\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\t\n\t\tObject deep = null;\n\t\t//这里完成对基本数据类型clone\n\t\tdeep = super.clone(); \n\t\t//对引用数据类型单独处理\n\t\tDeepProtoType deepProtoType = (DeepProtoType)deep;\n\t\tdeepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();\n\t\treturn deepProtoType;\n\t}\n\t\n\t//深拷贝 方式二 通过对象的序列化（推荐）\n\tpublic Object deepClone() {\n\t\t\n\t\t//创建流对象\n\t\tByteArrayOutputStream bos = null;\n\t\tObjectOutputStream oos = null;\n\t\tByteArrayInputStream bis = null;\n\t\tObjectInputStream ois = null;\n\t\ttry {\n\t\t\t//序列化\n\t\t\tbos = new ByteArrayOutputStream();\n\t\t\toos = new ObjectOutputStream(bos);\n\t\t\toos.writeObject(this); //当前这个对象以对象流的方式输出\n\t\t\t\n\t\t\t//反序列化\n\t\t\tbis = new ByteArrayInputStream(bos.toByteArray());\n\t\t\tois = new ObjectInputStream(bis);\n\t\t\tDeepProtoType copyObj = (DeepProtoType)ois.readObject();\n\t\t\treturn copyObj;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tbos.close();\n\t\t\t\toos.close();\n\t\t\t\tbis.close();\n\t\t\t\tois.close();\n\t\t\t} catch (Exception e2) {\n\t\t\t\tSystem.out.println(e2.getMessage());\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n```java\n    public static void main(String[] args) throws Exception {\n        DeepProtoType p = new DeepProtoType();\n        p.name = \"悟空\";\n        p.deepCloneableTarget = new DeepCloneableTarget(\"孙大圣\", \"猴子的类\");\n\n        //method 1 深拷贝\n//\t\tDeepProtoType p2 = (DeepProtoType) p.clone();\n//\t\tSystem.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode());\n//\t\tSystem.out.println(\"p2.name=\" + p.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode());\n\n//        //method 2 深拷贝\n        DeepProtoType p2 = (DeepProtoType) p.deepClone();\n        System.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode());\n        System.out.println(\"p2.name=\" + p.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode());\n    }\n```\n\n# 原型模式的注意事项和细节\n\n（1）创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率 \n\n（2）不用重新初始化对象，而是动态地获得对象运行时的状态\n\n（3）如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码\n\n（4）在实现深克隆的时候可能需要比较复杂的代码\n\n（5）缺点:需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则 ","tags":["design-patterns"],"categories":["design-patterns"]},{"title":"Java实操避坑指南","url":"/2020/12/16/Java实操避坑指南/","content":"\n\n\n# 学习备注\n\n\n\n# Java 空指针和异常\n\n## 出现空指针的情况\n\n（1）调用了空对象的实例方法\n\n```java\nUser user = null;\nuser.sayHello();\n```\n\n（2）访问了空对象的属性\n\n```java\nUser user = null;\nuser.name;\n```\n\n（3）当数组是一个空对象的时候，取它的长度\n\n```java\nUser user = new User();\nSystem.out.print(user.address.length)\n```\n\n（4）null当作Throwble的值\n\n```java\n/* 自定义一个异常 */\npublic static class CustomException extends RuntimeException {}\n\nCustomException c = null;\nthrow null;\n```\n\n（5）方法的返回值是null，调用方法直接去使用\n\n```java\nUser user = new User();\nSystem.out.println(user.getUserName().contains(\"MySQL\"));\n```\n\n## 避免空指针异常的方法\n\n（1）使用之前要初始化;使用前需要校验、判断是否为`null`\n\n（2）尽量避免在函数中返回`null`\n\n\n\n","tags":["java"],"categories":["java"]},{"title":"DesignPatterns - 单例模式","url":"/2020/12/15/DesignPatterns-单例模式/","content":"\n# 学习备注\n\n> 1. \n\n\n\n# 基本概念\n\n- 定义：保证一个类仅有一个实例，并提供一个全局访问点\n- 类型：创建型\n- **适用场景**：想确保任何情况下都绝对只有一个实例\n\n> （1）单服务情况下，网站计数器（集群服务情况下，共享计数器）\n>\n> （2）线程池\n>\n> （3）数据库连接池\n\n- **优点**：\n\n> （1）在内存里只有一个实例，减少了内存开销\n>\n> （2）避免对资源的多重占用\n>\n> （3）设置全局访问点，严格控制访问\n\n- 缺点：没有接口，扩展困难\n- 重点：\n\n> （1）私有构造器\n>\n> （2）线程安全\n>\n> （3）延迟加载\n>\n> （4）序列化和反序列化安全\n>\n> （5）反射（防止反射攻击）\n\n# 单例设计模式的八种方式\n\n单例模式有八种方式:\n\n（1）饿汉式（静态常量）\n\n（2）饿汉式（静态代码块）\n\n（3）懒汉式（线程不安全）\n\n（4）懒汉式（线程安全，同步方法）\n\n（5） 懒汉式（线程安全，同步代码块）\n\n（6）双重检查\n\n（7）静态内部类\n\n（8）枚举\n\n## 饿汉式（静态常量）\n\n```java\n//饿汉式(静态变量)\nclass Singleton {\n    //1. 构造器私有化, 外部能new\n    private Singleton() {}\n\n    //2.本类内部创建对象实例\n    private final static Singleton instance = new Singleton();\n\n    //3. 提供一个公有的静态方法，返回实例对象\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n- 优缺点说明\n\n> 1. 优点:这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题\n> 2. 缺点:在类装载的时候就完成实例化，没有达到LazyLoading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费\n> 3. 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大 多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式(或者其他的静 态方法)导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果\n> 4. 结论:这种单例模式可用，可能造成内存浪费\n\n## 饿汉式(静态代码块)\n\n```java\n//饿汉式(静态代码块) \nclass Singleton {\n    //1. 构造器私有化\n    private Singleton() {}\n\n    //2.本类内部创建对象实例\n    private static Singleton instance;\n\n    static {\n        // 在静态代码块中，创建单例对象\n        instance = new Singleton();\n    }\n\n    //3. 提供一个公有的静态方法，返回实例对象\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n## 懒汉式(线程不安全)\n\n```java\nclass Singleton {\n\n    private static Singleton instance;\n\n    private Singleton() {}\n\n    //提供一个静态的公有方法，当使用到该方法时，才去创建 instance //即懒汉式\n    public static Singleton getInstance() {\n        if(instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n- 优缺点说明\n\n> 1. 起到了**LazyLoading**的效果，但是只能在单线程下使用\n> 2. 如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式\n> 3. 结论:在实际开发中，不要使用这种方式\n\n## 懒汉式(线程安全，同步方法)\n\n```java\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n    private static Singleton instance;\n\n    private Singleton() {}\n\n    //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 //即懒汉式\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n- 优缺点说明\n\n> 1. 解决了线程安全问题\n> 2. 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低\n> 3. 结论:在实际开发中，不推荐使用这种方式\n\n## 懒汉式(线程安全，同步代码块)\n\n```java\n// 懒汉式(线程安全，同步代码块)\nclass Singleton {\n    private static Singleton instance;\n\n    private Singleton() {}\n\n    //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 //即懒汉式\n    public static  Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n## 双重检查\n\n```java\nclass Singleton {\n    \n    private static volatile Singleton instance;\n\n    private Singleton() {}\n\n    //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题 //同时保证了效率, 推荐使用\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n- 优缺点说\n\n> 1. Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这 样就可以保证线程安全了\n> 2. 这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)，直接return实例化对象，也避 免的反复进行方法同步\n> 3. 线程安全;延迟加载;效率较高\n> 4. 结论:在实际开发中，推荐使用这种单例设计模式\n\n## 静态内部类\n\n```java\n// 静态内部类， 推荐使用\nclass Singleton {\n    //private static volatile Singleton instance;\n\n    //构造器私有化\n    private Singleton() {}\n\n    //写一个静态内部类,该类中有一个静态属性 Singleton\n    private static class SingletonInstance {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE\n    public static synchronized Singleton getInstance() {\n        return SingletonInstance.INSTANCE;\n    }\n}\n```\n\n- 优缺点说明\n\n> 这种方式采用了类装载的机制来保证初始化实例时只有一个线程\n>\n> 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化\n>\n> 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的\n>\n> 优点:避免了线程不安全，利用静态内部类特点实现延迟加载，效率高\n>\n> 结论:推荐使用\n\n## 枚举\n\n```java\nenum Singleton {\n    INSTANCE; //属性\n}\n```\n\n- 优缺点说明\n\n> 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建 新的对象\n>\n> 这种方式是**EffectiveJava**作者**JoshBloch**提倡的方式\n>\n> 结论:推荐使用\n\n# 单例模式在 JDK 应用的源码分析\n\n- java.lang.Runtime就是经典的单例模式(饿汉式)\n\n# 单例模式注意事项和细节说明\n\n（1）单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使 用单例模式可以提高系统性能\n\n（2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new\n\n（3）单例模式使用的场景:需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、**session** 工厂等)\n\n","tags":["design-patterns"],"categories":["design-patterns"]},{"title":"《尚硅谷Java设计模式》study notes","url":"/2020/12/12/《尚硅谷Java设计模式》study-notes/","content":"\n# 学习备注\n\n> 1. \n\n\n\n\n\n# 设计模式七大原则\n\n## 单一职责原则\n\n1. 降低类的复杂度，一个类只负责一项职责。\n2. 提高类的可读性，可维护性\n3. 降低变更引起的风险\n4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则;只有类中方法数量足够少，可以在方法级别保持单一职责原则\n\n## 接口隔离原则\n\n## 依赖倒转(倒置)原则\n\n## 里氏替换原则\n\n## 开闭原则\n\n## 迪米特法则\n\n## 合成复用原则","tags":["design-patterns"],"categories":["design-patterns"]},{"title":"DataStructure & Algorithm - Algorithm","url":"/2020/12/03/DataStructure-Algorithm-Algorithm/","content":"\n# LinearSearch\n\n```java\npublic class LinearSearch {\n\n    private LinearSearch(){}\n\n    public static <E> int search (E [] data,E target) {\n        for (int i = 0; i < data.length; i++) {\n            if (data[i].equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n# SelectionSort\n\n```java\npublic class SelectionSort {\n\n    private SelectionSort() {}\n\n    public static <E extends Comparable<E>> void sort(E [] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            // 选择 arr [0..n)中最小值的索引\n            int minIndex = i;\n            for (int j = i; j < arr.length ; j++) {\n                if (arr[j].compareTo(arr[minIndex]) < 0) {\n                    minIndex = j;\n                }\n            }\n            swap(arr,i,minIndex);\n        }\n    }\n\n    private static <E> void swap(E[] arr, int i, int j) {\n        E tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n}\n```\n\n# InsertioSort\n\n```java\npublic class InsertionSort {\n\n    private InsertionSort(){}\n\n    public static <E extends Comparable<E>> void sort (E [] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = i; j-1 >= 0 && arr[j].compareTo(arr[j-1])<0 ;j--) {\n                swap(arr,j,j-1);\n            }\n        }\n    }\n\n    private static <E> void swap(E[] arr, int i, int j) {\n        E tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n","tags":["algorithm"],"categories":["algorithm"]},{"title":"DataStructure & Algorithm - Introduction","url":"/2020/12/02/DataStructure-Algorithm-Introduction/","content":"\n# 数据结构、算法是什么\n\n- 从广义上讲，**数据结构**就是指一组数据的存储结构。**算法**就是操作数据的一组方法\n- 数据结构和算法是相辅相成的。**数据结构是为算法服务的，算法要作用在特定的数据结构之上**\n\n- 数据结构是静态的，它只是组织数据的一种方式\n\n# 为什么要学习数据结构和算法\n\n- 通关大厂面试，别让数据结构和算法拖了后腿\n- 基础框架中，一般都揉和了很多基础数据结构和算法的设计思想，掌握数据结构和算法，利于阅读框架源码，理解其背后的设计思想\n- 基础架构研发工程师，写出达到开源水平的框架才是你的目标（细节：算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等）\n- 编码能力强？性能好坏是其中一个非常重要的评判标准\n- 掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样\n\n> 我们学任何知识都是为了“用”的，是为了解决实际工作问题的\n\n> 我们学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生\n\n# 学习重点\n\n（1）掌握复<font color=red>**杂度分析**</font>\n\n（2）攻克常用的数据结构、算法\n\n> 10 个数据结构：<font color=red>**数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树**</font>\n>\n> 10 个算法：<font color=red>**递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法**</font>\n\n（3）要学习它的<font color=red> **来历、自身的特点、实际的应用场景**</font>\n\n- 数据结构与算法脑图\n\n<img src=\"913e0ababe43a2d57267df5c5f0832a7.jpg\" />\n\n# 学习技巧\n\n（1）**边学边练习，适度刷题（学习内容中涉及的数据结构和算法，全都自己写出来，用代码实现一遍。适度刷题）**\n\n（2）多问、多思考、多互动（找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑）\n\n（3）打怪升级学习法（学习的过程中，我们碰到最大的问题就是，坚持不下来。给自己设立一个切实可行的目标，就像打怪升级一样）\n\n（3）知识需要沉淀，不要想试图一下子掌握所有（学习知识的过程是反复迭代、不断沉淀的过程）\n\n# goals & flag\n\n（1）学习各个数据结构对应的知识（来历、自身特点、实际的应用场景）（常用操作、时间空间复杂度、相关算法题）\n\n（2）对知识点做好笔记写进blog\n\n（3）动手实现相关数据结构。对知识点进行总结\n\n（4）刷一下相关的题目、面试题。（理解其时间空间复杂度）总结经典代码\n\n（5）对算法题分门别类整理\n\n（6）每周学习 2个左右数据结构，以及相关算法题（起步阶段）\n\n","tags":["algorithm","data-structure"],"categories":["algorithm","data-structure"]},{"title":"《MySQL实战45讲》study notes","url":"/2020/11/30/《MySQL实战45讲》study-notes/","content":"\n# MySQL整体架构\n\n<img width=\"800px\" src=\"0d2070e8f84c4801adbfa03bda1f98d9.png\" />\n\n## Server层\n\n- Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等\n\n### 连接器\n\n- 连接器负责跟客户端建立连接、获取权限、维持和管理连接\n\n  ```sql\n  mysql -h$ip -P$port -u$user -p\n  ```\n\n- 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限\n\n- 长连接占用资源和内存比较大，如何解决？\n\n  > 1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。\n  > 2. 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\n\n### 查询缓存\n\n- MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。\n- **但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**\n- 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。\n- MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。\n\n### 分析器\n\n词法分析 -> 语法分析\n\n### 优化器\n\n- 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。\n\n### 执行器\n\n- 开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误\n- \n\n\n\n## 存储引擎层\n\n- 存储引擎层负责数据的存储和提取","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"《阿里新零售数据库设计与实战》 study notes ","url":"/2020/11/27/《阿里新零售数据库设计与实战》-study-notes/","content":"\n# 学习备注\n\n> linux的目录结构需要了解一下\n>\n> linux常用命令\n>\n> 理解常用的mysql引擎\n>\n> 补充的sql需要深入再理解一下\n>\n> 数据库的事物深入了解\n>\n> 数据表的设计后序再好好学习一下\n\n# 前置知识与环境准备\n\n* 常用命令\n\n  ```shell\n  touch\n  vi/vim\n  \n  mkdir\n  \n  clear\n  \n  rm -rf\n  \n  ps aux\n  \n  kill -9 [8088]\n  ```\n\n* 关闭SELinux\n\n  ```shell\n  vi /etc/selinux/config\n  \n  SELINUX=disabled\n  ```\n\n* 配置yum源\n\n  ```shell\n  curl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo\n  ```\n\n  ```shell\n  yum clean all\n  \n  yum makecache\n  ```\n\n# 安装配置MySQL\n\n## yum源安装mysql\n\n* 下载rpm文件\n\n  ```shell\n  yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm\n  ```\n\n* 安装MySQL数据库\n\n  ```shell\n  yum install mysql-community-server -y\n  ```\n\n## 本地安装MySQL数据库\n\n- [官网下载MySQL的tar包](https://downloads.mysql.com/archives/community/) 然后上传到Linux主机的/root/mysql目录\n\n  ```shell\n  scp -r 22 /Users/sorozy/Documents/study/database/阿里新零售数据库设计与实战/document/MySQL本地安装包/mysql-8.0.11-1.el7.x86_64.rpm-bundle.tar root@192.168.0.113:/root/mysql/\n  ```\n\n  \n\n- 执行解压缩\n\n  ```shell\n  tar xvf mysql-8.0.11-1.el7.x86_64.rpm-bundle.tar\n  ```\n\n- 安装依赖的程序包\n\n  ```shell\n  yum install perl -y\n  yum install net-tools -y\n  ```\n\n- 卸载mariadb程序包\n\n  ```shell\n  rpm -qa|grep mariadb\n  rpm -e mariadb-libs-5.5.56-2.el7.x86_64 --nodeps\n  ```\n\n- 安装MySQL程序包\n\n  ```shell\n  rpm -ivh mysql-community-common-8.0.11-1.el7.x86_64.rpm\n  rpm -ivh mysql-community-libs-8.0.11-1.el7.x86_64.rpm\n  rpm -ivh mysql-community-client-8.0.11-1.el7.x86_64.rpm\n  rpm -ivh mysql-community-server-8.0.11-1.el7.x86_64.rpm\n  ```\n\n- 修改MySQL目录权限\n\n  ```shell\n  chmod -R 777 /var/lib/mysql/\n  ```\n\n- 初始化MySQL\n\n  ```shell\n  mysqld --initialize\n  chmod -R 777 /var/lib/mysql/*\n  ```\n\n  \n\n- 启动MySQL\n\n  ```shell\n  # 网络安装使用mysql，本地安装使用mysqld\n  service mysql/mysqld start\n  ```\n\n- 查看初始密码\n\n  ```shell\n  grep 'temporary password' /var/log/mysqld.log\n  ```\n\n- 登陆数据库之后，修改默认密码\n\n  ```mysql\n  alter user user() identified by \"111111\"; \n  ```\n\n- 允许远程使用root帐户\n\n  ```mysql\n  UPDATE user SET host = '%' WHERE user ='root';\n  FLUSH PRIVILEGES;\n  ```\n\n- 允许远程访问MySQL数据库（/etc/my.cnf）\n\n  ```ini\n  character_set_server = utf8\n  bind-address = 0.0.0.0\n  ```\n\n- 开启防火墙3360端口\n\n  ```shell\n  firewall-cmd --zone=public --add-port=3306/tcp --permanent\n  firewall-cmd --reload\n  ```\n\n# ER图\n\n## 业务数据库设计流程\n\n<img width=\"800px\" src=\"WechatIMG225.png\" />\n\n\n\n## E-R图概念\n\n- E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述[现实世界](https://baike.baidu.com/item/现实世界/688877)的[概念模型](https://baike.baidu.com/item/概念模型/3187025)。\n\n- 它是描述现实世界关系概念模型的有效方法。是表示概念关系模型的一种方式。用“矩形框”表示[实体型](https://baike.baidu.com/item/实体型/3187353)，矩形框内写明实体名称；用“椭圆图框”或圆角矩形表示实体的属性，并用“实心线段”将其与相应关系的“实体型”连接起来；\n- 瀑布模型\n- 螺旋模型\n\n# CRUD\n\n```sql\n/* 忽略错误 */\ninsert ignore into \n\n/* 存在就更新，不存在就插入 */\nINSERT INTO table (a,b,c) VALUES (1,2,3)  ON DUPLICATE KEY UPDATE c=c+1; \n\n/**\n\t使用from子查询（使用join），替代where子查询 \n\n\t删除、更新语句使用表连接（join）\n*/\n\n```\n\n# 事物\n\n\n\n# 新零售数据结构设计\n\n\n\n\n\n# 常见问题与企业级解决方案\n\n## 表的主键用数字还是UUID\n\n- UUID是通用唯一识别码的缩写，其目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做信息的指定\n\n```mysql\nselect uuid();\n```\n\n### UUID优点\n\n（1）使用UUID分布式生成主键，降低了全局节点的压力。使得主键生成速度更快\n\n（2）使用UUID生成主键值全局唯一\n\n（3）跨服务器合并数据很方便\n\n### UUID主键的缺点\n\n（1）UUID占用16个字节，比4字节的INT类型和8字节的BIGINT类型更加占用存储空间\n\n（2）UUID是字符串类型，查询速度很慢\n\n（3）UUID不是顺序增长，作为主键，数据写入IO随机性很大\n\n### 主键自动增长的优点\n\n（1）INT和BIGINT占用存储空间很小\n\n（2）MySQL检索数字类型速度远快过字符串\n\n（3）主键值是自动增长的，所以IO写入连续性较好\n\n### 分布式环境下的主键自动增长\n\n（1）在一个项目中不同的模块的数据库里，若使用数据库自带的主键自动增长可能造成主键冲突。解决方案是：**使用数据库中间件（如MyCat）统一生成自动增长的主键（全局唯一）**\n\n（2）**无论什么场合，都不推荐使用UUID作为数据表的主键，而是要利用数据库中间件来生成全局主键**\n\n## 如何在线修改表结构\n\n（1）在业务系统运行的过程中随意删改字段，会造成重大事故\n\n（2）常规的做法是业务停机，维护表结构\n\n（3）但是不影响正常业务的表结构是允许在线修改的\n\n### ALTER TABLE 修改表结构的弊病\n\n（1）由于修改表结构是表级锁，因此在修改表结构时，影响表写入操作\n\n（2）如果修改表结构失败，必须还原表结构，所以耗时更长\n\n（3）大数据表记录多，修改表结构锁表时间很久\n\n### 使用Percona-Toolkit工具\n\n- 安装第三方依赖包\n\n  ```shell\n  yum install  -y perl-DBI\n  yum install  -y perl-DBD-mysql\n  yum install  -y perl-IO-Socket-SSL\n  yum install  -y perl-Digest-MD5\n  yum install  -y perl-TermReadKey\n  ```\n\n- 安装Percona-Toolkit\n\n  ```shell\n  #进入到Percona-Tookit离线文件所在的目录\n  rpm -ivh *.rpm\n  ```\n\n- 允许连接\n\n  ```mysql\n  ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;\n  ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password by '111111';\n  ```\n\n  \n\n- 把客户收货地址表中的name字段改成VARCHAR(20)\n\n  ```shell\n  pt-online-schema-change --host=10.2.14.125 --port=3306 --user=root --password=111111 --alter \"MODIFY name VARCHAR(20) NOT NULL COMMENT '收货人'\" D=neti, t=t_customer_address --print --execute --charset=utf8\n  ```\n\n## 订单号和流水号的关系\n\n* 订单号既是订单的唯一编号，而且经常被用来检索，所以应当是数字类型的主键\n* 流水号是打印在购物单据上的字符串，便于阅读，但是不用做查询\n\n```java\nimport java.util.concurrent.ThreadLocalRandom;\n/**\n\t生产流水号\n*/\npublic class Demo1 {\n\tpublic static String createOrderCode(String type,String organizationId,\n\t\t\tString spgId,String date) {\n\t\tStringBuffer buffer=new StringBuffer();\n\t\tbuffer.append(type);\n\t\tbuffer.append(organizationId);\n\t\tbuffer.append(spgId);\n\t\tbuffer.append(date);\n\t\tThreadLocalRandom.current().ints(0,9).limit(10).forEach((one)->{\n\t\t\tbuffer.append(one);\n\t\t});\n\t\treturn buffer.toString();\n\t}\n\tpublic static void main(String[] args) {\n\t\tString code=createOrderCode(\"S\", \"000012\", \"11002\", \"20180514\");\n\t\tSystem.out.println(code);\n\t}\n}\n```\n\n## 逻辑删除还是物理删除\n\n物理删除就是用DELETE、TRUNCATE、DROP语句删除数据。物理删除是把数据从硬盘中删除，可以释放存储空间，缩小数据表的体积，对性能提升有帮助\n\n（1）由于物理删除是真删除，所以数据恢复起来难度大\n\n（2）物理删除会造成主键的不连续，导致分页查询变慢\n\n```mysql\nSELECT ……  FROM ……  LIMIT 1000, 20;\n```\n\n```mysql\n# 加速查询\nSELECT ……  FROM ……  WHERE  id>=1000  AND  id<= 1020;\n```\n\n（3）核心业务表的数据不建议做物理删除，只做状态变更。比如订单作废、账号禁用、优惠券作废等等。既不删除数据，又能缩小数据表体积，可以把记录转移到历史表。\n\n（4）逻辑删除就是在数据表添加一个字段（is_deleted），用字段值标记该数据已经逻辑删除，查询的时候跳过这些数据\n\n## 千万记录，如何快速分页\n\n（1）利用主键索引来加速分页查询\n\n```mysql\nSELECT * FROM t_test WHERE id>=5000000 LIMIT 100;\nSELECT * FROM t_test WHERE id>=5000000 AND id<=5000000+100;\n```\n\n（2）如果用物理删除，主键不连续，就不能用主键索引来加速分页，所以只能使用折中的方案\n\n```mysql\nSELECT t.id, t.name FROM t_test t JOIN ( SELECT id FROM t_test LIMIT 5000000, 100) tmp ON t.id = tmp.id;\n```\n\n（3）业务上限定不能查询太靠后的数据\n\n## 读多写少和读多写多\n\n### 读多写少的解决方案\n\n可以把MySQL组建集群，并且设置上读写分离\n\n### 写多读少的解决方案\n\n如果是低价值的数据，可以采用NoSQL数据库来存储这些数据\n\n如果是高价值的数据，可以用TokuDB来保存\n\n## 删改数据如何避免锁表\n\n- 什么事锁机制\n\nInnoDb采用的是行级锁，删改数据的时候，MySQL会锁住记录\n\n- 共享锁（S锁）和排它锁（X锁）\n- 排它锁都不允许其它事物执行写操作，但是可以读数据\n\n- 共享锁\n\n  > 添加了共享锁，其它事务只能读取加锁数据，而不能修改和删除\n  >\n  > 只有在serializable事物隔离级别，才会给数据读取添加共享锁\n\n```mysql\nselect ... from .. lock in share mode;\n```\n\n- 排它锁\n\n  > MySQL默认会给删除、添加、修改记录，设置排它锁\n  >\n  > 排它锁不允许对数据再另行加锁\n\n```mysql\nselect ... from ... for update;(添加排它锁)\n```\n\n- 如何减少并发操作的锁冲突\n\n  > 把复杂的sql语句，拆分成简单的sql语句\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"Java - OOP","url":"/2020/11/18/Java-OOP/","content":"\n# java类成员\n\n## 属性（成员变量） vs 局部变量\n\n### 不同点\n\n（1）声明位置\n\n​\t\t成员变量：声明在类的一对{}中\n\n​\t\t局部变量：声明在方法内、方法形参、代码块内、构造器内、构造器形参\n\n（2）权限修饰符\n\n​\t\t成员变量：可以在声明属性时，使用权限修饰符（`private protect default public`）\n\n​\t\t局部变量：不可以使用权限修饰符。（仅可以使用final修饰）\n\n（3）默认初始化值的情况\n\n成员变量：都有默认初始化值\n\n```java\n整型（byte、short、int、long）：0\n浮点型（float、double）：0.0\n字符型（char）：0  （或'\\u0000'）\n布尔型（boolean）：false\n引用数据类型（类、数组、接口）：null\n```\n\n局部变量：**没有默认初始化值。意味着我们在使用局部变量前一定要显示初始化（赋值）**。特别的，形参，我们在调用时赋值即可。\n\n（4）在内存中加载的位置\n\n成员变量：加载到堆空间（非static）\n\n局部变量：加载到栈空间\n\n## 方法\n\n### return\n\n- 终止方法\n- 返回数据\n\n## overload\n\n- `两同一不同`\n\n> 同一个类、相同的方法名。不同的形参列表\n\n- 判断是否重载\n\n> 跟方法的权限修饰、返回值、形参变量名、方法体都没关系\n\n## 可变个数的形参\n\n1. jdk 5.0新增的内容\n\n2. 具体使用：\n\n   > 2.1 可变个数形参的格式：数据类型 ... 变量名<br>\n   >\n   > 2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，...<br>\n   >\n   > 2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载<br>\n   >\n   > 2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。<br>\n   >\n   >  2.5 可变个数形参在方法的形参中，必须声明在末尾<br>\n   >\n   >  2.6  可变个数形参在方法的形参中,最多只能声明一个可变形参<br>\n\n   \n\n","tags":["java","oop"],"categories":["java","oop"]},{"title":"Java - 基础类库","url":"/2020/11/18/Java-基础类库/","content":"\n# Scanner\n\n```java\n  Scanner sc = new Scanner(System.in);\nsc.hasNext();\nsc.next();\nsc.nextLong();\n```\n\n# System\n\n```java\n//标准输入\nSystem.in\nSystem.nanoTime();\n```\n\n# Object\n\n<br>\n\n# String、StringBuffer、StringBuilder\n\n- String类是不可变类\n- StringBuffer是线程安全的。StringBuilder是线程不安全的，但高效\n- `Java9` 改进了字符串（包括 `String、StringBuffer、StringBuilder`）的实现，在`Java9`以前字符串采用`char []` 数组来保存字符，因此字符串的每个字符占2字节；而`Java9`的字符串采用`byte [] `数组再加一个 encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。所以`Java9`的字符串更加节省空间，但字符串的功能方法没有受到任何影响\n\n# Java 7 的ThreadLocalRandom与Random\n\n- ThreadLocalRandom是Java 7 新增的一个类，是Random的增强版，在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程竞争，最终保证系统具有更好的线程安全性\n\n```java\nRandom random = new Random(System.currentTimeMillis());\nThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n```\n\n# BigDecimal\n\n","tags":["java","api"],"categories":["java","api"]},{"title":"Java - Reflection","url":"/2020/11/17/Java-Reflection/","content":"\n# 概述\n\n- Reflection(反射)是被视为动态语言的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法\n- 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个 类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。**这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为:反射**\n\n\n\n# 补充:动态语言 vs 静态语言\n\n## 动态语言\n\n- 是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运 行时代码可以根据某些条件改变自身结构。 \n\n- 主要动态语言:Object-C、C#、JavaScript、PHP、Python、Erlang\n\n## 静态语言\n\n- 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++\n- Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动 态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。 Java的动态性让编程的时候更加灵活\n\n# Java反射机制研究及应用\n\n## Java反射机制提供的功能\n\n> 在运行时判断任意一个对象所属的类\n>\n> 在运行时构造任意一个类的对象\n>\n> 在运行时判断任意一个类所具有的成员变量和方法\n>\n> 在运行时获取泛型信息\n>\n> 在运行时调用任意一个对象的成员变量和方法\n>\n> 在运行时处理注解\n>\n> 生成动态代理\n\n## 反射相关的主要API\n\n```java\njava.lang.Class:代表一个类\n  \njava.lang.reflect.Method:代表类的方法\n  \njava.lang.reflect.Field:代表类的成员变量\n  \njava.lang.reflect.Constructor:代表类的构造器\n```\n\n## 相关问题\n\n1. 通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个？\n\n> 建议：直接new的方式\n>\n> 什么时候使用反射的方式？\n>\n> 编译时候能确定具体的对象类型，则用直接new的方式。编译时不能确定对象类型（运行时才能确定对象类型）则用反射的方式\n\n2. 反射机制与面向对象的封装性是不是矛盾的？如何看待两个技术？\n\n> 不矛盾\n>\n> 面向对象的封装性解决的是一种规范和建议\n>\n> 反射机制解决的是能不能的问题\n\n## java.lang.Class\n\n在Object类中定义了以下的方法，此方法将被所有子类继承\n\n```java\npublic final Class getClass()\n```\n\n以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射 从程序的运行结果来看也很好理解，即: 可以通过对象反射求出类的名称。\n\n\n\n对象照镜子后可以得到的信息:某个类的属性、方法和构造器、某个类到底实现了哪些接 口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含 了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。\n\n> - Class本身也是一个类\n> - Class 对象只能由系统建立对象\n> - 一个加载的类在 JVM 中只会有一个Class实例\n> - 一个Class对象对应的是一个加载到JVM中的一个.class文件\n> - 每个类的实例都会记得自己是由哪个 Class 实例所生成\n> - 通过Class可以完整地得到一个类中的所有被加载的结构\n> - Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象\n\n### Class类的常用方法\n\n|                       方法名                       |                           功能说明                           |\n| :------------------------------------------------: | :----------------------------------------------------------: |\n|          static Class forName(Stringname)          |               返回指定类名 name 的 Class 对象                |\n|                Object newInstance()                |         调用缺省构造函数，返回该Class对象的一个实例          |\n|                     getName()                      | 返回此Class对象所表示的实体(类、接口、数组类、基本类型 或void)名称 |\n|               Class getSuperClass()                |              返回当前Class对象的父类的Class对象              |\n|              Class [] getInterfaces()              |                   获取当前Class对象的接口                    |\n|            ClassLoader getClassLoader()            |                      返回该类的类加载器                      |\n|               Class getSuperclass()                |           返回表示此Class所表示的实体的超类的Class           |\n|          Constructor[] getConstructors()           |            返回一个包含某些Constructor对象的数组             |\n|            Field[] getDeclaredFields()             |                   返回Field对象的一个数组                    |\n| Method getMethod(String name,Class ... paramTypes) |       返回一个Method对象，此对象的形参类型为paramType        |\n\n### 类的加载过程\n\n- 程序经过Javac.exe命令以后，会生成一个或多个字节码文件（.class结尾），接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，就作为Class的一个实例\n- 换句话说，Class的实例就对应着一个运行时类\n- 加载到内存中的运行时类会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类\n\n### 获取Class实例的四种方式\n\n```java\npublic class ReflectionTest {\n\n    @Test\n    public void testgetClass() throws ClassNotFoundException {\n        \n        // 方式一 调用运行时类的属性 .class\n        Class clazz1 = Person.class;\n        Class<Person> clazz1_1 = Person.class;\n        System.out.println(clazz1);\n        System.out.println(clazz1_1);\n\n        // 方式二 通过运行时类的对象获取\n        Person p = new Person();\n        Class clazz2 = p.getClass();\n        System.out.println(clazz2);\n\n        // 方式三 使用Class的静态方法： Class.forName(String classPath)\n        Class clazz3 = Class.forName(\"com.study.Person\");\n        System.out.println(clazz3);\n        \n        // 方式四 使用类的加载器 ClassLoader\n        ClassLoader classLoader = ReflectionTest.class.getClassLoader();\n        Class clazz4 = classLoader.loadClass(\"com.study.Person\");\n        System.out.println(clazz4);\n\n    }\n}\n```\n\n### 哪些类型可以有Class对象\n\n> (1) class: 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类\n>\n> (2) interface:接口\n>\n> (3) []:数组\n>\n> (4) enum:枚举\n>\n> (5) annotation:注解@interface\n>\n> (6) primitive type:基本数据类型\n>\n> (7) void\n\n\n\n- 理解Class类并获取Class的实例\n\n```java\n\nClass c1 = Object.class; \nClass c2 = Comparable.class;\nClass c3 = String[].class; \nClass c4 = int[][].class; \nClass c5 = ElementType.class; \nClass c6 = Override.class; \nClass c7 = int.class;\nClass c8 = void.class;\nClass c9 = Class.class;\n\nint[] a = new int[10];\nint[] b = new int[100];\nClass c10 = a.getClass();\nClass c11 = b.getClass();\n// 只要元素类型与维度一样，就是同一个Class \nSystem.out.println(c10 == c11);// true\n```\n\n# 类的加载与ClassLoader的理解\n\n\n\n## 使用ClassLoader加载配置文件\n\n```java\n   @Test\n    public void testLoadFileByClassLoader() throws IOException {\n\n        Properties properties = new Properties();\n\n//         方式一 此时文件默认在当前的module下\n//        FileInputStream fis = new FileInputStream(\"jdbc.properties\");\n//        properties.load(fis);\n\n        // 方式二 使用ClassLoader，文件路径默认为当前module的 src/main/resources 下\n        ClassLoader classLoader = this.getClass().getClassLoader();\n        InputStream is = classLoader.getResourceAsStream(\"jdbc3.properties\");\n        properties.load(is);\n\n        String user = properties.getProperty(\"name\");\n        String password = properties.getProperty(\"password\");\n        String age = properties.getProperty(\"age\");\n\n        System.out.println(\"user = \"+user+\",password = \"+password+\",age = \"+age);\n\n    }\n```\n\n\n\n# 创建运行时类的对象\n\n```java\n/**\n     * 1)类必须有一个无参数的构造器。\n     * 2)类的构造器的访问权限需要足够。\n     *\n     * 没有空参构造器会抛出 InstantiationException\n     * 权限不够抛出 InstantiationException\n     *\n     * */\n    @Test\n    public void testCreateObjectByReflection () throws InstantiationException, IllegalAccessException {\n        Class<Person> clazz = Person.class;\n        Person person = clazz.newInstance();\n        System.out.println(person);\n    }\n\n// 根据全类名获取对应的Class对象\n//1.根据全类名获取对应的Class对象\n        String name = \"atguigu.java.Person\";\n        Class clazz = null;\n        try {\n            clazz = Class.forName(name);\n            //2.调用指定参数结构的构造器，生成Constructor的实例\n            Constructor con = clazz.getConstructor(String.class,Integer.class);\n            //3.通过Constructor的实例创建对应类的对象，并初始化类属性\n            Person p2 = (Person) con.newInstance(\"Peter\",20);\n            System.out.println(p2);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n```\n\n# 获取运行时类的完 整结构\n\n- 自行查阅相关API\n\n# 调用运行时类的方法\n\n```java\n    @Test\n    public void test() throws Exception {\n        //属性\n        Class clazz = Person.class;\n        Person p = (Person) clazz.newInstance();\n\n        Field name = clazz.getDeclaredField(\"name\");\n        name.setAccessible(true);\n\n        name.set(p,\"章三\");\n//        System.out.println(name.get(p));\n//        System.out.println(p.getName());\n\n        //method\n        Method method = clazz.getDeclaredMethod(\"showName\", String.class);\n        Object res = method.invoke(p,\"海绵宝宝\");\n//        System.out.println(res);\n\n        //constructure\n        Constructor constructor = clazz.getDeclaredConstructor(String.class);\n        Person p2 = (Person) constructor.newInstance(\"小李\");\n        System.out.println(p2);\n    }\n```\n\n","tags":["java","reflection"],"categories":["java","reflection"]},{"title":"java - annotation","url":"/2020/11/17/java-annotation/","content":"\n# 概述\n\n- 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)\n\n- Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加 载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员 可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证 或者进行部署\n- Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中\n\n# 基本注解\n\n```java\n/* 作用：告诉编译器检查这个方法，保证父类包含一个被该方法重写的方法，否则就会编译出错。可以帮助程序员避免一些低级错误*/\n@Override\n/** java9 为@Deprecated增加了两个属性，\n\t\tforRemoveal：该boolean类型的属性指定该api在将来是否会被删除\n\t\tsince：该String类型的属性指定该api从哪个版本标记为过时\n*/\n@Deprecated\n@Deprecated(since=\"7\",forRemoval=true)\n\n@SuppressWarnings\n\n/* java7新增\n\t\t抑制“堆污染”警告\t\n*/\n@SafeVarargs\n\n/* java8新增*/\n@FunctionalInterface\n\n```\n\n","tags":["java","annotation"],"categories":["java","annotation"]},{"title":"java - 泛型","url":"/2020/11/12/java-泛型/","content":"\n# 概念\n\n> 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类 型或者是某个方法的返回值及参数类型。这个类型参数将在使用时(例如， 继承或实现这个接口，用这个类型声明变量、创建对象时)确定(即传入实 际的类型参数，也称为类型实参)。\n\n- JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持， 从而可以在声明集合变量、创建集合对象时传入类型实参\n\n","tags":["java","generic"],"categories":["java","generic"]},{"title":"DataStructure - List","url":"/2020/11/09/DataStructure-List/","content":"\n# LeetCode\n\n## Easy\n\n[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\n\n## Medium\n\n[92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\n\n","tags":["algorithm","data-structure"],"categories":["algorithm","data-structure"]},{"title":"《尚硅谷Netty视频教程》study notes","url":"/2020/11/02/《尚硅谷Netty视频教程》study-notes/","content":"\n# 备注\n\n> 写过的程序多敲几遍\n\n","tags":["netty"],"categories":["netty"]},{"title":"git","url":"/2020/10/30/git/","content":"\n# 将本地项目上传到Github\n\n```git\ncd [project dir]\n\n# 把这个文件夹变成Git可管理的仓库\ngit init \n\ngit add ./\n\ngit commit -m'add'\n\n# 在Github上创建一个Git仓库\n\n# 在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了。注意origin后面加的是你Github上创建好的仓库的地址\ngit remote add origin [your github repo addr]\n\n# 关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上\ngit push -u origin master\n\n# 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了\ngit push origin master\n\n# 有个坑需要注意一下，就是在上面第七步创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了第九步你将本地仓库内容推送到远程仓库的时候就会报一个failed to push some refs to https://github.com/xxx/xxx.git的错\n\n# 这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并\ngit pull --rebase origin master\n```\n\n","tags":["git"],"categories":["git"]},{"title":"Java training camp study notes - jvm","url":"/2020/10/15/Java-training-camp-study-notes-jvm/","content":"\n\n\n# 概述\n\n## 目录\n\n> 1. JVM基础知识:不积跬步，无以至千里\n> 2. Java字节码技术:不积细流，无以成江河 \n> 3. JVM类加载器:山不辞土，故能成其高\n> 4. JVM内存模型:海不辞水，故能成其深\n> 5. JVM启动参数:博观而约取、厚积而薄发\n> 6. 第一节课总结回顾与作业实践\n\n## 编程语言\n\n- 机器语言 -> 汇编语言 -> 高级语言\n\n> 面向过程、面向对象、面向函数\n>\n> 静态类型、动态类型\n\n## 字节码、类加载器、虚拟\n\n\n\n\n\n# Java字节码技术\n\n- Java bytecode 由单字节(byte)的指令组成，理论上最多支持 256 个操作码(opcode)。实 际上Java只使用了200左右的操作码， 还有一些操作码则保留给调试操作\n\n","tags":["java","jvm"],"categories":["java","jvm"]},{"title":"Java training camp study notes","url":"/2020/10/15/Java-training-camp-study-notes/","content":"\n","tags":["java"],"categories":["java"]},{"title":"git study notes","url":"/2020/10/13/git-study-notes/","content":"\n# 配置\n\n```git\n# 显示config的配置，三个作用域\n# 优先级 local > global > system\ngit config --local --list\ngit config --global --list\ngit config --system --list\n```\n\n配置**user.name**和**user.email**\n\n```git\ngit config --global user.name ‘your_name’\ngit config --global user.email ‘your_email@domain.com’\n\n# 清除，--unset\ngit config --unset --local user.name\ngit config --unset --global user.name\n```\n\n","tags":["git"],"categories":["git"]},{"title":"java - 环境准备","url":"/2020/10/12/java-环境准备/","content":"\n# JDK、JRE、JVM的关系\n\n## JDK\n\nJDK(Java Development Kit) 是用于开发 Java 应用程序的软件开发工具集合，包括 了 Java 运行时的环境(JRE)、解释器(Java)、编译器(javac)、Java 归档 (jar)、文档生成器(Javadoc)等工具。简单的说我们要开发Java程序，就需要安 装某个版本的JDK工具包。\n\n## JRE\n\nJRE(Java Runtime Enviroment )提供 Java 应用程序执行时所需的环境，由 Java 虚拟机(JVM)、核心类、支持文件等组成。简单的说，我们要是想在某个机器上运 行Java程序，可以安装JDK，也可以只安装JRE，后者体积比较小。\n\n## JVM\n\nJava Virtual Machine(Java 虚拟机)有三层含义，分别是:\n\n- JVM规范要求\n- 满足 JVM 规范要求的一种具体实现(一种计算机程序)\n-  一个 JVM 运行实例，在命令提示符下编写 Java 命令以运行 Java 类时，都会创建一 个 JVM 实例，我们下面如果只记到JVM则指的是这个含义;如果我们带上了某种JVM 的名称，比如说是Zing JVM，则表示上面第二种含义\n\n# JDK 与 JRE、JVM 之间的关系\n\n就范围来说，JDK > JRE > JVM:\n\n- JDK = JRE + 开发工具\n- JRE = JVM + 类库\n\n<img src=\"14805043-171ef9e473a9f85d.webp\" />\n\n## 三者在开发运行Java程序时的交互关系:\n\n简单的说，就是通过JDK开发的程序，编译以后，可以打包分发给其他装有JRE的机器上去运行。而运行的程序，则是通过java命令启动的一个JVM实例，代码逻辑的执行都运行在这 个JVM实例上\n\n## Java程序的开发运行过程为:\n我们利用 JDK (调用 Java API)开发Java程序，编译成字节码或者打包程序 然后可以用 JRE 启动一个JVM实例，加载、验证、执行 Java 字节码以及依赖库， 运行Java程序而JVM 将程序和依赖库的Java字节码解析并变成本地代码执行，产生结果\n\n# jdk安装、环境配置、管理（mac OS）\n\n## 使用jenv管理jdk版本\n\n（1）oracle官网下载需要的jdk版本（这里使用解压缩版本）\n\n（2）[下载jenv](https://www.jenv.be/)\n\n（2）将jdk添加到jenv管理\n\n```linux\n# jenv add $JAVA_HOME\n\njenv add /Users/sorozy/Documents/dev/conf/jdk/jdk1.8.0_191.jdk/Contents/Home\njenv add /Users/sorozy/Documents/dev/conf/jdk/jdk-11.0.8.jdk/Contents/Home\njenv add /Users/sorozy/Documents/dev/conf/jdk/jdk-14.0.2.jdk/Contents/Home\n```\n\n（3）查看、切换、设置\n\n```linux\n# 查看现有jdk版本\njenv versions\n\n# 切换jdk版本\njenv local 1.8\n\n# 设置全局jdk版本\njenv global jdk11\n```\n\n\n\n","tags":["java"]},{"title":"《全面掌握MongoDB4.0》study notes","url":"/2020/10/04/《全面掌握MongoDB4-0》study-notes/","content":"\n\n\n# 简介\n\n- MongoDB是存储文档的非关系型数据库\n- ","tags":["database","mongodb"],"categories":["database","mongodb"]},{"title":"List/链表","url":"/2020/09/28/List-链表/","content":"\n\n\n- 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的\n\n- This is a test","tags":["data-structure","list"]},{"title":"java - io","url":"/2020/09/24/java-io/","content":"\n# 学习备注\n\n> 有空可以研究一下读写方法的内部\n>\n> file部分的作业记得一定完成一下\n>\n> p602 600这块关于字符集的内容可以认真看一下\n>\n> p603的题目记得写一下\n\n\n\n# File类使用\n\n## 简介\n\n- java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关\n- File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。 如果需要访问文件内容本身，则需要使用输入/输出流。\n- 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。\n- File对象可以作为参数传递给流的构造器\n\n## construtor\n\n```java\n// 以pathname为路径创建File对象，可以是绝对路径或者相对路径\npublic File(String pathname)\n  \n// 以parent为父路径，child为子路径创建File对象。\npublic File(String parent,String child)\n  \n// 根据一个父File对象和子文件路径创建File对象\npublic File(File parent,String child)\n```\n\n## 路径分隔符\n\n- 路径中的每级目录之间用一个路径分隔符隔开\n\n-  路径分隔符和系统有关:\n\n  - windows和DOS系统默认使用“\\”来表示\n\n  - UNIX和URL使用“/”来表示\n\n- 根据操作系统，动态的提供分隔符\n\n```java\npublic static final String separator\n\n// 举例\nFile file = new File(\"d:\" + File.separator + \"test\" + File.separator + \"info.txt\");\n```\n\n## 常用方法\n\n### get\n\n```java\npublic String getAbsolutePath()\t//获取绝对路径\n  \npublic String getPath() //获取路径\n\npublic String getName() //获取名称\n  \npublic String getParent() //获取上层文件目录路径。若无，返回null\n  \npublic long length() //获取文件长度(即:字节数)。不能获取目录的长度。\n  \npublic long lastModified() //获取最后一次的修改时间，毫秒值\n  \npublic String[] list() //获取指定目录下的所有文件或者文件目录的名称数组\n  \npublic File[] listFiles() //获取指定目录下的所有文件或者文件目录的File数组\n```\n\n### rename\n\n```java\npublic boolean renameTo(File dest) //把文件重命名为指定的文件路径\n// 比如 file1.renameTo(file2); 想要保证返回true，则需要保证file1在硬盘中是存在的，file2在硬盘中是不存在的\n```\n\n### judgment\n\n```java\npublic boolean isDirectory() // 判断是否是文件目录\n  \npublic boolean isFile() //判断是否是文件\n  \npublic boolean exists() //判断是否存在\n  \npublic boolean canRead() //判断是否可读\n  \npublic boolean canWrite() //判断是否可写\n  \npublic boolean isHidden() //判断是否隐藏\n```\n\n### create\n\n```java\npublic boolean createNewFile() //创建文件。若文件存在，则不创建，返回false\n  \npublic boolean mkdir() //创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。\n  \npublic boolean mkdirs() //创建文件目录。如果上层文件目录不存在，一并创建\n\n//注意事项:如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目 路径下。\n```\n\n### delete\n\n```java\npublic boolean delete() //删除文件或者文件夹\n\n// 删除注意事项:\n// Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录\n```\n\n# IO流原理及流的分类\n\n## java io原理\n\n- I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于 处理设备之间的数据传输。如读/写文件，网络通讯等\n- Java程序中，对于数据的输入/输出操作以“流**(stream)**” 的 方式进行。\n- java.io包下提供了各种“流”类和接口，用以获取不同种类的 数据，并通过标准的方法输入或输出数据。\n\n\n\n- 输入**input**:读取外部数据(磁 盘、光盘等存储设备的数据)到 程序(内存)中。\n- 输出**output**:将程序(内存) 数据输出到磁盘、光盘等存储设 备中。\n\n\n\n## 流的分类\n\n- 按操作数据单位不同分为：字节流**(8 bit)**，字符流**(16 bit)**\n- 按数据流的流向不同分为：输入流，输出流\n- 按流的角色的不同分为：节点流，处理流\n\n| (抽象基类) |    字节流    | 字符流 |\n| :--------: | :----------: | :----: |\n|   输入流   | InputStream  | Reader |\n|   输出流   | OutputStream | Writer |\n\n## io流体系\n\n<img src=\"WechatIMG698.png\" />\n\n## 节点流和处理流\n\n- 节点流:直接从数据源或目的地读写数据\n- 处理流:不直接连接到数据源或目的地，而是“连接”在已存 在的流(节点流或处理流)之上，通过对数据的处理为程序提 供更为强大的读写功能。\n\n## InputStream & Reader\n\n- InputStream 和 Reader 是所有输入流的基类\n- 程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资 源，所以应该显式关闭文件 **IO** 资源。\n- FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader\n\n```java\n//从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因 为已经到达流末尾而没有可用的字节，则返回值 -1。\nint read()\n\n//从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已 经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取 的字节数。\nint read(byte[] b)\n\n//将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于 文件末尾而没有可用的字节，则返回值 -1。  \nint read(byte[] b, int off,int len)\n\n// 关闭此输入流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n```java\n// 读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)(2个 字节的Unicode码)，如果已到达流的末尾，则返回 -1\nint read()\n\n// 将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。\nint read(char[] cbuf)\n\n// 将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字 符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。\nint read(char[] cbuf,int off,int len) \n  \n// 关闭此输入流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n## OutputStream & Writer\n\n- 因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组， 即以 String 对象作为参数\n- **void write(String str);**\n- **void write(String str, int off, int len);**\n- FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter\n\n```java\n// 将指定的字节写入此输出流。write 的常规协定是:向输出流写入一个字节。要写 入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。\nvoid write(int b)\n\n// 将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是:应该 与调用 write(b, 0, b.length) 的效果完全相同。\nvoid write(byte[] b)\n\n// 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。\nvoid write(byte[] b,int off,int len)\n\n// 刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。\npublic void flush()throws IOException\n  \n// 关闭此输出流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n```java\n//写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即 写入0 到 65535 之间的Unicode码。\nvoid write(int c)\n\n//写入字符数组。\nvoid write(char[] cbuf)\n\n// 写入字符数组的某一部分。从off开始，写入len个字符\nvoid write(char[] cbuf,int off,int len) \n\n// 写入字符串。\nvoid write(String str)\n\n// 写入字符串的某一部分。\nvoid write(String str,int off,int len)\n\n// 刷新该流的缓冲，则立即将它们写入预期目标。\nvoid flush()\n\n// 关闭此输出流并释放与该流关联的所有系统资源。\npublic void close() throws IOException \n```\n\n## 节点流\n\n### 节点流**(**文件流**)**:注意点\n\n> 定义文件路径时，注意:可以用“/”或者“\\\\”。\n>\n> 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文 件将被覆盖。\n>\n> 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖， 在文件内容末尾追加内容。\n>\n> 在读取文件时，必须保证该文件已存在，否则报异常。\n>\n> 字节流操作字节，比如:.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt\n>\n> 字符流操作字符，只能操作普通文本文件。最常见的文本文 件:.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文本文件。\n\n### 字符流\n\n- 使用字符流复制（拷贝）文本文件\n\n```java\n    public static void copyFile (File srcFile, File destFile) {\n      \t// 1.创建流对象，将（已存在的）文件加载进流。\n        FileReader fileReader = null;\n        FileWriter fileWriter = null;\n        try {\n            fileReader = new FileReader(srcFile);\n            fileWriter = new FileWriter(destFile);\n          \n\t\t\t\t// 2.创建临时存放数据的数组。\n            char [] cbuf = new char[5];\n            int len = 0;\n          \n        // 3.调用流对象的读取方法将流中的数据读入到数组中（写入到文件中）。\n            while ((len = fileReader.read(cbuf)) != -1) {\n                fileWriter.write(cbuf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n        // 4.关闭流资源\n            if (fileReader != null){\n                try {\n                    fileReader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (fileWriter != null) {\n                try {\n                    fileWriter.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n### 字节流\n\n- 使用字节流复制（拷贝）二进制文件\n\n```java\n    public static void copy2File (File srcFile, File destFile){\n      // 1.创建流对象，将（已存在的）文件加载进流。\n        FileInputStream fileInputStream = null;\n        FileOutputStream fileOutputStream = null;\n        try {\n            fileInputStream = new FileInputStream(srcFile);\n            fileOutputStream = new FileOutputStream(destFile);\n\t\t\t// 2.创建临时存放数据的数组。\n            byte [] buf = new byte[5];\n            int len;\n      // 3.调用流对象的读取方法将流中的数据读入到数组中（写入到文件中）。\n            while ((len = fileInputStream.read(buf)) != -1){\n                fileOutputStream.write(buf,0,len);\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n\t\t\t// 4.关闭流资源\n            if (fileInputStream != null) {\n                try {\n                    fileInputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (null != fileOutputStream ) {\n                try {\n                    fileOutputStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n## 处理流\n\n### 缓冲流\n\n- 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区\n- 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区\n- 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从 文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中 读取下一个8192个字节数组。\n- 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法 flush()可以强制将缓冲区的内容全部写入输出流\n- 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也 会相应关闭内层节点\n- flush()方法的使用:手动将buffer中内容写入文件\n- 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷 新缓冲区，关闭后不能再写出\n\n\n\n- 使用缓冲流（字节型）复制文件\n\n```java\npublic static void copyFileByBufferedInputStream(File srcFile,File destFile) {\n        // 1、创建缓冲流（字节型）\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(srcFile));\n            bos = new BufferedOutputStream(new FileOutputStream(destFile));\n        // 2、创建零时数组 存放缓冲数据\n            byte [] buffered = new byte[1024];\n            int len = 0;\n            while ((len = bis.read(buffered)) != -1){\n                bos.write(buffered,0,len);\n            }\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n\n        // 3、关闭资源（先关闭外层，再关闭内层）关闭外层流的时候，内层流也会自动关闭，我们可以省略\n            if(bis!=null) {\n                try {\n                    bis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (bos != null) {\n                try {\n                    bos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n### 转换流\n\n- 转换流提供了在字节流和字符流之间的转换\n\n- Java API提供了两个转换流\n\n  > InputStreamReader:将InputStream转换为Reader\n  >\n  > OutputStreamWriter:将Writer转换为OutputStream\n\n- 字节流中的数据都是字符时，转成字符流操作更高效\n- 很多时候我们使用转换流来处理文件乱码问题。实现编码和 解码的功能\n\n#### InputStreamReader\n\n```java\n// 实现将字节的输入流按指定字符集转换为字符的输入流\n// 需要和InputStream“套接”\n\npublic InputStreamReader(InputStream in)\n  \npublic InputSreamReader(InputStream in,String charsetName)\n```\n\n#### OutputStreamWriter\n\n```java\n// 实现将字符的输出流按指定字符集转换为字节的输出流\n// 需要和OutputStream“套接”\n\npublic OutputStreamWriter(OutputStream out)\n  \npublic OutputSreamWriter(OutputStream out,String charsetName)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---","tags":["java","io"],"categories":["java","io"]},{"title":"《编程必备基础－大话HTTP协议》study notes","url":"/2020/09/22/《编程必备基础－大话HTTP协议》study-notes/","content":"\n# 学习备注\n\n>  ssession 和 cookie 的底层工作原理需要深入理解一下\n\n# 前言\n\n> 1. 学习了慕课网的《编程必备基础－大话HTTP协议》课程，本篇文章是学习笔记。以便温习\n\n# HTTP基础\n\n## http协议简介\n\n- **超文本传输协议**（英语：**H**yper**T**ext **T**ransfer **P**rotocol，缩写：**HTTP**）\n- 一种用于分布式、协作式和超媒体信息系统的应用层协议，（属于应用层面向对象的协议）\n- 设计HTTP最初的目的是为了提供一种发布和接收[HTML](https://zh.wikipedia.org/wiki/HTML)页面的方法。通过HTTP或者[HTTPS](https://zh.wikipedia.org/wiki/HTTPS)协议请求的资源由[统一资源标识符](https://zh.wikipedia.org/wiki/统一资源标志符)（Uniform Resource Identifiers，URI）来标识。\n\n\n\n- web\n\n> web是一种基于超文本和http的全球性的、动态交互的、跨平台的分布式图形信息系统\n\n## http协议历史版本\n\n- 版本\n\n> 超文本传输协议已经演化出了很多版本，它们中的大部分都是[向下兼容](https://zh.wikipedia.org/wiki/向下兼容)的。在 [RFC 2145](https://tools.ietf.org/html/rfc2145) 中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。\n\n- HTTP/0.9（1991年）\n\n> 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。\n\n- HTTP/1.0（1996年5月）\n\n>  这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在[代理服务器](https://zh.wikipedia.org/wiki/代理服务器)中\n\n- HTTP/1.1（1997年1月）\n\n> 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以[管道方式](https://zh.wikipedia.org/wiki/HTTP管线化)在同时发送多个请求，以便降低线路负载，提高传输速度。\n>\n> HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：\n>\n> - 缓存处理\n> - 带宽优化及网络连接的使用\n> - 错误通知的管理\n> - 消息在网络中的发送\n> - 互联网地址的维护\n> - 安全性及完整性\n\n- HTTP/2（2015年5月）\n\n> 于2015年5月作为互联网标准正式发布。\n\n- HTTP 3.0 / QUIC协议\n\n## TCP/IP\n\n- HTTP协议是构建在TCP/IP协议之上的，是TCP/IP协议的一个子集\n\n- TCP/IP协议族\n\n> tcp/ip协议其实是一系列与互联网相关联的协议集合起来的总称\n>\n> 分层管理是tcp/ip协议的重要特征\n\n### tcp/ip协议族分层\n\n| 分层       | 说明                                                         | 举例                           |\n| ---------- | ------------------------------------------------------------ | ------------------------------ |\n| 应用层     | 应用层一般是我们编写的应用程序，决定了向用户提供的用户服务，应用层可以通过系统调用与传输层进行通信 | ftp、dns、http                 |\n| 传输层     | 传输层通过系统调用向应用层提供处于网络连接中的两台计算机的数据传输功能 | tcp（面向连接）、udp（无连接） |\n| 网络互联层 | 网络层用来处理网络上流动的数据包，数据包是网络上数据传输的最小数据单位，该层规定了通过怎样的路径（传输线路）到达对方计算机，并把数据包传输给对方 |                                |\n| 数据链路层 | 链路层用来处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动NIC以及光纤等物理可以见部分，硬件上的范畴均在链路层的作用范围之内 |                                |\n\n### 数据包的封装过程\n\n<img src=\"tcpip.datagram.png\" width=\"80%\" />\n\n## HTTP数据传输过程\n\n- 使用tcp协议进行通信的双方必须先建立连接，然后才能开始传输数据，为了确保连接双方可靠性，在建立连接时，tcp协议采用了三次握手策略。\n\n<img src=\"WechatIMG660.png\" width=\"80%\" /><br>\n\n<img src=\"WechatIMG661.png\" width=\"80%\" />\n\n## 传输层 TCP三次握手\n\n<img src=\"daMoW6HkaxYhGW6o.png__original\" width=\"80%\" />\n\n- 第一次握手\n\n> 客户端发送SYN标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。 \n>\n> 服务端接收到信息后，此时，**服务端知道**：*客户端可以成功发送数据，服务端可以接受数据*\n\n- 第二次握手\n\n> 服务端接收到客户端的SYN报文段后，需要发送ACK信息对这个SYN报文段进行确认，同时还要发送自己的SYN请求信息。服务端会将上述的信息放到一个报文段（SYN+ACk报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECEIVED状态 \n>\n> 客户端接收到信息后，此时，**客户端知道**：*自己可以发送数据，可以接收数据，服务端可以接收数据，服务端可以发送数据*\n\n- 第三次握手\n\n> 客户端接收到服务端的SYN+ACK报文段后，会向服务端发送ACK确认报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED状态，完成tcp三次握手\n>\n> 服务端接收到信息后，服务端知道自己可以成功发送数据，客户端可以接收数据\n\n- 三次握手的意义\n\n> 服务端和客户端都确认彼此都能成功发送和接收数据\n\n## DNS\n\n- dns服务提供 域名到ip地址之间的解析服务\n- cdn负责转发（可以设置是否转发）\n- dns服务\n\n> 系统配置文件\n>\n> 本地dns服务\n>\n> 高级dns服务\n>\n> 根dns服务\n\n# HTTP协议结构和通讯原理\n\n## http协议特点\n\n- 支持客户/服务器模式\n\n> 由客户端向服务器发出请求，服务器端响应请求，并进行相应服务\n\n- 简单快速\n\n> 客户向服务器请求服务时，只需传送请求方法和路径\n>\n> http协议简单，使得http服务器的程序规模小，通信速度快\n\n- 灵活\n\n> http允许传输任意类型的对象\n>\n> 正在传输的数据类型由Content-Type标记\n\n- 无连接\n\n> 无连接的含义是：限制每次连接只处理一个请求\n>\n> 服务器处理完客户端的请求，并收到客户端的应答后即断开连接\n>\n> 采用这种方式可以节省传输时间\n\n- 无状态\n\n> http协议是无状态协议\n>\n> 无状态是指协议对事物处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则必须重传，这样可能导致每次每次连接传送的数据量增大\n>\n> 在服务区不需要先前的信息时，它应答就快\n\n## URI & URL & URN\n\n### URI\n\n> **统一资源标识符**（英语：**U**niform **R**esource **I**dentifier，缩写：**URI**）在[电脑](https://zh.wikipedia.org/wiki/電腦)术语中是一个用于[标识](https://zh.wikipedia.org/wiki/标识)某一[互联网](https://zh.wikipedia.org/wiki/互联网)[资源](https://zh.wikipedia.org/wiki/资源)名称的[字符串](https://zh.wikipedia.org/wiki/字符串)\n>\n> a URI 可以进一步分为定位符、名字或者两者都是\n>\n> URI可以分为URl 和 URN，或者同时具备locators和names特性的一个东西\n\n### URL\n\n> Uniform Resource Locator（URL）是URI的子集，除了确定一个资源，还提供一种该资源的主要访问机制（如网络“位置”）\n\n### URN\n\n> URN是唯一标识的一部分，是身份信息\n\n<br>\n\n> URL是URI的一种\n>\n> URI和URL最大的差别是访问机制\n>\n> URN的作用就好像一个人的名字，URL就好像一个人的地址\n>\n> URN确定了东西的身份，URL提供了找到它的方式\n\n## HTTP报文结构\n\n<img src=\"oBhtzgH1zfetmRvb__original.png\" width=\"80%\" />\n\n<img src=\"image.png__original\" width=\"80%\" />\n\n<img src=\"6fkx0BHVtqGmBT9K.png__original\" width=\"80%\" />\n\n### HTTP报文头\n\n- 在HTTP1.1里一共规范了47种报文头字段\n\n#### 通用报文头\n\n<img src=\"WechatIMG662.png\" width=\"80%\" />\n\n#### 请求报文头\n\n<img src=\"WechatIMG663.png\" width=\"80%\" />\n\n#### 响应报文头\n\n<img src=\"WechatIMG664.png\" width=\"80%\" />\n\n#### 实体报文头\n\n<img src=\"WechatIMG665.png\" width=\"80%\" />\n\n#### 常用报文头解析\n\n- Accept\n\n| 作用   | 浏览器可以接收的媒体类型                                     |\n| ------ | ------------------------------------------------------------ |\n| 举例   | Accept: text/html （代表浏览器可以接受的返回类型为text/html，也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务区应该返回一个406错误（Non Acceptable）） |\n|        | Accept: \\*/\\* （代表浏览器可以处理所有类型）                 |\n| 优先级 | 如果想要给显示的媒体类型增加优先级，则使用q= 来额外表示权重值；q的范围是0～1，（可精确到小数点后3位）。且1为最大值。不指定权重q值时，默认权重q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型 |\n\n- Accept-Encoding\n\n| 作用 | 浏览器申明自己的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） |\n| ---- | ------------------------------------------------------------ |\n| 举例 | Accept-Encoding: gzip,deflate;                               |\n\n- Accept-Language\n\n| 作用 | 浏览器申明自己接收的语言                       |\n| ---- | ---------------------------------------------- |\n| 举例 | Accept-Language: zh-cn,zh,q=0.7,en-us,en,q=0.3 |\n\n- Connection\n\nConnection: kite-alive;（当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接）\n\nConnection: close;\n\n- Host\n\n作用：请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来\n\n- Referer\n\n当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的。服务器藉此可以获得一些信息用于处理\n\n- User-Agent\n\n作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本\n\n- Content-Type\n\n作用：说明了报文体内对象的媒体类型\n\n常见的媒体格式类型如下：\n\n- text/html ： HTML格式\n- text/plain ：纯文本格式\n- text/xml ： XML格式\n- image/gif ：gif图片格式\n- image/jpeg ：jpg图片格式\n- image/png：png图片格式\n\n以application开头的媒体格式类型：\n\n- application/xhtml+xml ：XHTML格式\n- application/xml： XML数据格式\n- application/atom+xml ：Atom XML聚合格式\n- application/json： JSON数据格式\n- application/pdf：pdf格式\n- application/msword ： Word文档格式\n- application/octet-stream ： 二进制流数据（如常见的文件下载）\n- application/x-www-form-urlencoded ： \\<form encType=\"\">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）\n\n另外一种常见的媒体格式是上传文件之时使用的：\n\n- multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式\n\n## HTTP请求方法\n\n### HTTP状态码分类\n\n| 分类 | 分类描述                                       |\n| :--- | :--------------------------------------------- |\n| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |\n| 2**  | 成功，操作被成功接收并处理                     |\n| 3**  | 重定向，需要进一步的操作以完成请求             |\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\n\n### HTTP状态码列表\n\n| 状态码 | 状态码英文名称                  | 中文描述                                                     |\n| ------ | ------------------------------- | ------------------------------------------------------------ |\n| 100    | Continue                        | 继续。客户端应继续其请求                                     |\n| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |\n|        |                                 |                                                              |\n| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |\n| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |\n| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |\n| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |\n| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |\n| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |\n| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |\n|        |                                 |                                                              |\n| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |\n| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |\n| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |\n| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |\n| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |\n| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |\n|        |                                 |                                                              |\n| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |\n| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |\n| 402    | Payment Required                | 保留，将来使用                                               |\n| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |\n| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 |\n| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |\n| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |\n| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |\n| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |\n| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |\n| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |\n| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |\n| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |\n| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |\n| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |\n| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |\n| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |\n| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |\n|        |                                 |                                                              |\n| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |\n| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |\n| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |\n| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |\n| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |\n| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |\n\n## Cookie & Session\n\n\n\n# 深入认识HTTP协议不为人知的特性和使用\n\n\n\n---","tags":["http","network"],"categories":["http","network"]},{"title":"《新版Nginx体系化深度精讲》study notes","url":"/2020/09/16/《新版Nginx体系化深度精讲》study-notes/","content":"\n# 学习备注\n\n> 总结出自己的思维脑图\n\n# 前言\n\n> 1. 学习了慕课网的《新版Nginx体系化深度精讲，从青铜到王者的飞跃》课程，本篇文章是学习笔记。以便温习\n\n# 初识Nginx\n\n## 学习Nginx的三个理由\n\n> 1. 应用广泛，大厂和小厂必用的WEB组件\n> 2. 前后端、运维必知必会技能之一\n> 3. 性能优化，进阶高级工程师\n\n## 学习后收获\n\n> 部署前端项目，反向代理nodejs\n>\n> 反向代理java、python等，负载均衡\n>\n> 协调前后端，故障排查，性能优化\n\n## Nginx概念\n\n​\t\tNginx* (engine x) 是一个高性能的[HTTP](https://baike.baidu.com/item/HTTP)和[反向代理](https://baike.baidu.com/item/反向代理/7793488)web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为[俄罗斯](https://baike.baidu.com/item/俄罗斯/125568)访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n\n​\t\t其将[源代码](https://baike.baidu.com/item/源代码)以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而[闻名](https://baike.baidu.com/item/闻名/2303308)。2011年6月1日，nginx 1.0.4发布。\n\n​\t\tNginx是一款[轻量级](https://baike.baidu.com/item/轻量级/10002835)的[Web](https://baike.baidu.com/item/Web/150564) 服务器/[反向代理](https://baike.baidu.com/item/反向代理/7793488)服务器及[电子邮件](https://baike.baidu.com/item/电子邮件/111106)（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，[并发](https://baike.baidu.com/item/并发/11024806)能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、[京东](https://baike.baidu.com/item/京东/210931)、[新浪](https://baike.baidu.com/item/新浪/125692)、[网易](https://baike.baidu.com/item/网易/185754)、[腾讯](https://baike.baidu.com/item/腾讯/112204)、[淘宝](https://baike.baidu.com/item/淘宝/145661)等。\n\n## Nginx为什么出现并如此流行\n\n- 互联网数据的快速增长\n- Apache请求处理的低效性\n\n### Nginx相较于Apache的优势\n\n|        Apache        |        Nginx         |\n| :------------------: | :------------------: |\n| 一个进程处理一个请求 | 一个进程处理多个请求 |\n|       阻塞式的       |      非阻塞式的      |\n\n## Nginx处理请求过程\n\n<img src=\"WechatIMG550.png\" width=\"80%\" />\n\n## 三个常见应用场景\n\n1. 静态资源服务\n2. 反向代理服务\n3. API服务\n\n## 优势特点\n\n- 高并发、高性能\n- 扩展性好\n- 异步非阻塞的事件驱动模型\n\n## 简单安装\n\n- linux环境准备\n\n> Centos7\n\n```linux\nyum install epel-release -y\n\nyum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake\n\nyum -y install wget httpd-tools vim\n\nyum list all | grep nginx\n\nyum install nginx -y\n\n# 列出包里的所有文件\nrpm -ql nginx\n\nrpm -ql nginx | grep bin\n```\n\n## Linux信号量\n\n```linux\n# 列出linux所有信号量\nkill -l\n```\n\n## 利用信号量管理Nginx进程\n\n- Master进程\n\n<img src=\"WechatIMG606.png\" width=\"80%\" />\n\n- Woker进程\n\n<img src=\"WechatIMG607.png\" width=\"80%\" />\n\n- 命令行\n\n<img src=\"WechatIMG608.png\" width=\"80%\" />\n\n> Nginx会监测当前环境有几个cpu，就会启动几个woker进程（当nginx.conf 的 **worker_processes** 配置为 `auto`时，即没有指定**worker_processes**的数量时），每个worker进程都会绑定到一颗cpu上\n\n```linux\n# 查看linux cpu 相关信息\nlscpu\n\n# 杀死（关闭）master进程\nkill -s SIGTERM pid[master进程pid]\n\n# 重新读取配置文件关闭旧的worker进程，开启新的worker进程\nkill -s SIGHUP pid[master进程pid]\n\n```\n\n## reload重载配置文件的流程\n\n1. 向master进程发送HUP信号（reload命令）\n2. master进程检查配置语法是否正确\n3. master进程打开监听端口\n4. master进程使用新的配置文件启动新的worker子进程\n5. master进程向老的woker子进程发送QUIT信号\n6. 旧的work进程关闭监听句柄，处理完当前连接后关闭进程\n\n<img src=\"WechatIMG609.png\" width=\"80%\" />\n\n## Nginx热部署\n\n1. 将旧的Nginx文件替换成新的Nginx文件\n2. 向mstaer进程发送USR2信号\n3. master进程修改pid文件，加后缀.oldbin\n4. master进程用新nginx文件启动新master进程\n5. 向旧的master进程发送WINCH信号，旧的worker子进程退出\n6. 回滚情形：向旧master发送HUP，向新的master发送QUIT\n\n<img src=\"WechatIMG610.png\" width=\"80%\" />\n\n- Nginx热部署演示\n\n```linux\n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     1776  1775  0 11:11 ?        00:00:00 nginx: worker process\nnginx     1777  1775  0 11:11 ?        00:00:00 nginx: worker process\nroot      2078  1460  0 11:21 pts/0    00:00:00 grep --color=auto nginx\n\n\n[root@sorozy run]# kill -s SIGUSR2 1775\n[root@sorozy run]# \n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     1776  1775  0 11:11 ?        00:00:00 nginx: worker process\nnginx     1777  1775  0 11:11 ?        00:00:00 nginx: worker process\nroot      2146  1775  0 11:22 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2147  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2148  2146  0 11:22 ?        00:00:00 nginx: worker process\nroot      2159  1460  0 11:22 pts/0    00:00:00 grep --color=auto nginx\n\n\n[root@sorozy run]# kill -s SIGWINCH 1775\n[root@sorozy run]# \n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nroot      2146  1775  0 11:22 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2147  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2148  2146  0 11:22 ?        00:00:00 nginx: worker process\nroot      2201  1460  0 11:23 pts/0    00:00:00 grep --color=auto nginx\n\n##（1） 回滚\n[root@sorozy run]# kill -s SIGHUP 1775\n[root@sorozy run]# \n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nroot      2146  1775  0 11:22 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2147  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2148  2146  0 11:22 ?        00:00:00 nginx: worker process\nnginx     2280  1775  0 11:25 ?        00:00:00 nginx: worker process\nnginx     2281  1775  0 11:25 ?        00:00:00 nginx: worker process\nroot      2285  1460  0 11:25 pts/0    00:00:00 grep --color=auto nginx\n\n\n[root@sorozy run]#  kill -s SIGQUIT 2146\n[root@sorozy run]# ps -ef | grep nginx\nroot      1775     1  0 11:11 ?        00:00:00 nginx: master process /usr/sbin/nginx\nnginx     2280  1775  0 11:25 ?        00:00:00 nginx: worker process\nnginx     2281  1775  0 11:25 ?        00:00:00 nginx: worker process\nroot      2355  1460  0 11:26 pts/0    00:00:00 grep --color=auto nginx\n\n## (2) 删除不需要的old进程\nkill -s SIGQUIT 1775\n```\n\n## 模块化设计机制\n\n- 模块结构图\n\n<img src=\"WechatIMG611.png\" width=\"80%\" />\n\n- 模块体系结构\n\n<img src=\"WechatIMG612.png\" width=\"80%\" />\n\n## Nginx编译安装配置参数\n\n- 常用配置参数\n\n<img src=\"WechatIMG613.png\" width=\"80%\" />\n\n## 定制编译安装Nginx\n\n- 环境准备\n\n```linux\ncentos7\n\nwget\n\nyum\n```\n\n- 软件包准备\n\n```linux\n[root@sorozy source]# pwd\n/opt/source\n[root@sorozy source]# ll\n总用量 3512\n-rw-r--r--. 1 root root 1032630 8月  14 2019 nginx-1.16.1.tar.gz\n-rw-r--r--. 1 root root 2085854 2月  24 2019 pcre-8.43.tar.gz\n-rw-r--r--. 1 root root  467960 1月  16 2017 zlib-1.2.11.tar.xz\n```\n\n- 解压\n\n```linux\n[root@sorozy source]# tar xf zlib-1.2.11.tar.xz \n[root@sorozy source]# tar xf pcre-8.43.tar.gz \n[root@sorozy source]# tar xf nginx-1.16.1.tar.gz \n[root@sorozy source]# \n[root@sorozy source]# \n[root@sorozy source]# ll\n总用量 3528\ndrwxr-xr-x.  8 1001  1001     158 8月  13 2019 nginx-1.16.1\n-rw-r--r--.  1 root root  1032630 8月  14 2019 nginx-1.16.1.tar.gz\ndrwxr-xr-x.  7 1169  1169    8192 2月  24 2019 pcre-8.43\n-rw-r--r--.  1 root root  2085854 2月  24 2019 pcre-8.43.tar.gz\ndrwxr-xr-x. 14  501 games    4096 1月  16 2017 zlib-1.2.11\n-rw-r--r--.  1 root root   467960 1月  16 2017 zlib-1.2.11.tar.xz\n```\n\n- 编译前需要安装的相关依赖以及准备工作\n\n```linux\nyum install -y gcc gcc-c++\nyum install openssl openssl-devel -y\nyum install gd gd-devel -y\nuseradd nginx\n\n# 关闭防火墙\n# 关闭selinux\n```\n\n- 指定编译参数对nginx进行编译安装\n\n```linux\n# 进入nginx的解压目录\ncd nginx-1.16.1\n\n./configure --prefix=/opt/nginx --conf-path=/opt/nginx/conf/nginx.conf --user=nginx --group=nginx --pid-path=/opt/nginx/pid/nginx.pid --error-log-path=/opt/nginx/logs/error.log --with-pcre=/opt/source/pcre-8.43 --with-zlib=/opt/source/zlib-1.2.11 --with-http_ssl_module --with-http_image_filter_module --with-http_stub_status_module --http-log-path=/opt/nginx/logs/access.log\n```\n\n<br>\n\n```linux\nmake\n\nmake install\n```\n\n- nginx启动\n\n```linux\n/opt/nginx/sbin/nginx\n```\n\n# Nginx配置文件结构\n\n<img src=\"WechatIMG614.png\" width=\"80%\" />\n\n\n\n## 配置文件核心参数用法\n\n### main段核心参数\n\n|      | user USERNAME [GROUP]                                       |\n| :--: | ----------------------------------------------------------- |\n| 解释 | 指定运行Nginx的worker子进程的属主和属组，其中属组可以不指定 |\n| 示例 | user nginx nginx;                                           |\n\n|      | pid DIR                                      |\n| :--: | -------------------------------------------- |\n| 解释 | 指定运行Nginx的master主进程的pid文件存放路径 |\n| 示例 | pid /opt/nginx/logs/nginx.pid;               |\n\n|      | worker_rlimit_nofile number              |\n| :--: | ---------------------------------------- |\n| 解释 | 指定worker子进程可以打开的最大文件句柄数 |\n| 示例 | worker_rlimit_nofile 20480;              |\n\n|      | worker_rlimit_core size                                      |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 指定worker子进程异常终止后的core文件，用于记录分析问题       |\n| 示例 | worker_rlimit_core 50M;<br>working_directory /opt/nginx/tmp; |\n\n|      | work_processes number \\| auto                 |\n| :--: | --------------------------------------------- |\n| 解释 | 指定nginx启动的worker子进程数量               |\n| 示例 | worker_processes 4;<br>worker_processes auto; |\n\n|      | worker_cpu_affinity cpumask1 cpumask2...                     |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 将每个worker子进程与我们的cpu物理核心绑定                    |\n| 示例 | worker_cpu_affinity 0001 0010 0100 1000;<br>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000; # 8物理核心 8个worker子进程<br>worker_cpu_affinity 01 10 01 10; # 2个物理核心 4个worker子进程 |\n| 备注 | 将每个worker子进程与特定cpu物理核心绑定，优势在于：避免同一个worker子进程在不同的cpu物理核心上切换，缓存失效，降低性能；其并不能避免真正的进程切换 |\n\n|      | worker_priority number                                       |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 指定worker子进程的nice值，以调整运行nginx的优先级。通常设置为负值，以优先调用nginx |\n| 示例 | worker_priority -10;                                         |\n| 备注 | Linux默认进程的优先级值是120，值越小越优先；nice设定范围为-20到+19 |\n\n|      | worker_shutdown_timeout time         |\n| :--: | ------------------------------------ |\n| 解释 | 指定worker子进程优雅退出时的超时时间 |\n| 示例 | worker_shutdown_timeout 5s;          |\n\n|      | timer_resolution time                                        |\n| :--: | ------------------------------------------------------------ |\n| 解释 | worker子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升，反之，系统调用越多，性能下降 |\n| 示例 | worker_resolution 100ms;                                     |\n\n|      | daemon on \\| off                                             |\n| :--: | ------------------------------------------------------------ |\n| 解释 | 设定nginx的运行方式，前台还是后台，前台用户调试，后台用于生产 |\n| 示例 | daemon off;                                                  |\n\n- lock_file\n\n| 语法     | lock_file file             |\n| -------- | -------------------------- |\n| 默认配置 | lock_file logs/nginx.lock  |\n| 推荐配置 | lock_file logs/nginx.lock  |\n| 解释     | 负载均衡锁信息会写入该文件 |\n\n### events段核心参数\n\n| 参数               | 含义                                 |\n| :----------------- | ------------------------------------ |\n| use                | nginx使用何种事件驱动模型            |\n| worker_connections | worker子进程能够处理的最大并发连接数 |\n| accept_mutex       | 是否打开负载均衡互斥锁               |\n| accept_mutex_delay | 新连接分配给worker子进程的超时时间   |\n| lock_file          | 负载均衡互斥锁文件存放路径           |\n| multi_accept       | worker子进程可以接收的新连接个数     |\n\n- use\n\n| 语法         | use method                                        |\n| ------------ | ------------------------------------------------- |\n| method可选值 | select、poll、kqueue、epoll、/dev/poll、eventport |\n| 默认配置     | 无                                                |\n| 推荐配置     | 不指定，让nginx自己选择                           |\n\n- worker_connections\n\n| 语法     | worker_connections number                          |\n| -------- | -------------------------------------------------- |\n| 默认配置 | worker_connections 1024                            |\n| 推荐配置 | worker_connections 65535/worker_processes \\| 65535 |\n\n- accept_mutex\n\n| 语法     | accept_mutex on \\| off                                       |\n| -------- | ------------------------------------------------------------ |\n| 可选值   | on、off                                                      |\n| 默认配置 | accept_muttex off                                            |\n| 推荐配置 | accept_mutex on                                              |\n| 解释     | 当请求到达master process，off（默认）：给所有子进程发送这个请求。on：只给其中的一个子进程发送请求 |\n\n- accept_mutex_delay\n\n| 语法     | accept_mutex_delay time                                      |\n| -------- | ------------------------------------------------------------ |\n| 默认配置 | accept_mutex_delay 500ms                                     |\n| 推荐配置 | accept_mutex_delay 200ms                                     |\n| 解释     | 当请求到达master process，会给其中一个子进程发送请求，如果该子进程在设置的时间内未响应（响应超时），则master process会再给其它子进程发送请求 |\n| 备注     | 只有当`accept_mutex`设置为`on`的时候才有意义                 |\n\n- multi_accept\n\n| 语法     | multi_accept on \\| off         |\n| -------- | ------------------------------ |\n| 可选值   | on、of                         |\n| 默认配置 | multi_accept off               |\n| 推荐配置 | multi_accept on                |\n| 解释     | 一个子进程一次可以接受多个请求 |\n\n### server_name\n\n**语法**：server_name name1,name2,...;\n\n- 四种写法\n\n| server_name | www.badiu.com      |\n| ----------- | ------------------ |\n| server_name | *.baidu.com        |\n| server_name | www.baidu.*        |\n| server_name | ~^www\\\\.baidu\\\\.*$ |\n\n`~`表示正则表达式匹配\n\n- 优先级\n\n> 精确匹配 > 左侧通配符匹配 > 右侧通配符匹配 > 正则表达式匹配\n\n### root & alias\n\n- 相同点\n\n  > URI到磁盘路径的映射\n\n- 区别\n\n  > root会将定义路径与URI叠加<br>\n  >\n  > alias则只去定义路径<br>\n  >\n  > 使用alias末尾一定要加/<br>\n  >\n  > alias只能位于location块中<br>\n\n### location\n\n- 匹配规则\n\n<img src=\"WechatIMG640.png\" width=\"80%\" />\n\n- 优先级\n\n> `=` > `^~` > `~` > `~*` > `不带任何字符`\n\n- URL末尾带`/`和不带`/`的区别\n\n# module\n\n## stub_status\n\n> 指令：stub_status；<br>\n>\n> 低于1.7.5版本：stub_status on；<br>\n>\n> 上下文：server location；\n\n- 配置示例\n\n```nginx\nlocation /uri {\n  stub_status;\n}\n```\n\n- 状态项\n\n<img src=\"WechatIMG643.png\" width=\"80%\" />\n\n- 内嵌变量\n\n<img src=\"WechatIMG644.png\" width=\"80%\" />\n\n## limit_conn\n\n### 基本功能\n\n> 用于限制客户端并发连接数<br>\n>\n> 默认编译进Nginx，通过`--without-http_limit_conn_module`\n>\n> 使用共享内存，对所有worker子进程生效\n\n### 常用指令\n\n`limit_conn_zone`\n\n`limit_conn_status`\n\n`limit_conn_log_level`\n\n`limit_conn`\n\n### limit_conn_zone\n\n| 语法   | limit_conn_zone key zone=name:size                  |\n| ------ | --------------------------------------------------- |\n| 默认值 | 无                                                  |\n| 上下文 | http                                                |\n| 示例   | `limit_conn_zone $binary_remote_addr name=addr:10m` |\n\n### limit_conn_status\n\n| 语法   | limit_conn_status code; |\n| ------ | ----------------------- |\n| 默认值 | `limit_conn_status 503` |\n| 上下文 | http、server、location  |\n\n### limit_conn_log_level\n\n| 语法   | `limit_conn_log_level`  `info`/`notice`/`warn`/`error`; |\n| ------ | ------------------------------------------------------- |\n| 默认值 | `limit_conn_status` `503`                               |\n| 上下文 | http、server、location                                  |\n\n### limit_conn\n\n| 语法   | limit_conn zone number; |\n| ------ | ----------------------- |\n| 默认值 | 无                      |\n| 上下文 | http、server、location  |\n\n## limit_req\n\n> 用于限制客户端处理请求的平均速率\n>\n> 默认编译进nginx，通过`--without-http_limit_req_module`禁用\n>\n> 使用共享内存，对所有woker子进程生效\n>\n> 限流算法：leaky_bucket\n\n- leaky_bucket算法\n\n<img src=\"WechatIMG647.png\" width=\"80%\" />\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"《Nginx核心知识100讲》study notes","url":"/2020/09/16/《Nginx核心知识100讲》study-notes/","content":"\n# 学习备注\n\n> 1. 10需要再看看\n\n# 初识Nginx\n\n## 主流web服务器\n\nNginx、Apache、Tomcat\n\n## Nginx的三个主要应用场景\n\n<img src=\"WechatIMG550.png\" width=\"80%\"/>\n\n## Nginx为什么会出现\n\n1. 互联网的数据量快速增长：互联网的快速普及、全球化物联网\n2. 摩尔定律：性能提升\n\n3. 低效的Apache：一个连接对应一个进程\n\n## Nginx优点\n\n高并发、高性能\n\n可扩展性好\n\n高可靠性\n\n热部署\n\nBSD许可\n\n## Nginx组成\n\n<img src=\"WechatIMG552.png\" width=\"80%\"/>\n\n## Nginx配置语法\n\n<img src=\"WechatIMG559.png\" width=\"80%\"/>\n\n### 配置参数 - 时间单位\n\n| 简写 |      单位       |\n| :--: | :-------------: |\n|  ms  |   millisecond   |\n|  s   |     seconds     |\n|  m   |     minutes     |\n|  h   |      hours      |\n|  d   |      days       |\n|  w   |      weeks      |\n|  m   | months，30 days |\n|  y   | years，365days  |\n\n### 配置参数 - 空间单位\n\n| 简写 |   单位    |\n| :--: | :-------: |\n|      |   bytes   |\n| k/K  | kilobytes |\n| m/M  | megabytes |\n| g/G  | gigabytes |\n\n### http配置的指令块\n\n> http\n>\n> server\n>\n> upstream\n>\n> Location\n\n## Nginx命令行\n\n<img src=\"WechatIMG560.png\" width=\"80%\"/>","tags":["nginx","中间件"],"categories":["nginx","中间件"]},{"title":"《线程八大核心+Java并发底层原理精讲》study notes","url":"/2020/09/04/《线程八大核心-Java并发底层原理精讲》study-notes/","content":"\n# 学习备注\n\n（1）学习monitor，了解什么是锁\n\n（2）常见面试问题，用文字补充清楚，最好能口述出来\n\n（3）需要再深入学习一下\n\n# 为什么需要学习并发编程\n\n（1）源于JD的硬性要求，尤其是大厂\n\n（2）网络上面经高频出现，且水平参差不齐，做归纳整理耗时耗力，难辨真伪\n\n（3）是成为高级工程师的必经之路\n\n> 几乎所有程序或多或少需要并发和多线程\n>\n> 线上服务用户量大，并发量轻松过万，如果不使用并发编程，性能很快成为瓶颈\n>\n> 在职场打怪升级过程中，并发编程是绕不过去的boos\n\n（4）众多框架的原理和基础\n\n> spring中对线程池、单例的应用\n>\n> 数据库中的乐观锁思想\n>\n> log4j2对阻塞队列的应用\n\n# 课程学习概述\n\n（1）知识需要成体系，否则很容易忘记\n\n（2）课程内容包含：\n\n> 8大核心基础\n>\n> java内存模型\n>\n> 死锁\n>\n> 高频面试题+面试加薪技巧\n>\n> - 分析本质、深入原理\n>\n> 深入原理：剖析背后设计理念\n>\n> java内存模型——底层原理，修炼内功\n\n# 实现多线程的办法？几种？\n\n- 正确的说法\n\n> oracle官网说法：https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html\n\n> 有两种方法可以创建新的执行线程。一种是将一个类声明为Thread的子类。另一种方法是声明一个实现Runnable接口的类\n\n- 实现Runnable接口\n\n```java\npublic class RunnableStyle implements Runnable {\n  \n    @Override\n    public void run() {\n        System.out.println(\"通过实现Runnable接口创建线程\");\n    }\n\n    public static void main(String[] args) {\n        new Thread(new RunnableStyle()).start();\n    }\n}\n```\n\n- 继承Thread类\n\n```java\npublic class ThreadStyle extends Thread{\n\n    @Override\n    public void run() {\n        System.out.println(\"通过继承Thread类 创建线程\");\n    }\n\n    public static void main(String[] args) {\n        new ThreadStyle().start();\n    }\n}\n```\n\n- **准确的讲，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式**\n\n> 方法一：实现`Runnable`接口的run方法，并把Runnable实例传给Thread类\n>\n> 方法二：重写Thread的run方法（继承Thread类）\n\n## *继承Thread与实现Runnable接口方法区别\n\n- 实现（Runnable接口）更好\n\n> 1. 解耦角度（run方法应该和Thread类解耦）\n> 2. 资源节约（Runnable可以使用线程池，比Thread类节约资源）（线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类）\n> 3. 避免由单继承局限带来的影响\n\n- 本质对比\n\n> 实现（Runnable接口）：最终调用target.run();\n>\n> 继承Thread：run()整个都被重写\n\n- 思考：同时使用两种方法会怎么样？\n\n```java\npublic class BothRunnableThread {\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //下面折行代码将不会执行\n                System.out.println(\"我来自Runnable\");\n            }\n        }) {\n            @Override\n            public void run() {\n                System.out.println(\"我来自Thread\");\n            }\n        }.start();\n    }\n}\n\n//控制台打印：我来自Thread\n// 原因: run方法被重写了\n```\n\n# 彩蛋\n\n## 学习编程知识的优质途径\n\n- 宏观上\n\n  > 1. 并不是靠工作年限增长技术\n  > 2. 要有强大责任心，不放过任何bug，找到原因并去解决，这就是提高\n  > 3. 主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等\n  > 4. 敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程中，进步是飞速的\n  > 5. 关心产品，关心业务，而不只是写代码\n\n- 微观上\n\n  > 1. 看经典书籍（指外国人写的经典的中国译本比如java并发编程实战、自顶向下计算机网络）\n  > 2. 看官方文档\n  > 3. 使用英文搜索，使用google、stackoverflow\n  > 4. 自己动手写，实践写demo，尝试用到项目里\n  > 5. 不理解的参考该领域的多个书本，综合判断\n  > 6. 学习开源项目，分析源码（学习synchronized原理，反编译 看cpp代码）\n\n## 如何了解技术领域的最新动态\n\n- 高质量固定途径（掘金、阮一峰的blog）\n- 订阅技术论坛（infoQ）\n- 公众号\n\n## 如何在业务开发中成长\n\n- 偏业务方向...\n- 偏技术方向...\n- 两个25%理论\n\n# 实现多线程 - 常见面试问题\n\n（1）有多少种实现线程的方法?思路有5点\n\n> 1. 从不同角度看，会有不同的答案\n> 2. 典型答案是两种\n> 3. 我们看原理，两种本质都是一样的\n> 4. 具体展开说其它方式\n> 5. 结论\n\n解答：\n\n> 从不同的角度看这个问题会有不同的答案，（没有说是几种代码实现方法还是本质实现方法）。（典型回答是：）通过继承Thread类和实现Runnable接口两种方式来实现多线程。实现Runnable接口方式更好。有三点优势：\n>\n> 1. 解耦角度（run方法应该和Thread类解耦）\n> 2. 资源节约（Runnable可以使用线程池，比Thread类节约资源）（线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类）\n> 3. 避免由单继承局限带来的影响\n>\n> 看原理两种方法本质一样,Thread类中的run方法代码是\n\n```java\n @Override\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n```\n\n> 其实都是都是利用了Thread类的run方法，另外一种是重写了run方法，一种是传入target再执行run方法。\n>\n> （展开说：）除了上面说的两种方法还有很多种方法：线程池、定时器等。但是它们细看源码后，都没有逃脱以上这个本质。\n>\n> （总结：）本质上只有一种，新建线程我们必须通过Thread类，但是通常我们把它区分为两种形式：重写Thread的run方法（继承Thread类）、实现`Runnable`接口的run方法，并把Runnable实例传给Thread类。另外还有更多的外在表现形式：线程池、计时器、lamda、匿名内部类等等\n\n\n\n（2）实现Runnable接口和继承Thread类那种方式更好？\n\n> 1. 从代码架构角度\n> 2. 新建线程的损耗\n> 3. java不支持双继承\n\n解答：\n\n\n\n# 启动线程的正确和错误方式\n\n- star方法含义：启动新线程\n- 不能重复执行start方法\n- start()方法源码分析\n\n> 启动过新线程检查线程状态\n>\n> 加入线程组\n>\n> 调用start0(); （本地方法）\n\n## 启动线程 - 常见面试问题\n\n- 一个线程两次调用start()方法会出现什么情况？为什么？\n\n解答：\n\n> Java中线程是不允许启动两次的，第二次调用会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。\n>\n> 通过Thread类start方法源码，可以看出start方法是一个同步方法，并且在执行start方法时首先会判断当前线程的运行状态，只有在当前状态为**NEW**的时候才会继续执行，方法执行完毕或改变当前线程的状态。如此设计保证了线程仅可执行一次start。\n>\n> （在回答完以上内容后，如果感觉面试官没有让你停下来的意思，可以继续说下自己对于线程生命周期的理解。以下是对于线程生命周期的完整阐述，面试的时候可摘取必要部分进行阐述。）\n>\n> 关于线程生命周期的不同状态，在Java 5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：\n>\n> **新建（NEW）**，表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。\n>\n> **就绪（RUNNABLE）**，表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。\n>\n> 在其他一些分析中，会额外区分一种状态**RUNNING**，但是从Java API的角度，并不能表示出来。\n>\n> **阻塞（BLOCKED）**，这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。\n>\n> **等待（WAITING）**，表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。\n>\n> **计时等待（TIMED_WAIT）**，其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例：\n>\n> public final native void wait(long timeout) throws InterruptedException;\n>\n> **终止（TERMINATED）**，不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。\n>\n> 在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。\n>\n> - 考点分析\n>\n> 这个问题可以算是个常见的面试热身题目，不仅阿里，一些有技术积累的团队也会有类似的问法。前面给出的推荐回答，算是对线程基本状态和简单流转的一个简单介绍，如果觉得还不够直观，请参考如下状态图进行演练。\n\n<img src=\"123.jpeg\" width=\"700px\" />\n\n> 总的来说，理解线程的内部原理对于我们日常开发或者诊断分析，都是不可或缺的。\n>\n> 面试官可能会以此为契机，从各种不同角度考察你对线程的掌握：\n>\n> \\1. 资深一点的面试官可能会问你线程到底是什么以及Java底层实现线程的方式。\n>\n> \\2. 线程状态的切换、线程安全以及并发工具类等方面的扩展。\n>\n> \\3. 多线程编程时容易踩的坑与体会等。\n>\n> 可以看出，仅仅是一个线程，就有非常多的内容需要掌握。我们在面试备战过程中切忌浮躁，脚踏实地地把相关的知识点逐一攻克，还担心没有心仪大厂的offer嘛！\n\n- 既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？\n\n解答：\n\n> start()用来启动一个线程，当调用start()方法时，系统才会开启一个线程，通过Thead类中start()方法来启动的线程处于就绪状态（可运行状态），此时并没有运行，一旦得到CPU时间片，就自动开始执行run()方法。此时不需要等待run()方法执行完也可以继续执行下面的代码，所以也由此看出run()方法并没有实现多线程。\n> run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。\n\n# 线程停止、中断\n\n## 如何正确停止线程\n\n- 使用interrupt来通知（停止线程），而不是强制\n\n- 两种情况下线程会停止\n\n  > run()方法所有代码执行完毕<br>\n  >\n  > 抛出异常未捕获\n\n### 普通情况下停止线程\n\n```java\n/**\n *  run方法内没有sleep或wait方法时，停止线程\n */\npublic class RightWayStopThreadWithoutSleep implements Runnable{\n    @Override\n    public void run() {\n        int num=0;\n        //Thread.currentThread().isInterrupted() 线程是否被中断\n        while (!Thread.currentThread().isInterrupted() && num <= Integer.MAX_VALUE / 2) {\n            if (num % 10000 == 0 ) {\n                System.out.println(num+\"是10000的倍数\");\n            }\n            num++;\n        }\n        System.out.println(\"任务运行结束了\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new RightWayStopThreadWithoutSleep());\n        thread.start();\n        Thread.sleep(2000);\n        thread.interrupt();\n    }\n}\n```\n\n### 阻塞的情况下停止线程（响应中断的方式：抛出异常）\n\n```java\n/**\n * run方法内有sleep或wait时停止线程\n \n */\npublic class RightWayStopThreadWithSleep {\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            try {\n                int num = 0;\n\n                while (!Thread.currentThread().isInterrupted() && num <= 300 ) {\n                    if (num % 100 == 0 ) {\n                        System.out.println(num + \"是100的倍数\");\n                    }\n                    num++;\n                }\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n        Thread thread = new Thread(runnable);\n        thread.start();\n        Thread.sleep(500);\n        thread.interrupt();\n    }\n}\n```\n\n### 每次迭代后都阻塞\n\n```java\n/**\n * 如果在执行过程中，每次循环都会调用sleep或wait方法，那么不需要每次迭代都检查是否被中断，\n * 因为在sleep过程中会响应这个中断\n */\npublic class RightWayStopThreadWithSleepEveryLoop {\n  \n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            int num=0;\n            try {\n                // 在这里检测是否被打断是多余的\n                while (num <= 10000) {\n                    if (num % 100 == 0 ) {\n                        System.out.println(num+\"是100的倍数\");\n                    }\n                    num++;\n                    Thread.sleep(10);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        Thread.sleep(2000);\n        thread.interrupt();\n    }\n}\n```\n\n### while内try/catch问题\n\n*响应中断后会把interrupt标记位清除*\n\n```java\n/**\n * 描述：如果while里面放try catch 会导致中断失效\n 响应中断后会把interrupt标记位清除\n */\npublic class CantInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n          int num=0;\n              while (!Thread.currentThread().isInterrupted() &&  num <= 10000 ) {\n                  if (num % 100 == 0 ) {\n                      System.out.println(num + \"是100的倍数\");\n                  }\n                  num++;\n\n                  try {\n                    Thread.sleep(10);\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  }\n              }\n        };\n\n        Thread thread = new Thread(runnable);\n        thread.start();\n        Thread.sleep(2000);\n        thread.interrupt();\n    }\n}\n```\n\n### 两种最佳实践\n\n（1）优先选择：传递中断\n\n```java\n\n/**\n * @author 李国栋\n * @create 2020-09-09 3:51 下午\n *\n */\npublic class RightWayStopThreadInProd implements Runnable{\n    @Override\n    public void run() {\n        while (!Thread.currentThread().isInterrupted() && true) {\n            System.out.println(\"go\");\n            try {\n                throwInMethod();\n            } catch (InterruptedException e) {\n                //保存日志 或停止程序\n                e.printStackTrace();\n                System.out.println(\"保存日志 或停止程序\");\n            }\n        }\n    }\n\n    /**\n     * 把中断吞了（错误做法）\n     */\n//    private void throwInMethod() {\n//        try {\n//            Thread.sleep(1000);\n//        } catch (InterruptedException e) {\n//            e.printStackTrace();\n//        }\n//    }\n  /**\n  应该传递（正确做法）\n  */\n    private void throwInMethod() throws InterruptedException {\n      Thread.sleep(1000);\n    }\n        \n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new RightWayStopThreadInProd());\n        thread.start();\n        Thread.sleep(1000);\n        thread.interrupt();\n    }\n}\n\n```\n\n（2）不想或无法传递：恢复中断（重置打断标记）\n\n*描述：最佳实践2：在catch子语句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便于在后续的执行中，依然能够检查到刚才发生了中断*\n\n```java\npublic class RightWayStopThreadPro implements Runnable {\n    @Override\n    public void run() {\n        while( true){\n            if (Thread.currentThread().isInterrupted()){\n                System.out.println(\"程序被中断了\");\n                break;\n            }\n            reInterrupt();\n        }\n    }\n\n    public void reInterrupt(){\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            // 重置打断标记\n            Thread.currentThread().interrupted();\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new RightWayStopThreadPro());\n        thread.start();\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        thread.interrupt();\n    }\n}\n```\n\n\n\n- **不应屏蔽中断**\n\n- 响应终端的方法请求列表\n\n<img src=\"124.png\"  width=\"800px\"/>\n\n<img src=\"WechatIMG128.png\"  width=\"800px\"/>\n\n## 错误停止线程的方法\n\n（1）*用`stop()`来停止线程，会导致线程运行一半突然停止，没办法完成一个基本单位的操作*\n\n参考官方文档 https://docs.oracle.com/javase/7/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html\n\n（2）`suspend`和resume是带着锁休息的，不会释放锁，可能会导致死锁\n\n（3）用`volatile`设置boolean标记位（volatile只是看似可行）\n\n普通情况下可以，下面的情况下则无法停止\n\n```java\n/**\n * 描述：     演示用volatile的局限part2 陷入阻塞时，volatile是无法线程的 此例中，生产者的生产速度很快，消费者消费速度慢，所以阻塞队列满了以后，生产者会阻塞，等待消费者进一步消费\n */\npublic class WrongWayVolatileCantStop {\n\n    public static void main(String[] args) throws InterruptedException {\n        ArrayBlockingQueue storage = new ArrayBlockingQueue(10);\n\n        Producer producer = new Producer(storage);\n        Thread producerThread = new Thread(producer);\n        producerThread.start();\n        Thread.sleep(1000);\n\n        Consumer consumer = new Consumer(storage);\n        while (consumer.needMoreNums()) {\n            System.out.println(consumer.storage.take()+\"被消费了\");\n            Thread.sleep(100);\n        }\n        System.out.println(\"消费者不需要更多数据了。\");\n\n        //一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况\n        producer.canceled=true;\n        System.out.println(producer.canceled);\n    }\n}\n\nclass Producer implements Runnable {\n\n    public volatile boolean canceled = false;\n\n    BlockingQueue storage;\n\n    public Producer(BlockingQueue storage) {\n        this.storage = storage;\n    }\n\n\n    @Override\n    public void run() {\n        int num = 0;\n        try {\n            while (num <= 100000 && !canceled) {\n                if (num % 100 == 0) {\n                    storage.put(num);\n                    System.out.println(num + \"是100的倍数,被放到仓库中了。\");\n                }\n                num++;\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"生产者结束运行\");\n        }\n    }\n}\n\nclass Consumer {\n\n    BlockingQueue storage;\n\n    public Consumer(BlockingQueue storage) {\n        this.storage = storage;\n    }\n\n    public boolean needMoreNums() {\n        if (Math.random() > 0.95) {\n            return false;\n        }\n        return true;\n    }\n\n```\n\n错误原因：生产者阻塞在 `storage.put(num);` 这里，无法执行到 ` while (num <= 100000 && !canceled)` 这行代码。\n\n修正：使用 `interrupt`\n\n## 停止线程相关重要函数解析\n\n- 判断线程是否被中断相关方法\n\n```java\n// 判断线程是否被中断。会清楚打断标记\n// 源码\n public static boolean interrupted() {\n        return currentThread().isInterrupted(true);//true代表是否要清楚打断标记\n }\n\n// 判断线程是否被中断。但不会清除 打断标记\npublic boolean isInterrupted() {\n  return this.isInterrupted(false);\n}\n```\n\n- 注意点\n\n`Thread.interrupted` 的目的对象：不管是谁调用的，而是看执行这个方法的线程\n\n```java\n * 描述：     注意Thread.interrupted()方法的目标对象是“当前线程”，而不管本方法来自于哪个对象\n */\npublic class RightWayInterrupted {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Thread threadOne = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (; ; ) {\n                }\n            }\n        });\n\n        // 启动线程\n        threadOne.start();\n        //设置中断标志\n        threadOne.interrupt();\n        //获取中断标志\n        System.out.println(\"isInterrupted: \" + threadOne.isInterrupted());\n        //获取中断标志并重置\n        System.out.println(\"isInterrupted: \" + threadOne.interrupted());\n        //获取中断标志并重直\n        System.out.println(\"isInterrupted: \" + Thread.interrupted());\n        //获取中断标志\n        System.out.println(\"isInterrupted: \" + threadOne.isInterrupted());\n        threadOne.join();\n        System.out.println(\"Main thread is over.\");\n    }\n}\n```\n\n## 停止线程 - 常见面试问题\n\n（1）如何停止线程\n\n<img src=\"WechatIMG130 .png\"  width=\"800px\"/>\n\n（2）如何处理不可中断的阻塞\n\n待解决\n\n# 线程的6个状态（生命周期）\n\n<img src=\"WechatIMG131 .png\"  width=\"800px\"/>\n\n```java\n/**\n * 描述：     展示线程的NEW、RUNNABLE、Terminated状态。即使是正在运行，也是Runnable状态，而不是Running。\n */\npublic class NewRunnableTerminated implements Runnable {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new NewRunnableTerminated());\n        //打印出NEW的状态\n        System.out.println(thread.getState());\n        thread.start();\n        System.out.println(thread.getState());\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //打印出RUNNABLE的状态，即使是正在运行，也是RUNNABLE，而不是RUNNING\n        System.out.println(thread.getState());\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //打印出TERMINATED状态\n        System.out.println(thread.getState());\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n\n\n```java\n/**\n * 描述：     展示Blocked, Waiting, TimedWaiting\n */\npublic class BlockedWaitingTimedWaiting implements Runnable{\n    public static void main(String[] args) {\n        BlockedWaitingTimedWaiting runnable = new BlockedWaitingTimedWaiting();\n        Thread thread1 = new Thread(runnable);\n        thread1.start();\n        Thread thread2 = new Thread(runnable);\n        thread2.start();\n        try {\n            Thread.sleep(5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //打印出Timed_Waiting状态，因为正在执行Thread.sleep(1000);\n        System.out.println(thread1.getState());\n        //打印出BLOCKED状态，因为thread2想拿得到sync()的锁却拿不到\n        System.out.println(thread2.getState());\n        try {\n            Thread.sleep(1300);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //打印出WAITING状态，因为执行了wait()\n        System.out.println(thread1.getState());\n\n    }\n\n    @Override\n    public void run() {\n        syn();\n    }\n\n    private synchronized void syn() {\n        try {\n            Thread.sleep(1000);\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n---","tags":["java","concurrent"],"categories":["java","concurrent"]},{"title":"《理论+实战 构建完整JVM知识体系》study notes","url":"/2020/09/03/《理论-实战-构建完整JVM知识体系》study-notes/","content":"\n\n\n# 备注\n\n> Java9模块系统开发需要抽空了解一下\n\n# JVM概述\n\n## 为什么需要学习jvm\n\n（1）面试需要。衡量中高级开发人员技术储备\n\n（2）更加深入理解。知其然还要知其所以然\n\n> 一个类是如何装载到jvm的\n>\n> 它在jvm中是如何存储的\n>\n> 如何运行的\n>\n> 方法是如何调用的\n>\n> 运行时内存是怎么分配的\n>\n> 产生垃圾后是如何回收的\n\n（3）排查解决故障的能力\n\n> 内存溢出导致宕机了\n>\n> cpu使用率居高不下\n>\n> 频繁卡顿\n>\n> 应用越跑越慢\n\n（4）应用jvm对java应用和中间件调优\n\n> 需要（如何）合理的分配内存\n>\n> 调整参数\n>\n> 选择GC垃圾回收器\n>\n> 对第三方中间件调优\n\n## jvm知识体系\n\n- jvm知识导图\n\n<img src=\"WechatIMG61.png\" />\n\n- java虚拟机知识框架图\n\n<img width=\"700px\" src=\"WechatIMG62.jpeg\" />\n\n## jvm是什么\n\n- JVM：Java Virtual Machine（java虚拟机）\n- 虚拟机：通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的计算机系统\n- jvm 是通过软件来模拟java的字节码指令集，是java程序的运行环境\n\n<img width=\"700px\" src=\"WechatIMG388.png\" />\n\n## jvm主要功能\n\n（1）通过ClassLoader寻找和装载class文件\n\n（2）解释字节码成为指令并执行，提供class文件的运行环境\n\n（3）进行运行期间的内存分配和垃圾回收\n\n（4）提供与硬件交互的平台\n\n## 虚拟机是java平台无关的保障\n\n<img width=\"700px\" src=\"WechatIMG393.png\" />\n\n## jvm规范作用\n\n- java虚拟机规范为不同的硬件平台提供了一种编译java技术代码的规范\n- 该规范使用java软件独立于平台，因为编译是针对作为虚拟机的`一般机器`而做\n- 这个`一般机器`可用软件模拟并运行于各种现存的计算机系统，也可用硬件来实现\n\n## jvm规范定义的主要内容\n\n- 字节码指令集（相当于中央处理器cpu）\n- class文件的格式\n- 数据类型和值\n- 运行时数据区\n- 栈帧\n- 特殊方法\n- 类库\n- 异常\n- 虚拟机的启动、加载、链接和初始化\n\n# class文件格式概述\n\nclass文件是jvm的输入，java虚拟机规范中定义了，class文件的结构，class文件是jvm实现平台无关、技术无关的基础\n\n1:class文件是一组以8字节为单位的字节流，各个数据项目按顺序紧凑排列\n\n2:对于占用空间大于8字节的的数据项，按照高位在前的方式分割成多个8字节进行存储\n\n3:class文件格式里面只有两种数据类型：无符号数、表\n\n（1）无符号数：基础数据类型，以u1、u2、u4、u8来代表几个字节的无符号数\n\n（2）表：由多个无符号数和其它表构成的复合数据类型，通常以`_info`结尾\n\n\n\n\n\n# 类加载\n\n## 概述\n\n<img width=\"500px\" src=\"WechatIMG404.png\" />\n\n- 加载：查找并加载类文件的二进制数据\n- 连接：将已经读入内存的类的二进制数据合并到jvm运行时环境中去，包含如下几个步骤\n\n> 1. 验证 ：确保被加载类的正确性\n> 2. 准备：为类的静态变量分配内存，并初始化它们\n> 3. 解析：把常量池中的符号引用转换成直接引用\n\n- 初始化：为类的静态变量赋初始值\n\n### 类加载要完成的功能\n\n1. 通过类的全限定名来获取该类的二进制字节流\n2. 把二进制字节流转化为方法区的运行时数据结构\n3. 在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口\n\n### 加载类的方式\n\n- 最常见的方式：本地文件系统中加载、从jar等归档文件中加载\n- 动态的方式：将java源文件动态编译成class\n- 其它方式：网络下载、从专有数据库中加载等等\n\n## 类加载器\n\n<img width=\"500px\" src=\"WechatIMG409.png\" />\n\n- 为什么要废除jdk1.8的扩展类加载器\n\n> 1. jdk1.8的扩展类加载器主要加载`jre/lib/ext` 下面的jar包，当我们想扩展功能的时候就把jar包放在下面。其实并不安全\n> 2. jdk9想要扩展功能的时候，因为jdk9有了模块化开发，这种扩展机制就被模块化的天然扩展能力取代了\n\n- 类加载器的关系\n\n<img width=\"500px\" src=\"WechatIMG411.png\" />\n\n## 类加载器说明\n\n<img width=\"500px\" src=\"WechatIMG413.png\" /><br>\n\n```java\n// 各种类加载器\npublic class ClassLoaderStudy {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\tString str = \"Hello ClassLoader\";\n\t\tSystem.out.println(\"str ClassLoader == \" + str.getClass().getClassLoader());\n\t\t\n\t\tSystem.out.println(\"\\n\");\n\t\t\n\t\tClass driver = Class.forName(\"java.sql.Driver\");\n\t\tSystem.out.println(\"driver ClassLoader == \" + driver.getClassLoader());\n\t\tSystem.out.println(\"driver parent ClassLoader == \" + driver.getClassLoader().getParent());\n\t\t\n\t\tSystem.out.println(\"\\n\");\n\t\t\n\t\tClassLoaderStudy clt = new ClassLoaderStudy();\n\t\tSystem.out.println(\"clt ClassLoader == \" + clt.getClass().getClassLoader());\n\t\tSystem.out.println(\"clt parent  ClassLoader == \" + clt.getClass().getClassLoader().getParent());\n\t\tSystem.out.println(\"clt parent parent ClassLoader == \" + clt.getClass().getClassLoader().getParent().getParent());\n\t}\n}\n```\n\n```java\n// 运行输出结果\nstr ClassLoader == null\n\n\ndriver ClassLoader == jdk.internal.loader.ClassLoaders$PlatformClassLoader@27c170f0\ndriver parent ClassLoader == null\n\n\nclt ClassLoader == jdk.internal.loader.ClassLoaders$AppClassLoader@55054057\nclt parent  ClassLoader == jdk.internal.loader.ClassLoaders$PlatformClassLoader@27c170f0\nclt parent parent ClassLoader == null\n```\n\n\n\n<img width=\"500px\" src=\"WechatIMG414.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG415.png\" />\n\n\n\n\n\n## 双亲委派模型\n\n<img width=\"500px\" src=\"WechatIMG416.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG417.png\" /><br><img width=\"500px\" src=\"WechatIMG30.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG31.png\" /><br>\n\n### 破坏双亲委派模型\n\n<img width=\"500px\" src=\"WechatIMG32.png\" /><br>\n\n# 内存分配\n\n## JVM简化架构\n\n<img width=\"500px\" src=\"WechatIMG946.png\" />\n\n## PC（Program Counter）寄存器\n\n（1）每个线程拥有一个PC寄存器，是线程私有的，用来存储指向下一条指令的地址\n\n（2）在创建线程的时候，创建相应的PC寄存器\n\n（3）执行本地方法时，PC寄存器的值为undefined\n\n（4）是一块较小的内存空间，是唯一一个在jvm规范中没有规定OutOfMemoryError的内存区域\n\n## java 栈\n\n- 栈是由一系列帧（frame）组成（因此java栈也叫做帧栈），是线程私有的\n- 帧用来保存一个方法的局部变量、操作数栈（java没有寄存器，所有操作使用操作数栈）、常量池指针、动态链接、方法返回值等\n- 每一次方法调用创建一个帧，并压栈。退出方法的时候退出栈顶指针就可以把栈帧中的内容销毁\n- 局部变量表存放了编译期可预知的各种基本数据类型和引用类型，每个slot存放32位的数据，long、double两个槽位\n\n- 优点：存取速度比堆快，仅次于寄存器\n- 缺点：存在栈中的数据大小、生存期是在编译期决定的，缺乏灵活性\n\n## java堆\n\n- 用来存放应用系统创建的对象和数组，所有线程共享java堆\n- gc主要就管理堆空间，对分代gc来说，堆也是分代的\n- 优点：运行期动态分配内存大小，自动进行垃圾回收\n- 缺点：效率相对较慢\n\n<img width=\"500px\" src=\"WechatIMG959.png\" />\n\n### java堆的结构\n\n- 新生代用来放新分配的对象，新生代中经过垃圾回收，没有回收掉的对象，被复制到老年代\n\n- 老年代存储对象比新生代存储对象的年龄大的多\n\n- 老年代存储一些大对象\n- 整个堆大小 = 新生代 + 老年代\n- 新生代 = Eden + 存活区\n- 从前的持久代，用来存放Class、Method等元信息的区域，从jdk8去掉了。取而代之的是元空间（MetaSpace），元空间并不在虚拟机里面。而是直接使用本地内存\n\n## 方法区\n\n- 方法区是线程共享的，通常用来保存装载的类的结构信息\n- 通常跟元空间关联在一起，但具体的跟jvm实现和版本有关\n- jvm规范把方法区描述成为堆的一个逻辑部分，但它有一个别称Non-heap（非堆）。应是为了与java堆区分开\n\n### 运行时常量池\n\n- 是class文件中每个类或接口的常量池表，在运行期间的表现形式，通常包括：类的版本、字段、方法、接口等信息\n- 在方法区中分配\n\n- 通常在加载类和接口到jvm后，就创建相应的运行时常量池\n\n## 本地方法栈\n\n- 在jvm中用来支持native方法执行的方法栈就是本地方法栈\n\n## 栈、堆、方法区交互关系\n\n<img width=\"500px\" src=\"WechatIMG980.jpeg\" />\n\n## 对象的内存布局\n\n- 对象在内存中存在的布局（这里以HotSpot虚拟机为例来说明），分为对象头、实例数据和对齐填充\n- 对象头分为两个部分：\n\n（1）Mark Word：存储对象自身的运行数据，如：HashCode，GC分代年龄、锁状态标志等\n\n（2）类型指针：对象指向它的类原数据的指针\n\n- 实例数据：真正存放对象实例数据的地方\n- 对齐填充：这部分不一定存在，也没有什么特殊含义。仅仅是占位符。因为HotSpot要求对象起始地址都是8字节的整数倍，如果不是就对齐\n\n## 对象的访问定位\n\n- 对象的访问定位在jvm中只规定了reference类型是一个指向对象的引用，但没有规定这个引用具体如何去定位，访问堆中对象的具体位置\n\n- 对象的访问方式取决于jvm的实现。目前主流的有：使用句柄 或 使用指针两种方式\n- hotspot采用的第二种\n\n### 使用句柄\n\nJava堆中会划出一块内存来作为句柄池，reference中存储句柄池的地址，句柄中存储对象的实例数据，和类元数据地址\n\n<img width=\"500px\" src=\"WechatIMG966.png\" width=\"800px\" />\n\n### 使用指针\n\nJava堆中会存放访问类元数据的地址，reference存储的就直接是对象的地址\n\n<img width=\"500px\" src=\"WechatIMG968.png\" width=\"800px\" />\n\n## Trace跟踪参数\n\n打印gc的的简要信息：-Xlog:gc\n\n打印gc的详细信息：Xlog:gc*\n\n指定gc log的位置，以文件输出：-Xlog:gc:garbage-collection.log\n\n每一次gc后都打印堆信息：-Xlog:gc+heap:debug\n\n### gc日志格式\n\ngc发生的时间，也就是jvm从启动以来经过的秒数\n\n日志级别信息和日志类型标记\n\ngc识别号\n\ngc类型和说明gc的原因\n\n容量：gc前容量->gc后容量（该区域总容量）\n\ngc持续时间，单位秒。有的收集器会有更详细的描述，比如：user标示应用程序消耗的时间。sys表示系统内核消耗的时间。real表示操作从开始到结束表示的时间\n\n### *java 堆的参数\n\n-Xms 必须大于1MB，必须是1024的倍数\n\n-Xmx 必须大于2MB，必须是1024的倍数\n\n-Xms：初始堆大小，默认物理内存的1/64\n\n-Xmx：最大堆大小，默认物理内存的1/4\n\n一般 Xms 和 Xmx尽量配置一样，好处：避免每次gc后重新调整堆大小，减少内存开销\n\n\n\n# 字节码执行引擎\n\n## 执行引擎概述\n\n- 功能基本就是输入字节码文件，然后对字节码进行解析并处理，最后输出执行结果\n- 实现方式\n\n（1）解释器直接解释执行\n\n（2）通过及时编译器产生本地代码，编译执行。也可两者皆有\n\n## 栈帧\n\n- 栈帧是用于支持jvm进行方法调用和方法执行的数据结构\n- 生命周期：栈帧随着方法创建而创建，方法结束而销毁\n- 栈帧里存储了方法的局部变量、操作数栈、动态连接、方法返回地址等信息\n\n## 局部变量表\n\n- 用来存放方法参数和方法内部定义的局部变量的存储空间\n\n（1）以变量槽slot为单位，目前一个slot存放32位以内的数据类型\n\n（2）对于64位的数据，占用2个slot\n\n（3）对于实例方法，第0位存放的是 `this`，然后从1到n依次分配给参数列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jvm"],"categories":["jvm"]},{"title":"《一站式学习Java网络编程 全面理解BIO/NIO/AIO》study notes","url":"/2020/09/01/《一站式学习Java网络编程-全面理解BIO-NIO-AIO》study-notes/","content":"\n# 学习备注\n\n> 学习java io中的装饰器模式\n>\n> 学习线程池相关的知识\n>\n> 学习socket等相关的知识\n>\n> 多线程并发这块是先导知识，后序要深入理解\n>\n> Ok-学习 同步 异步 阻塞 非阻塞\n\n# 基础网络层的解析与协议\n\n##### \n\n\n\n# 概述\n\nBIO：Java 1.4以前\n\nNIO： java 1.4\n\nAIO： java 1.7\n\n- 网络编程的本质：进程间的通信\n- 通信的基础：IO模型\n\n## java io\n\n## 字符流\n\n<img src=\"WechatIMG702.png\" />\n\n## 字节流\n\n<img src=\"WechatIMG703.png\" />\n\n# Socket\n\n- socket也是一种数据源\n- socket是网络通信的断点\n\n- 通过socket发送数据\n\n<img src=\"WechatIMG706.png\" />\n\n# 同步 异步 阻塞 非阻塞\n\n- 同步和异步关注的是**消息通信机制**\n\n> 同步：就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回\n>\n> 异步：**调用**在发出之后，这个**调用**就直接返回了，所以没有返回结果\n\n- 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态\n\n> 阻塞调用：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回\n> 非阻塞调用：指在不能立刻得到结果之前，该调用不会阻塞当前线程\n\n# 线程池\n\n<img src=\"WechatIMG708.png\" />\n\n- 创建线程池的方法\n\n<img src=\"WechatIMG709.png\" />\n\n","tags":["network","io"],"categories":["io","network"]},{"title":"《深入理解Java虚拟机》study notes","url":"/2020/09/01/《深入理解Java虚拟机》study-notes/","content":"\n\n\n# 第二章 Java内存区域与内存溢出异常\n\n## 运行时数据区\n\n<img src=\"unnamed.jpg\" width=\"500px\" />\n\n### 程序计数器（program counter register）\n\n- 当前线程所执行的字节码行号指示器\n- 线程私有的内存\n- 没有OOM的区域","tags":["jvm"]},{"title":"适合后端编程人员的Redis实战教程","url":"/2020/08/24/适合后端编程人员的Redis实战教程/","content":"# Redis\n\n## 1.  NoSQL的引言\n\n**NoSQL**(` Not Only SQL` )，意即**不仅仅是SQL**, 泛指非关系型的数据库。Nosql这个技术门类,早期就有人提出,发展至2009年趋势越发高涨。\n\n## 2. 为什么是NoSQL\n\n随着互联网网站的兴起，传统的关系数据库在应付动态网站，特别是超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。如`商城网站中对商品数据频繁查询`、`对热搜商品的排行统计`、`订单超时问题`、以及微信朋友圈（音频，视频）存储等相关使用传统的关系型数据库实现就显得非常复杂，虽然能实现相应功能但是在性能上却不是那么乐观。nosql这个技术门类的出现，更好的解决了这些问题，它告诉了世界不仅仅是sql。\n\n## 3. NoSQL的四大分类\n\n### 3.1 键值(Key-Value)存储数据库\n\n```markdown\n# 1.说明: \n- 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。\n\n# 2.特点\n- Key/value模型对于IT系统来说的优势在于简单、易部署。  \n- 但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。\n\n# 3.相关产品\n- Tokyo Cabinet/Tyrant,\n- Redis\n- SSDB\n- Voldemort \n- Oracle BDB\n```\n\n### 3.2 列存储数据库\n\n```markdown\n# 1.说明\n- 这部分数据库通常是用来应对分布式存储的海量数据。\n\n# 2.特点\n- 键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。\n\n# 3.相关产品\n- Cassandra、HBase、Riak.\n```\n\n### 3.3 文档型数据库\n\n```markdown\n# 1.说明\n- 文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高\n\n# 2.特点\n- 以文档形式存储\n\n# 3.相关产品\n- MongoDB、CouchDB、 MongoDb(4.x). 国内也有文档型数据库SequoiaDB，已经开源。\n```\n\n### 3.4 图形(Graph)数据库\n\n ```markdown\n# 1.说明\n- 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。\n- NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。\n\n# 2.特点\n\n# 3.相关产品\n- Neo4J、InfoGrid、 Infinite Graph、\n ```\n\n----\n\n## 4. NoSQL应用场景\n\n- 数据模型比较简单\n\n- 需要灵活性更强的IT系统\n\n- 对数据库性能要求较高\n\n- 不需要高度的数据一致性\n\n## 5. 什么是Redis\n\n<img width=\"700px\" src=\"image-20200623121234046.png\" />\n\n> Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.\n\nRedis 开源  遵循BSD  基于内存数据存储 被用于作为 数据库 缓存  消息中间件\n\n- 总结: redis是一个内存型的数据库\n\n## 6. Redis特点\n\n-  Redis是一个高性能key/value内存型数据库\n\n- Redis支持丰富的数据类型 \n\n- Redis支持持久化 \n\n- Redis单线程,单进程\n\n---\n\n## 7. Redis安装\n\n```markdown\n# 0.准备环境\n- vmware15.x+\n- centos7.x+\n\n# 1.下载redis源码包\n- https://redis.io/\n```\n\n<img width=\"700px\" src=\"image-20200623121621195.png\"  />\n\n```markdown\n# 2.下载完整源码包\n- redis-4.0.10.tar.gz\n```\n\n<img width=\"700px\" src=\"image-20200623123918876.png\" />\n\n```markdown\n# 3.将下载redis资料包上传到Linux中\n```\n\n<img width=\"700px\" src=\"image-20200623124327319.png\" />\n\n```markdown\n# 4.解压缩文件\n[root@localhost ~]# tar -zxvf redis-4.0.10.tar.gz\n[root@localhost ~]# ll\n```\n\n<img width=\"700px\" src=\"image-20200623124522026.png\" />\n\n```markdown\n# 5.安装gcc  \n- yum install -y gcc\n\n# 6.进入解压缩目录执行如下命令\n- make MALLOC=libc\n\n# 7.编译完成后执行如下命令\n- make install PREFIX=/usr/redis\n\n# 8.进入/usr/redis目录启动redis服务 \n- ./redis-server\n```\n\n<img width=\"700px\" src=\"image-20200623125420505.png\" />\n\n```markdown\n# 9.Redis服务端口默认是 6379\n\n# 10.进入bin目录执行客户端连接操作\n- ./redis-cli –p 6379\n```\n\n<img width=\"700px\" src=\"image-20200623125716013.png\" />\n\n```markdown\n# 11.连接成功出现上面界面连接成功\n```\n\n## 8. Redis数据库相关指令\n\n### 8.1 数据库操作指令\n\n```markdown\n# 1.Redis中库说明\n- 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15\n- 可以使用select 库的编号 来选择一个redis的库\n\n# 2.Redis中操作库的指令\n- 清空当前的库  FLUSHDB\n- 清空全部的库  FLUSHALL\n\n# 3.redis客户端显示中文\n-\t./redis-cli  -p 7000 --raw\n```\n\n### 8.2 操作key相关指令\n\n```markdown\n# 1.DEL指令\n- 语法 :  DEL key [key ...] \n- 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。\n- 可用版本： >= 1.0.0\n- 返回值： 被删除key 的数量。 \n\n# 2.EXISTS指令\n- 语法:  EXISTS key\n- 作用:  检查给定key 是否存在。\n- 可用版本： >= 1.0.0\n- 返回值： 若key 存在，返回1 ，否则返回0。\n\n# 3.EXPIRE\n- 语法:  EXPIRE key seconds\n- 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。\n- 可用版本： >= 1.0.0\n- 时间复杂度： O(1)\n- 返回值：设置成功返回1 。\n\n# 4.KEYS\n- 语法 :  KEYS pattern\n- 作用 :  查找所有符合给定模式pattern 的key 。\n- 语法:\n\tKEYS * 匹配数据库中所有key 。\n\tKEYS h?llo 匹配hello ，hallo 和hxllo 等。\n\tKEYS h*llo 匹配hllo 和heeeeello 等。\n\tKEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 \"\\\" 隔开\n- 可用版本： >= 1.0.0\n- 返回值： 符合给定模式的key 列表。\n\n# 5.MOVE\n- 语法 :  MOVE key db\n- 作用 :  将当前数据库的key 移动到给定的数据库db 当中。\n- 可用版本： >= 1.0.0\n- 返回值： 移动成功返回1 ，失败则返回0 。\n\n# 6.PEXPIRE\n- 语法 :  PEXPIRE key milliseconds\n- 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。\n- 可用版本： >= 2.6.0\n- 时间复杂度： O(1)\n- 返回值：设置成功，返回1  key 不存在或设置失败，返回0\n\n# 7.PEXPIREAT\n- 语法 :  PEXPIREAT key milliseconds-timestamp\n- 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。\n- 可用版本： >= 2.6.0\n- 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)\n\n# 8.TTL\n- 语法 :   TTL key\n- 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。\n- 可用版本： >= 1.0.0\n- 返回值：\n\t当key 不存在时，返回-2 。\n\t当key 存在但没有设置剩余生存时间时，返回-1 。\n\t否则，以秒为单位，返回key 的剩余生存时间。\n- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。\n\n# 9.PTTL\n- 语法 :  PTTL key\n- 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。\n- 可用版本： >= 2.6.0\n- 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。\n- 否则，以毫秒为单位，返回key 的剩余生存时间。\n- 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。\n\n# 10.RANDOMKEY\n- 语法 :  RANDOMKEY\n- 作用 :  从当前数据库中随机返回(不删除) 一个key 。\n- 可用版本： >= 1.0.0\n- 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。\n\n# 11.RENAME\n- 语法 :  RENAME key newkey\n- 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。\n- 可用版本： >= 1.0.0\n- 返回值： 改名成功时提示OK ，失败时候返回一个错误。\n\n# 12.TYPE\n- 语法 :  TYPE key\n- 作用 :  返回key 所储存的值的类型。\n- 可用版本： >= 1.0.0\n- 返回值：\n\tnone (key 不存在)\n\tstring (字符串)\n\tlist (列表)\n\tset (集合)\n\tzset (有序集)\n\thash (哈希表)\n```\n\n### 8.3 String类型\n\n#### 1. 内存存储模型\n\n<img width=\"700px\" src=\"image-20200623132104399.png\" />\n\n#### 2. 常用操作命令\n\n| 命令                                       | 说明                                       |\n| ------------------------------------------ | ------------------------------------------ |\n| set                                        | 设置一个key/value                          |\n| get                                        | 根据key获得对应的value                     |\n| mset                                       | 一次设置多个key value                      |\n| mget                                       | 一次获得多个key的value                     |\n| getset                                     | 获得原始key的值，同时设置新值              |\n| strlen                                     | 获得对应key存储value的长度                 |\n| append                                     | 为对应key的value追加内容                   |\n| getrange 索引0开始                         | 截取value的内容                            |\n| setex                                      | 设置一个key存活的有效期（秒）              |\n| psetex                                     | 设置一个key存活的有效期（毫秒）            |\n| setnx                                      | 存在不做任何操作,不存在添加                |\n| msetnx原子操作(只要有一个存在不做任何操作) | 可以同时设置多个key,只有有一个存在都不保存 |\n| decr                                       | 进行数值类型的-1操作                       |\n| decrby                                     | 根据提供的数据进行减法操作                 |\n| Incr                                       | 进行数值类型的+1操作                       |\n| incrby                                     | 根据提供的数据进行加法操作                 |\n| Incrbyfloat                                | 根据提供的数据加入浮点数                   |\n\n###  8.4 List类型\n\nlist 列表 相当于java中list 集合  特点  元素有序  且 可以重复\n\n#### 1.内存存储模型\n\n<img width=\"700px\" src=\"image-20200623161114380.png\" />\n\n#### 2.常用操作指令\n\n| 命令    | 说明                                 |\n| ------- | ------------------------------------ |\n| lpush   | 将某个值加入到一个key列表头部        |\n| lpushx  | 同lpush,但是必须要保证这个key存在    |\n| rpush   | 将某个值加入到一个key列表末尾        |\n| rpushx  | 同rpush,但是必须要保证这个key存在    |\n| lpop    | 返回和移除列表左边的第一个元素       |\n| rpop    | 返回和移除列表右边的第一个元素       |\n| lrange  | 获取某一个下标区间内的元素           |\n| llen    | 获取列表元素个数                     |\n| lset    | 设置某一个指定索引的值(索引必须存在) |\n| lindex  | 获取某一个指定索引位置的元素         |\n| lrem    | 删除重复元素                         |\n| ltrim   | 保留列表中特定区间内的元素           |\n| linsert | 在某一个元素之前，之后插入新元素     |\n\n### 8.5 Set类型\n\n特点: Set类型 Set集合 元素无序  不可以重复\n\n#### 1.内存存储模型\n\n<img width=\"700px\" src=\"image-20200623193634316.png\" />\n\n#### 2.常用命令\n\n| 命令        | 说明                                               |\n| ----------- | -------------------------------------------------- |\n| sadd        | 为集合添加元素                                     |\n| smembers    | 显示集合中所有元素 无序                            |\n| scard       | 返回集合中元素的个数                               |\n| spop        | 随机返回一个元素 并将元素在集合中删除              |\n| smove       | 从一个集合中向另一个集合移动元素  必须是同一种类型 |\n| srem        | 从集合中删除一个元素                               |\n| sismember   | 判断一个集合中是否含有这个元素                     |\n| srandmember | 随机返回元素                                       |\n| sdiff       | 去掉第一个集合中其它集合含有的相同元素             |\n| sinter      | 求交集                                             |\n| sunion      | 求和集                                             |\n\n###  8.6 ZSet类型\n\n特点: 可排序的set集合  排序  不可重复 \n\nZSET 官方  可排序SET  sortSet   \n\n#### 1.内存模型\n\n<img width=\"700px\" src=\"image-20200623194903967.png\" />\n\n#### 2.常用命令\n\n| 命令                       | 说明                         |\n| -------------------------- | ---------------------------- |\n| zadd                       | 添加一个有序集合元素         |\n| zcard                      | 返回集合的元素个数           |\n| zrange 升序 zrevrange 降序 | 返回一个范围内的元素         |\n| zrangebyscore              | 按照分数查找一个范围内的元素 |\n| zrank                      | 返回排名                     |\n| zrevrank                   | 倒序排名                     |\n| zscore                     | 显示某一个元素的分数         |\n| zrem                       | 移除某一个元素               |\n| zincrby                    | 给某个特定元素加分           |\n\n###  8.7 hash类型\n\n特点: value 是一个map结构 存在key value  key 无序的  \n\n#### 1.内存模型\n\n<img width=\"700px\" src=\"image-20200623200348408.png\" />\n\n#### 2.常用命令\n\n| 命令         | 说明                    |\n| ------------ | ----------------------- |\n| hset         | 设置一个key/value对     |\n| hget         | 获得一个key对应的value  |\n| hgetall      | 获得所有的key/value对   |\n| hdel         | 删除某一个key/value对   |\n| hexists      | 判断一个key是否存在     |\n| hkeys        | 获得所有的key           |\n| hvals        | 获得所有的value         |\n| hmset        | 设置多个key/value       |\n| hmget        | 获得多个key的value      |\n| hsetnx       | 设置一个不存在的key的值 |\n| hincrby      | 为value进行加法运算     |\n| hincrbyfloat | 为value加入浮点值       |\n\n---\n\n## 9. 持久化机制\n\nclient  redis[内存] ----->  内存数据- 数据持久化-->磁盘\n\nRedis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:\n\n- 快照(Snapshot)\n- AOF (Append Only File) 只追加日志文件\n\n### 9.1 快照(Snapshot)\n\n#### 1. 特点\n\n这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是**redis的默认开启持久化方式**,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。\n\n<img width=\"700px\" src=\"image-20200623204303074.png\" />\n\n#### 2.快照生成方式\n\n- 客户端方式: BGSAVE 和 SAVE指令\n- 服务器配置自动触发\n\n```markdown\n# 1.客户端方式之BGSAVE\n- a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。\n\t\n\t`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务`\n```\n\n<img width=\"700px\" src=\"image-20200623205132460.png\" />\n\n```markdown\n# 2.客户端方式之SAVE\n- b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令\n```\n\n<img width=\"700px\" src=\"image-20200623205444101.png\" />\n\n- **注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务**\n\n```markdown\n# 3.服务器配置方式之满足配置自动触发\n- 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令\n```\n\n<img width=\"700px\" src=\"image-20200623210021012.png\" />\n\n```markdown\n# 4.服务器接收客户端shutdown指令\n- 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器\n```\n\n#### 3.配置生成快照名称和位置\n\n```markdown\n#1.修改生成快照名称\n- dbfilename dump.rdb\n\n# 2.修改生成位置\n- dir ./\n```\n\n<img width=\"700px\" src=\"image-20200623210352448.png\" />\n\n----\n\n### 9.2 AOF 只追加日志文件\n\n#### 1.特点\n\n这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.\n\n<img width=\"700px\" src=\"image-20200623211330798.png\" />\n\n#### 2.开启AOF持久化\n\n在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启\n\n```markdown\n# 1.开启AOF持久化\n- a.修改 appendonly yes 开启持久化\n- b.修改 appendfilename \"appendonly.aof\" 指定生成文件名称\n```\n\n<img width=\"700px\" src=\"image-20200623211508987.png\" />\n\n#### 3.日志追加频率\n\n```markdown\n# 1.always 【谨慎使用】\n- 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度\n- 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;\n- 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;\n- 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。\n\n# 2.everysec 【推荐】\n- 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘\n- 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。\n\n# 3.no\t【不推荐】\n- 说明: 由操作系统决定何时同步 \n- 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。\n```\n\n#### 4.修改同步频率\n\n```markdown\n# 1.修改日志同步频率\n- 修改appendfsync everysec|always|no 指定\n```\n\n<img width=\"700px\" src=\"image-20200623211658910.png\" />\n\n----\n\n### 9.3 AOF文件的重写\n\n#### 1. AOF带来的问题\n\nAOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。\n\n#### 2. AOF重写\n\n用来在一定程度上减小AOF文件的体积\n\n#### 3. 触发重写方式\n\n```markdown\n# 1.客户端方式触发重写\n- 执行BGREWRITEAOF命令  不会阻塞redis的服务\n\n# 2.服务器配置方式自动触发\n- 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓\n- 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大\n```\n\n<img width=\"700px\" src=\"image-20200623212547775.png\" />\n\n#### 4. 重写原理\n\n **注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。**\n\n```markdown\n# 重写流程\n- 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令\n- 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。\n- 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。\n- 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。\n```\n\n<img width=\"700px\" src=\"image-20200623214843123.png\" />\n\n----\n\n### 9.4 持久化总结\n\n两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。\n\n无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。\n\n---\n\n## 10. java操作Redis\n\n### 10.1 环境准备\n\n#### 1. 引入依赖\n\n```xml\n<!--引入jedis连接依赖-->\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.9.0</version>\n</dependency>\n```\n\n#### 2.创建jedis对象\n\n```java\n public static void main(String[] args) {\n   //1.创建jedis对象\n   Jedis jedis = new Jedis(\"192.168.40.4\", 6379);//1.redis服务必须关闭防火墙  2.redis服务必须开启远程连接\n   jedis.select(0);//选择操作的库默认0号库\n   //2.执行相关操作\n   //....\n   //3.释放资源\n   jedis.close();\n }\n```\n\n<img width=\"700px\" src=\"image-20200623201932000.png\" />\n\n### 10.2 操作key相关API\n\n```java\nprivate Jedis jedis;\n    @Before\n    public void before(){\n        this.jedis = new Jedis(\"192.168.202.205\", 7000);\n    }\n    @After\n    public void after(){\n        jedis.close();\n    }\n\n    //测试key相关\n    @Test\n    public void testKeys(){\n        //删除一个key\n        jedis.del(\"name\");\n        //删除多个key\n        jedis.del(\"name\",\"age\");\n\n        //判断一个key是否存在exits\n        Boolean name = jedis.exists(\"name\");\n        System.out.println(name);\n\n        //设置一个key超时时间 expire pexpire\n        Long age = jedis.expire(\"age\", 100);\n        System.out.println(age);\n\n        //获取一个key超时时间 ttl\n        Long age1 = jedis.ttl(\"newage\");\n        System.out.println(age1);\n\n        //随机获取一个key\n        String s = jedis.randomKey();\n\n        //修改key名称\n        jedis.rename(\"age\",\"newage\");\n\n        //查看可以对应值的类型\n        String name1 = jedis.type(\"name\");\n        System.out.println(name1);\n        String maps = jedis.type(\"maps\");\n        System.out.println(maps);\n    }\n```\n\n<img width=\"700px\" src=\"image-20200627180325687.png\" />\n\n### 10.3操作String相关API\n\n```java\n//测试String相关\n    @Test\n    public void testString(){\n        //set\n        jedis.set(\"name\",\"小陈\");\n        //get\n        String s = jedis.get(\"name\");\n        System.out.println(s);\n        //mset\n        jedis.mset(\"content\",\"好人\",\"address\",\"海淀区\");\n        //mget\n        List<String> mget = jedis.mget(\"name\", \"content\", \"address\");\n        mget.forEach(v-> System.out.println(\"v = \" + v));\n        //getset\n        String set = jedis.getSet(\"name\", \"小明\");\n        System.out.println(set);\n\n        //............\n    }\n```\n\n<img width=\"700px\" src=\"image-20200627180352953.png\" />\n\n### 10.4操作List相关API\n\n```java\n//测试List相关\n    @Test\n    public void testList(){\n\n        //lpush\n        jedis.lpush(\"names1\",\"张三\",\"王五\",\"赵柳\",\"win7\");\n\n        //rpush\n        jedis.rpush(\"names1\",\"xiaomingming\");\n\n        //lrange\n\n        List<String> names1 = jedis.lrange(\"names1\", 0, -1);\n        names1.forEach(name-> System.out.println(\"name = \" + name));\n\n        //lpop rpop\n        String names11 = jedis.lpop(\"names1\");\n        System.out.println(names11);\n\n        //llen\n        jedis.linsert(\"lists\", BinaryClient.LIST_POSITION.BEFORE,\"xiaohei\",\"xiaobai\");\n\n      \t//........\n\n    }\n\n```\n\n<img width=\"700px\" src=\"image-20200627180435997.png\" />\n\n### 10.5操作Set的相关API\n\n```java\n//测试SET相关\n@Test\npublic void testSet(){\n\n  //sadd\n  jedis.sadd(\"names\",\"zhangsan\",\"lisi\");\n\n  //smembers\n  jedis.smembers(\"names\");\n\n  //sismember\n  jedis.sismember(\"names\",\"xiaochen\");\n\n  //...\n}\n```\n\n<img width=\"700px\" src=\"image-20200627181913715.png\" />\n\n### 10.6 操作ZSet相关API\n\n```java\n//测试ZSET相关\n@Test\npublic void testZset(){\n\n  //zadd\n  jedis.zadd(\"names\",10,\"张三\");\n\n  //zrange\n  jedis.zrange(\"names\",0,-1);\n\n  //zcard\n  jedis.zcard(\"names\");\n\n  //zrangeByScore\n  jedis.zrangeByScore(\"names\",\"0\",\"100\",0,5);\n\n  //..\n\n}\n```\n\n<img width=\"700px\" src=\"image-20200627181947116.png\" />\n\n### 10.7 操作Hash相关API\n\n```java\n//测试HASH相关\n@Test\npublic void testHash(){\n  //hset\n  jedis.hset(\"maps\",\"name\",\"zhangsan\");\n  //hget\n  jedis.hget(\"maps\",\"name\");\n  //hgetall\n  jedis.hgetAll(\"mps\");\n  //hkeys\n  jedis.hkeys(\"maps\");\n  //hvals\n  jedis.hvals(\"maps\");\n  //....\n}\n```\n\n<img width=\"700px\" src=\"image-20200628093242527.png\" />\n\n----\n\n## 11.SpringBoot整合Redis\n\nSpring Boot Data(数据) Redis 中提供了**RedisTemplate和StringRedisTemplate**，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，**RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。**\n\n`注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口`\n\n### 11.1 环境准备\n\n#### 1.引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n#### 2.配置application.propertie\n\n```properties\nspring.redis.host=localhost\nspring.redis.port=6379\nspring.redis.database=0\n```\n\n### 11.2 使用StringRedisTemplate和RedisTemplate\n\n```java\n\t\t@Autowired\n    private StringRedisTemplate stringRedisTemplate;  //对字符串支持比较友好,不能存储对象\n    @Autowired\n    private RedisTemplate redisTemplate;  //存储对象\n\n    @Test\n    public void testRedisTemplate(){\n        System.out.println(redisTemplate);\n        //设置redistemplate值使用对象序列化策略\n        redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());//指定值使用对象序列化\n        //redisTemplate.opsForValue().set(\"user\",new User(\"21\",\"小黑\",23,new Date()));\n        User user = (User) redisTemplate.opsForValue().get(\"user\");\n        System.out.println(user);\n//      Set keys = redisTemplate.keys(\"*\");\n//      keys.forEach(key -> System.out.println(key));\n        /*Object name = redisTemplate.opsForValue().get(\"name\");\n        System.out.println(name);*/\n\n        //Object xiaohei = redisTemplate.opsForValue().get(\"xiaohei\");\n        //System.out.println(xiaohei);\n        /*redisTemplate.opsForValue().set(\"name\",\"xxxx\");\n        Object name = redisTemplate.opsForValue().get(\"name\");\n        System.out.println(name);*/\n        /*redisTemplate.opsForList().leftPushAll(\"lists\",\"xxxx\",\"1111\");\n        List lists = redisTemplate.opsForList().range(\"lists\", 0, -1);\n        lists.forEach(list-> System.out.println(list));*/\n    }\n\n\n    //key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key\n    //boundValueOps 用来对String值绑定key\n    //boundListOps 用来对List值绑定key\n    //boundSetOps 用来对Set值绑定key\n    //boundZsetOps 用来对Zset值绑定key\n    //boundHashOps 用来对Hash值绑定key\n\n    @Test\n    public void testBoundKey(){\n        BoundValueOperations<String, String> nameValueOperations = stringRedisTemplate.boundValueOps(\"name\");\n        nameValueOperations.set(\"1\");\n        //yuew\n        nameValueOperations.set(\"2\");\n        String s = nameValueOperations.get();\n        System.out.println(s);\n\n    }\n\n\n    //hash相关操作 opsForHash\n    @Test\n    public void testHash(){\n        stringRedisTemplate.opsForHash().put(\"maps\",\"name\",\"小黑\");\n        Object o = stringRedisTemplate.opsForHash().get(\"maps\", \"name\");\n        System.out.println(o);\n    }\n\n    //zset相关操作 opsForZSet\n    @Test\n    public void testZSet(){\n        stringRedisTemplate.opsForZSet().add(\"zsets\",\"小黑\",10);\n        Set<String> zsets = stringRedisTemplate.opsForZSet().range(\"zsets\", 0, -1);\n        zsets.forEach(value-> System.out.println(value));\n    }\n\n    //set相关操作 opsForSet\n    @Test\n    public void testSet(){\n        stringRedisTemplate.opsForSet().add(\"sets\",\"xiaosan\",\"xiaosi\",\"xiaowu\");\n        Set<String> sets = stringRedisTemplate.opsForSet().members(\"sets\");\n        sets.forEach(value-> System.out.println(value));\n    }\n\n    //list相关的操作opsForList\n    @Test\n    public void testList(){\n        // stringRedisTemplate.opsForList().leftPushAll(\"lists\",\"张三\",\"李四\",\"王五\");\n        List<String> lists = stringRedisTemplate.opsForList().range(\"lists\", 0, -1);\n        lists.forEach(key -> System.out.println(key));\n    }\n\n\n    //String相关的操作 opsForValue\n    @Test\n    public void testString(){\n        //stringRedisTemplate.opsForValue().set(\"166\",\"好同学\");\n        String s = stringRedisTemplate.opsForValue().get(\"166\");\n        System.out.println(s);\n        Long size = stringRedisTemplate.opsForValue().size(\"166\");\n        System.out.println(size);\n    }\n\n\n    //key相关的操作\n    @Test\n    public void test(){\n        Set<String> keys = stringRedisTemplate.keys(\"*\");//查看所有key\n        Boolean name = stringRedisTemplate.hasKey(\"name\");//判断某个key是否存在\n        stringRedisTemplate.delete(\"age\");//根据指定key删除\n        stringRedisTemplate.rename(\"\",\"\");//修改key的名称\n        stringRedisTemplate.expire(\"key\",10, TimeUnit.HOURS);\n      \t//设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位\n        stringRedisTemplate.move(\"\",1);//移动key\n    }\n```\n\n---\n\n## 12. Redis 主从复制\n\n### 12.1 主从复制\n\n主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据\n\n**无法解决: 1.master节点出现故障的自动故障转移**\n\n### 12.2 主从复制架构图\n\n<img width=\"700px\" src=\"image-20200627201722700.png\" />\n\n### 12.3 搭建主从复制\n\n```markdown\n# 1.准备3台机器并修改配置\n- master\n\tport 6379\n\tbind 0.0.0.0\n\t\n- slave1\n\tport 6380\n\tbind 0.0.0.0\n\tslaveof masterip masterport\n\n- slave2\n\tport 6381\n\tbind 0.0.0.0\n\tslaveof masterip masterport\n```\n\n<img width=\"700px\" src=\"image-20200627202443388.png\" />\n\n```markdown\n# 2.启动3台机器进行测试\n- cd /usr/redis/bin\n- ./redis-server /root/master/redis.conf\n- ./redis-server /root/slave1/redis.conf\n- ./redis-server /root/slave2/redis.conf\n```\n\n---\n\n## 13. Redis哨兵机制\n\n### 13.1 哨兵Sentinel机制\n\nSentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有**自动故障转移功能的主从架构**。\n\n**无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限**\n\n### 13.2 哨兵架构原理\n\n<img width=\"700px\" src=\"image-20200627204422750.png\" />\n\n### 13.3 搭建哨兵架构\n\n```markdown\n# 1.在主节点上创建哨兵配置\n- 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；\n\n# 2.配置哨兵，在sentinel.conf文件中填入内容：\n- sentinel monitor 被监控数据库名字（自己起名字） ip port 1\n\n# 3.启动哨兵模式进行测试\n- redis-sentinel  /root/sentinel/sentinel.conf\n\t说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。\n```\n\n### 13.4 通过springboot操作哨兵\n\n```properties\n# redis sentinel 配置\n# master书写是使用哨兵监听的那个名称\nspring.redis.sentinel.master=mymaster\n# 连接的不再是一个具体redis主机,书写的是多个哨兵节点\nspring.redis.sentinel.nodes=192.168.202.206:26379\n```\n\n- **注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)**\n- **解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限**\n\n<img width=\"700px\" src=\"image-20200629154647970.png\" />\n\n## 14. Redis集群\n\n### 14.1 集群\n\nRedis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持节点的自动发现,支持slave-master选举和容错,支持在线分片(sharding shard )等特性。reshard\n\n### 14.2 <img width=\"700px\" src=\"wpsgRnQP8.jpg)\" />\n### 14.3 集群细节\n\n```markdown\n- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.\n- 节点的fail是通过集群中超过半数的节点检测失效时才生效. \n- 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可\n- redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->value\n```\n\n<img width=\"700px\" src=\"image-20200629165226329.png\" />\n\n### 14.4 集群搭建\n\n判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数，**搭建集群至少需要三个主节点,三个从节点,至少需要6个节点**。\n\n```markdown\n# 1.准备环境安装ruby以及redis集群依赖\n- yum install -y ruby rubygems\n- gem install redis-xxx.gem\n\n```\n\n<img width=\"700px\" src=\"image-20200627193219366.png\" />\n\n<img width=\"700px\" src=\"image-20200627193348905.png\" />\n\n```markdown\n# 2.在一台机器创建7个目录\n```\n\n<img width=\"700px\" src=\"image-20200627193849867.png\" />\n\n```markdown\n# 3.每个目录复制一份配置文件\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/\n[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/\n```\n\n<img width=\"700px\" src=\"image-20200627194103354.png\" />\n\n```markdown\n# 4.修改不同目录配置文件\n- port \t6379 .....                \t\t //修改端口\n- bind  0.0.0.0                   \t\t //开启远程连接\n- cluster-enabled  yes \t        \t\t\t //开启集群模式\n- cluster-config-file  nodes-port.conf //集群节点配置文件\n- cluster-node-timeout  5000      \t   //集群节点超时时间\n- appendonly  yes   \t\t               //开启AOF持久化\n\n# 5.指定不同目录配置文件启动七个节点\n- [root@localhost bin]# ./redis-server  /root/7000/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7001/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7002/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7003/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7004/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7005/redis.conf\n- [root@localhost bin]# ./redis-server  /root/7006/redis.conf\n```\n\n<img width=\"700px\" src=\"image-20200627194913866.png\" />\n\n```markdown\n# 6.查看进程\n- [root@localhost bin]# ps aux|grep redis\n```\n\n<img width=\"700px\" src=\"image-20200627194954143.png\" />\n\n#### 1.创建集群\n\n```markdown\n# 1.复制集群操作脚本到bin目录中\n- [root@localhost bin]# cp /root/redis-4.0.10/src/redis-trib.rb .\n\n# 2.创建集群\n- ./redis-trib.rb create --replicas 1 192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005\n```\n\n<img width=\"700px\" src=\"image-20200627195601307.png\" />\n\n```markdown\n# 3.集群创建成功出现如下提示\n```\n\n<img width=\"700px\" src=\"image-20200627195647767.png\" />\n\n#### 2.查看集群状态\n\n```markdown\n# 1.查看集群状态 check [原始集群中任意节点] [无]\n- ./redis-trib.rb check 192.168.202.205:7000\n\n# 2.集群节点状态说明\n- 主节点 \n\t主节点存在hash slots,且主节点的hash slots 没有交叉\n\t主节点不能删除\n\t一个主节点可以有多个从节点\n\t主节点宕机时多个副本之间自动选举主节点\n\n- 从节点\n\t从节点没有hash slots\n\t从节点可以删除\n\t从节点不负责数据的写,只负责数据的同步\n```\n\n#### 3.添加主节点\n\n```markdown\n# 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]\n- ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005\n- 注意:\n\t1.该节点必须以集群模式启动\n\t2.默认情况下该节点就是以master节点形式添加\n```\n\n#### 4.添加从节点\n\n```markdown\n# 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]\n- ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000\n- 注意:\n\t当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点\n\t\n# 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]\n- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000\n```\n\n#### 5.删除副本节点\n\n```markdown\n# 1.删除节点 del-node [集群中任意节点] [删除节点id]\n- ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1\n- 注意:\n 1.被删除的节点必须是从节点或没有被分配hash slots的节点\n```\n\n#### 6.集群在线分片\n\n```markdown\n# 1.在线分片 reshard [集群中任意节点] [无]\n- ./redis-trib.rb  reshard  192.168.1.158:7000\n```\n\n----\n\n## 15.Redis实现分布式Session管理\n\n### 15.1 管理机制\n\n**redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据。**\n\n<img width=\"700px\" src=\"image-20200628201643358.png\" />\n\n### 15.2 开发Session管理\n\n#### 1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.session</groupId>\n  <artifactId>spring-session-data-redis</artifactId>\n</dependency>\n```\n\n#### 2. 开发Session管理配置类\n\n```java\n@Configuration\n@EnableRedisHttpSession\npublic class RedisSessionManager {\n   \n}\n```\n\n#### 3.打包测试即可\n\n----\n\n\n\n","tags":["database","redis"],"categories":["database","redis"]},{"title":"Linux study Record","url":"/2020/08/21/Linux-Study-Record/","content":"\n\n\n# CentOS 7 安装完成后初始化配置\n\n## 网络配置\n\n```linux\n# 通过下面命令查询机器的网卡名\nip addr\n\nvi /etc/sysconfig/network-scripts/ifcfg-eth0\n\nTYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=dhcp\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=eth0\nUUID=c342a3ec-d2f5-48f9-a858-6dae42718cc5\nDEVICE=eth0\nONBOOT=yes\t# 开机自动启动网卡\n```\n\n\n\n","tags":["linux"]},{"title":"《尚硅谷Mycat教程》study notes","url":"/2020/08/21/《尚硅谷Mycat教程》study-notes/","content":"\n\n\n# 环境准备\n\n>  linux （CentOS-7-x86_64-DVD-2003.iso）\n\n# MyCat下载与安装\n\n```linux\ncd /opt\nwget http://dl.mycat.org.cn/1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz\n\n# z 按照gzip筛选； x 解压操作；v 显示信息； f 指定文件\n\ntar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz\n\n# -r 递归拷贝\ncp -r mycat/ /usr/local/\n```\n\n- 三个配置文件\n\n> schema.xml:定义逻辑库，表、分片节点等内容 \n>\n> rule.xml:定义分片规则 \n>\n> server.xml:定义用户以及系统相关变量，如端口等\n\n# MyCat启动\n\n- 修改配置文件\n\n```linux\n# 修改 /mycat/conf/server.xml user为mycat\n\n<user name=\"user\">\n\t\t<property name=\"password\">user</property>\n\t\t<property name=\"schemas\">TESTDB</property>\n\t\t<property name=\"readOnly\">true</property>\n\t</user>\n```\n\n","tags":["mysql","mycat"],"categories":["mysql","mycat"]},{"title":"《MyCAT+MySQL 搭建高可用企业级数据库集群》study notes","url":"/2020/08/20/《MyCAT-MySQL-搭建高可用企业级数据库集群》study-notes/","content":"\n\n\n# MyCat简介\n\n​\t\tMyCat 是目前最流行的`基于 java` 语言编写的`数据库中间件`，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是`分库分表`。配合数据库的主从模式还可实现`读写分离`。\n  \tMyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。\n\n<br>\n\n<img width=\"700px\" src=\"WechatIMG203.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG204.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG205.png\" /><br>\n\n## MyCat主要作用\n\n<img width=\"700px\" src=\"WechatIMG206.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG207.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG208.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG209.png\" /><br>\n\n## MyCat的基本元素\n\n<img width=\"700px\" src=\"WechatIMG210.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG211.png\" /><br>\n\n\n\n# MyCat安装\n\n## 安装步骤\n\n<img width=\"700px\" src=\"WechatIMG212.png\" /><br>\n\n- 下载安装mycat\n\n```linux\ncd /usr/local\n\nwget http://dl.mycat.org.cn/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz\n\ntar zxf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz\n\nchown mycat:mycat -R mycat/\n```\n\n- 下载安装jdk\n\n```linux\ncd /usr/local\n\nwget https://repo.huaweicloud.com/java/jdk/7u80-b15/jdk-7u80-linux-x64.tar.gz\n\ntar zxf jdk-7u80-linux-x64.tar.gz\n\nmkdir /usr/local/java\n\nmv ./jdk1.7.0_80/ /usr/local/java\n```\n\n- Add user\n\n```linux\nadduser mycat\n```\n\n- 修改mycat运行内存\n\n```linux\n# mycat目录下的 conf/wrapper.conf 文件配置了mycat运行所需要的内存大小\nwrapper.java.additional.5=-XX:MaxDirectMemorySize=2G\n\nfree -m # 查看linux的内存\n\nvi wrapper.conf\n\nwrapper.java.additional.5=-XX:MaxDirectMemorySize=256M\n```\n\n- 配置环境变量\n\n```linux\nvim /etc/profile\n\nexport PATH=$PATH:/usr/local/mycat/bin:/usr/local/java/jdk1.7.0_80/bin\n\nexport JAVA_HOME=/usr/local/java/jdk1.7.0_80\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n\nexport MYCAT_HOME=/usr/local/mycat\n\nsource /etc/profile\n\n# 验证jdk是否安装成功\njava -version\n```\n\n- mycat\n\n```linux\nmycat start \n\n# mycat/logs/wrapper.log 记录了启动信息\n```\n\n\n\n\n\n# 课程实例使用的数据库对象\n\n<img width=\"700px\" src=\"WechatIMG199.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG200.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG201.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG202.png\" /><br>\n\n\n\n# MyCat配置文件\n\n<img width=\"700px\" src=\"WechatIMG213.png\" /><br>\n\n## server.xml\n\n- 配置系统相关参数\n- 配置用户访问权限\n- 配置SQL防火墙以及SQL拦截功能\n\n\n\n\n\n","tags":["mysql","mycat"],"categories":["mysql","mycat"]},{"title":"《一站式学习Redis 从入门到高可用分布式实践》study notes","url":"/2020/08/06/《一站式学习Redis-从入门到高可用分布式实践》study-notes/","content":"\n# 学习备注\n\n> 1、熟悉终端相关的api\n>\n> 2、熟悉jedis和jedis连接池的使用\n\n# redis初识\n\n## redis是什么\n\n`开源` `基于健值的存储服务系统`  `多种数据结构` `高性能、功能丰富`\n\n## redis特性\n\n`速度快（官方：10w QPS）`\n\n> **数据存在内存中**（速度快的主要原因）\n>\n> C语言编写\n>\n> 单线程\n\n`持久化（断电不丢数据）`\n\n> redis所有数据保存在内存中，对数据的更新将异步的保存到磁盘上\n\n`多种数据结构` `支持多种编程语言` `功能丰富` `简单` `主从复制` `高可用、分布式`\n\n## redis适用场景\n\n缓存系统\t计数器\t消息队列系统\t排行榜\t社交网络\t实时系统\n\n## redis实验环境搭建\n\n### 环境准备\n\nCentos7 \n\n### redis下载与安装\n\n```sh\n# 确保wget可以使用\n# 下载相关依赖库\nyum install wget gcc-c++ -y\n\n# 下载redis 并建立软链接 然后编译安装redis\nmkdir -p /opt/soft && cd /opt/soft &&\twget https://mirrors.huaweicloud.com/redis/redis-3.0.7.tar.gz && tar -zxvf redis-3.0.7.tar.gz && ln -s redis-3.0.7 redis && cd redis && make && make install\n\n\ncd src && ll | grep redis-\n```\n\n### 启动方式一：最简启动\n\n```shell\n# 在任意目录下启动redis（默认启动方式，非守护进程）\nredis-server\n```\n\n### 启动方式二：动态参数启动\n\n```shell\n# 动态参数启动redis\nredis-server --port 6380\n\n# 在任意目录下使用redis客户端连接redis\nredis-cli -h 127.0.0.1 -p 6379\n```\n\n### 启动方式三：配置文件方式启动（建议在生产环境使用这种方式，更便于管理）\n\n#### 准备工作\n\n```shell\ncd /opt/soft/redis && mkdir config && cp redis.conf config && cd config && mv redis.conf redis-6381.conf\n\n# 查看配置的时候去除空格和注释\ncat redis-6381.conf | grep -v \"#\" | grep -v \"^$\"\n\ncat redis-6381.conf | grep -v \"#\" | grep -v \"^$\" > redis-6382.conf\n```\n\n```sh\nvim redis-6382.conf\n\n# 是否以守护进程的方式启动\ndaemonize yes \n# pidfile /var/run/redis.pid # 进程号存储位置，实际上还是需要用端口号进行区别\n# 端口号\nport 6382\t\n# 工作目录\ndir \"/opt/soft/redis/data\" \nlogfile \"6382.log\"\n```\n\n```shell\ncd /opt/soft/redis && mkdir data\n```\n\n#### 配置文件方式启动\n\n```shell\nredis-server config/redis-6382.conf\n\n# 查看进程\nps -ef | grep redis-server | grep 6382\n\n# 查看日志\ncd data && cat 6382.log\n```\n\n### 三种启动方式比较\n\n- 生产环境选择配置文件启动\n- 单机多实例配置文件可以用端口区分开\n\n# Redis API的理解和使用\n\n- 通用命令\n- 字符串类型\n- 哈希类型\n- 列表类型\n- 集合类型\n- 有序集合类型\n\n## 通用命令\n\n```sh\n# 计算数据库中所有的健，一般不在生产环境使用，O(n)的命令\nkeys\nkeys [pariner]\n\n# 算出数据库的大小,O(1),有内置计数器\ndbsize\n\n# 判断一个key是否存在 返回 0 / 1 \tO(1)\nexists key\n\n# 删除多个key O(1)\ndel key [key...]\n\n# 设置key的过期时间 O(1)\nexpire key seconds\n\n# 查询key的过期时间,-1代表没有过期时间，-2 代表已经过期 \nttl key\n\n# 去掉 key 的过期时间\npersist key\n\n# key的类型，可以返回 String hash list set zset none O(1)\ntype key\n```\n\n## 数据结构和内部编码\n\n<img width=\"500px\" src=\"WechatIMG14.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG15.png\" /><br>\n\n## 单线程架构\n\n<img width=\"500px\" src=\"WechatIMG16.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG17.png\" /><br>\n\n<img width=\"500px\" src=\"WechatIMG18.png\" /><br>\n\n## 字符串\n\n- 对于redis来说所有的key都是字符串\n- value限制512M\n\n- 使用场景\n\n> 缓存、计数器、分布式锁\n\n- 字符串总结\n\n<img width=\"500px\" src=\"WechatIMG853.png\" />\n\n ## hash\n\n- 使用场景\n\n> 每个用户主页访问量\n\n- 与String对比\n\n<img width=\"500px\" src=\"WechatIMG854.png\" />\n\n- hash总结\n\n<img width=\"500px\" src=\"WechatIMG855.png\" />\n\n## list\n\n# redis客户端\n\n## jedis和jedis连接池\n\n<img width=\"500px\" src=\"WechatIMG470.png\" />\n\n<img width=\"500px\" src=\"WechatIMG471.png\" />\n\n<img width=\"500px\" src=\"WechatIMG856.png\" />\n\n## 资源池配置\n\n<img width=\"500px\" src=\"WechatIMG857.png\" />\n\n<img width=\"500px\" src=\"WechatIMG858.png\" />\n\n# 慢查询\n\n## 生命周期\n\n<img width=\"500px\" src=\"WechatIMG473.png\" />\n\n## 两个配置\n\n- `slowlog-log-slower-than` 选项指定执行时间超过多少微秒（`1` 秒等于 `1,000,000` 微秒）的命令请求会被记录到日志上。\n- `slowlog-max-len` 选项指定服务器最多保存多少条慢查询日志。\n\n> 服务器使用先进先出的方式保存多条慢查询日志： 当服务器储存的慢查询日志数量等于 `slowlog-max-len` 选项的值时， 服务器在添加一条新的慢查询日志之前， 会先将最旧的一条慢查询日志删除。\n\n- 可以使用修改配置文件重启\n- 动态配置\n\n```shell\n CONFIG SET slowlog-log-slower-than 1000\n CONFIG SET slowlog-max-len 5\n```\n\n## 慢查询命令\n\n``` shell\n# 获取慢查询队列\nslowlog get [n]\n\n# 获取慢查询队列长度\nslowlog len\n\n# 清空慢查询队列\nslowlog reset\n```\n\n## 运维经验\n\n- `slowlog-max-len` 默认10ms，通常设置1ms\n-  `slowlog-log-slower-than`不要设置过小，通常设置1000左右\n- 理解命令生命周期\n- 定期持久化慢查询\n\n\n\n---\n\n","tags":["database","redis"],"categories":["database","redis"]},{"title":"XML文件的读写","url":"/2020/07/29/XML文件的读写/","content":"\n\n\nXML 指可扩展标记语言（e**X**tensible **M**arkup **L**anguage）。\n\nXML 被设计用来传输和存储数据。\n\n","tags":["xml"]},{"title":"《Linux核心技能与应用》study notes","url":"/2020/07/24/《Linux核心技能与应用》study-notes/","content":"\n# 学习备注\n\n> 了解linux的各个目录的作用\n>\n> \n\n\n\n# 环境\n\n> Centos 7、VirtualBox、git、Apache、Nginx、Squid、Bash\n\n# 概念\n\n> `$` 代表普通用户，有权限限制\n>\n> `#` 拥有所有权限\n\n# 命令\n\n```shell\n# 切换为root用户\nsudo su\n\n# 日期\ndate\n\nhistory\n# 输入history回车后，可以使用`!编号`运行history编号对应的命令\n\n# 显示当前目录路径\npwd\n\n# 列出当前目录下的文件和目录\nls\n\n# a 表示 all\n# 显示所有的文件目录，包括隐藏文件\nls -a \nls --all\n\n# 显示详细信息 -h 按适合人阅读的方式\nls -l \nls -lh\n# 按修改时间降序排列\nls -t \n\n\n```\n\n\n\n# 快捷键\n\n```shell\n# tab补全补全命令\n# 上、下键\n\n# 清屏\nctrl + L / clean \n\nshift + 上/下键，相当于鼠标滚屏\n\nctrl + R # 查找之前使用过的命令\nctrl + D # 给文件传递EOF（end of file）文件结束符\n\nctrl + a # 光标跳到一行命令的开头\nctrl + E # 光标跳到一行命令的结尾\nctrl + U # 删除光标左侧的字符\nctrl + K # 删除光标右侧的字符\nctrl + W # 删除光标左侧的一个单词\nctrl + Y # 粘贴用 ctrl + U / ctrl + K / ctrl + W 删除的字符串\n\n\n# 获取命令的可执行文件的位置\nwhich\n例如：which pwd\n\n\n# 显示目录包含的文件大小\ndu\ndu -h\ndu -a\ndu -s\n\n# 一次显示文件所有内容\ncat \n# 显示行号 n 代表number\ncat -n\n# 分页显示\nless\nmore\nhead -n\ntail -n\n# 实时追踪更新的文件\ntail -f [file_name] # 默认每秒检查更新\ntail -f -s 4 [file_name] # 指定每隔4s检查更新\n# 例子 tail -n 6\n# 空格 读取下一页\n# d 前进半页\n# b 后退一页\n# y 后退一行\n# u 后退半夜\n# q 退出\n# = 显示当前页面在文件第几行\n# / 搜索模式 （n）跳到下一个符合项 （N/shifit + n） 跳到上一个符合项\n\n\ntouch\nmkdir\nmkdir -p a/b/c # 递归的创建目录\n\ncp file_name new_file_name\ncp -r # 递归的拷贝目录\n\nmv # 移动或重命名目录\n\n# 递归删除文件\nrm -rf\n\n# 创建链接\nln\n\n# 硬链接、软链接\nln file1 file2 # 创建硬链接\nln -s file1 file2 # 创建软链接\n\n\nlocate [file_name]\n\n```\n\n# 用户管理\n\n```shell\n# root 默认创建/超级用户\n# 暂时称为root用户/权限\nsudo su\n\n# 切换到root用户\nsu -\n\n# 添加用户\nadduser [user_name]\n\n# 修改密码\npasswd thomas\n\n# 删除用户，并删除其目录\nuserdel -r thomas\n\n# 修改用户群组\nusermod -g [group_name] [user_name]\n\ngroupadd\n\ngroupdel\n\n# 改变文件群组\nchown [user_name] [file_name]\n\nchgrp [user_name] [file_name]\n# 修改访问权限\nchmod 600 [file_name]\n```\n\n\n\n- grep命令：筛选数据\n\n```linux\ngrep text file\t# 在file文件中搜索'text'文字，区分大小写\n\ngrep -i text file # 忽略大小写\n\ngrep -n text file # -n 显示行号\n\n# -v 显示文本不包含字符串的行\n# -r 在所有的子文件子目录中查找（递归查找）\n\n# rgrep 相当于grep -r\n\n# -E 或 --extended-regexp : 将样式为延伸的正则表达式来使用\n```\n\n","tags":["linux"],"categories":["linux"]},{"title":"《MySQL必知必会》read notes","url":"/2020/07/22/《MySQL必知必会》read-notes/","content":"\n\n\n- 学习备注\n\n  > mysql 正则这块不是很熟悉\n\n  \n\n---\n\n# 数据库基础知识\n\n- 数据库(database) \n\n> 保存有组织的数据的容器(通常是一个文 件或一组文件)。\n>\n> 数据库软件应称为DBMS(数据库管理系统)。数据库 是通过DBMS创建和操纵的容器。\n\n- 表(table)： 某种特定类型数据的结构化清单\n- 列(column) ：表中的一个字段\n- 数据类型(datatype) ：所容许的数据的类型。每个表列都有相 应的数据类型，它限制(或容许)该列中存储的数据\n- 行(row)： 表中的一个记录\n- 主键(primary key)：一列(或一组列)，其值能够唯一区分表 中每个行\n- SQL(Structured Query Language)：SQL是一种专门用来与数据库通信的语言\n\n# 使用MySQL\n\n```mysql\nUSE [database_name]\n\nSHOW DATABASES;\n\nSHOW TABLES;\n\nSHOW COLUMNS FROM customers;\n\nSHOW STATUS # 用于显示广泛的服务器状态信息;\n\nSHOW CREATE DATABASE\n\nSHOW CREATE TABLE\n\nSHOW GRANTS\n\nSHOW ERRORS;\nSHOW WARNINGS;\n# 用来显示服务器错误或警告消息\n```\n\n\n\n# SELECT\n\n```mysql\n\nselect * from [table_name];\n\nselect distinct id,name from [table_name]; # 作用于所有列\n\nselect id from [table_name] limit 5;\n\nselect id from [table_name] limit 5; # 返回从第5行开始的5行\n\n# 检索出来的第一行为行0而不是行1。因此，LIMIT1,1 将检索出第二行而不是第一行\n\nselect name,id from [table_name] order by name,id;\n\n# order by ,默认升序，ASC 升序，DESC 降序\n\n```\n\n# WHERE\n\n```mysql\n# where 子句操作符\n=\n<>\n!=\n<\n<=\n>\n>=\nBETWEEN\n\n# BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。\nselect prod_price from [table_name] where prod_price between 5 and 10;\n\nIS NULL\n\nAND 的计算次序高于 OR\n\nIN\nNOT IN\n\n# 通配符 % _\n\nlike '1000'\nregexp '1000'\n\n# LIKE匹配整个列。如果被匹配的文本在列值 中出现，LIKE将不会找到它，相应的行也不被返回(除非使用 通配符)。而REGEXP在列值内进行匹配，如果被匹配的文本在 列值中出现，REGEXP将会找到它，相应的行将被返回。\n\n# |为正则表达式的OR操作 符。它表示匹配其中之一\n```\n\n\n\n# 计算字段\n\n```mysql\nconcat()\n\nLeft() 返回串左边的字符\nLength() 返回串的长度\nLocate() 找出串的一个子串\nLower() 将串转换为小写\nLTrim() 去掉串左边的空格\nRight() 返回串右边的字符\nRTrim() 去掉串右边的空格\nSoundex() 返回串的SOUNDEX值\nSubString() 返回子串的字符\nUpper() 将串转换为大写\n\n\n# 数值处理\nAbs() 返回一个数的绝对值\nRand() 返回一个随机数\nSqrt() 返回一个数的平方根\n\nAVG() 返回某列的平均值\nCOUNT() 返回某列的行数\nMAX() 返回某列的最大值\nMIN() 返回某列的最小值\nSUM() 返回某列值之和\n\n# 使用COUNT(column)对特定列中具有值的行进行计数，忽略 NULL值\n\n\n```\n\n<br>\n\n```mysql\nHAVING 和 WHERE 的差别:\n这里有另一种理解方法，WHERE在数据 分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重 要的区别，WHERE排除的行不包括在分组中。\n```\n\n\n\n- Select 子句顺序\n\n```mysql\nselect\nfrom\nwhere\ngroup by\nhaving\norder by\nlimit\n```\n\n<br>\n\n```mysql\nUNION\nUNION ALL\n\nmath() against()\n```\n\n# INSERT\n\n```mysql\ninsert into values (),();\ninsert into values select * from [table_name]\n```\n\n\n\n# UPDATE\n\n```mysql\nupdate [table_name] set name='',age=18 where id='1';\n\nupdate ignore [table_name] ... # 如果某条语句出错，则 取消所有更新\n```\n\n\n\n# DELETE\n\n```mysql\ndelete from [table_name] where id='1';\n\ndelete from [table_name];\ntruncate from [table_name];\n```\n\n\n\n# CREATE\n\n```mysql\ncreate table [table_name] {\n\tid int auto_increment,\n\tname char(50),\n\tprimary key(id)\n\t\n} engine =InnoDB\n```\n\n\n\n# ALTER\n\n```mysql\nalter table [table_name] add tel char(20);\n\nalter table [table_name] drop column [age];\n\ndrop table [table_name]\n\nrename table [table_name] to [table_name1]\n\n```\n\n\n\n# VIEW\n\n```mysql\ncreate view [view_name] as select * from [table_name]\n\nshow create view [view_name];\n\ndrop view [view_name];\n```\n\n\n\n# 存储过程\n\n```mysql\ncreate procedure getDate()\n  begin\n    select now();\n  end;\n  \n \ncall getDate();\n\ndrop procedure getDate;\n\nshow create procedure getDate;\n```\n\n","tags":["mysql","database","read-notes"],"categories":["mysql","database","read-notes"]},{"title":"新锐台球教程 study notes","url":"/2020/07/21/新锐台球教程-study-notes/","content":"\n\n\n# 台球入门教学-击球动作和出杆（一级）\n\n- 手架\n\n> 放稳：手掌不要悬空，小臂放在台面上，小臂不要太直，不需要太用力\n>\n> 距离：适中，不要太近，也不要太远\n\n- 握杆\n\n> 虎口贴住球杆，拇指和食指握住球杆，其他指头轻轻贴住球杆\n>\n> **后手放松**\n>\n> 一松一合\n\n- 站位\n\n> 右脚脚后跟站到击球线上\n>\n> 入位\n\n- 俯身\n\n- 运杆\n\n> 通过小臂摆动找到击球的感觉\n>\n> 前停，后停\n\n- 练习直球\n\n> 固定站位，手架，运杆节奏\n\n## 练习\n\n1. 五分点直球，连续进球\n2. 中线摆放15颗球，练习进球\n\n","tags":["台球"],"categories":["台球"]},{"title":"牛课网算法初级班课程 study notes","url":"/2020/07/20/牛课网算法初级班课程-study-notes/","content":"\n","tags":["algorithm","data-structure"],"categories":["algorithm","data-structure"]},{"title":"《MySQL 8.0详解与实战》study notes","url":"/2020/07/02/《MySQL-8-0详解与实战》study-notes/","content":"\n- 学习备注与扩展\n\n> 1. 数据库需求分析，设计这块，后续需要自己跟着老师的设计进行思考，再学习一遍。（第三章前面部分）\n> 2. 需要熟悉各个常见MySQL引擎，了解使用场景，优缺点等等。\n> 3. 熟悉（记忆、理解）三范式\n> 4. 学习了解一下课程中创建的表\n\n- 学习环境\n\n> MySQL8.0.15、CentOS7、SQLyog\n\n\n\n# 数据库选型\n\n## SQL（关系型数据库）\n\n- MySQL、oracle、SQLServer、PostGreSQL\n\n- 特点\n\n  1. 数据结构化存储在二维表中\n\n  2. 支持事物的ACID特性\n\n  3. 支持使用SQL语言对存储在其中的数据进行操作\n\n### 适用场景\n\n1. 数据之间存在着一定关系，需要关联查询数据的场景\n\n2. 需要事物支持业务场景\n\n3. 需要使用SQL语言灵活操作数据的场景\n\n## NOSQL（非关系型数据库）\n\n- HBase、MOngoDB、Redis、Hadoop\n\n- 特点\n  1. 存储结构灵活，没有固定的结构\n  2. 对事物的支持比较弱，但对数据的并发处理性能高\n  3. 大多不使用SQL语言操作数据\n\n### 适用场景\n\n1. 数据结构不固定的场景\n2. 对事物要求不高，但读写并发比较大的场景\n3. 对数据的处理操作比较简单的场景\n\n## 关系型数据库选型原则\n\n- 广泛性、可扩展性、安全性和稳定性、数据库所支持的系统、使用成本\n\n## 选择MySQL数据库\n\n- 可扩展性\n\n  1. 支持基于二进制日志的逻辑复制\n\n  2. 存在多种第三方数据库中间层，支持读写分离、分库分表\n\n- 安全性和稳定性\n\n  1. MySQL主从复置集群可达到99%的可用性\n\n  2. 配合主从复置高可用架构可以达到99%的可用性\n\n  3. 支持对存储在MySQL的数据进行分级安全控制\n\n- 支持的系统：支持Windows、linux系统\n\n- 使用成本\n\n  1. 社区版本免费\n\n  2. 使用人员众多，方便获取技术支持\n\n# MySQL实验环境搭建\n\n## 环境准备\n\n- VirtualBox、CentOS-7-x86_64-DVD-1611.iso、MySQL8.0.15、\n\n## 虚拟机环境搭建\n\n（1）安装 VirtualBox\n\n（2）在 VirtualBox 中安装 CentOS（CentOS-7-x86_64-DVD-1611）\n\n​\t\t设置网络为桥接网卡\n\n（3）配置虚拟机环境\n\n- 设置静态ip\n\n  ```shell\n  cd /etc/sysconfig/network-scripts\n  \n  # 通过ip addr 命令获取网卡名称\n  ip addr\n  \n  vi ifcfg-enp0s3\n  ```\n\n  ```shell\n  TYPE=Ethernet\n  BOOTPROTO=none\t# 关闭自动获取ip，设置为静态ip\n  DEFROUTE=yes\n  PEERDNS=yes\n  PEERROUTES=yes\n  IPV4_FAILURE_FATAL=no\n  IPV6INIT=no\t# 关闭ipv6\n  IPV6_AUTOCONF=yes\n  IPV6_DEFROUTE=yes\n  IPV6_PEERDNS=yes\n  IPV6_PEERROUTES=yes\n  IPV6_FAILURE_FATAL=no\n  IPV6_ADDR_GEN_MODE=stable-privacy\n  NAME=enp0s3\n  UUID=c43ba353-8a1c-4c0c-9c24-04d308950e1b\n  DEVICE=enp0s3\n  ONBOOT=yes\t# 开机自动启动网卡\n  IPADDR=10.2.103.103\t# 配置静态ip\n  NETMASK=255.255.254.0\t# 子网掩码\n  GATEWAY=10.2.103.254\t# 网关\n  DNS1=8.8.8.8\n  ```\n\n- 修改主机名\n\n  ```shell\n  vi /etc/hostname\n  \n  sorozy-mysql\n  \n  reboot\n  ```\n\n## 下载、安装与配置MySQL8.0.15\n\n```shell\n# 确保wget可以使用\nyum install wget -y\n\n# 一般安装在 /usr/local 目录下\ncd /usr/local\n\n# 下载mysql安装包\nwget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz\n\n# 或者上传下载好的文件到linux下\nscp -P 22 /Users/sorozy/Documents/bak/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz root@172.20.94.39:/usr/local/\n\n# 解压缩\nxz -d mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz\n\n# 提取文件\ntar xf mysql-8.0.15-linux-glibc2.12-x86_64.tar\n# 迁移并更名至 /usr/local/mysql 目录下\nmv mysql-8.0.15-linux-glibc2.12-x86_64 mysql\n\n# 创建mysql用户,专门启动服务\nuseradd mysql\n\n# 修改my.cnf\nvi /etc/my.cnf\n```\n\n- 修改my.cnf\n\n  ```shell\n  [client]\n  port            = 3306\n  socket          = /usr/local/mysql/data/mysql.sock\n  [mysqld]\n  # Skip #\n  #skip_name_resolve              = 1\n  #skip_external_locking          = 1 \n  #skip_symbolic_links     = 1\n  # GENERAL #\n  user = mysql\n  default_storage_engine = InnoDB\n  character-set-server = utf8\n  socket  = /usr/local/mysql/data/mysql.sock\n  pid_file = /usr/local/mysql/data/mysqld.pid\n  basedir = /usr/local/mysql\n  port = 3306\n  bind-address = 0.0.0.0\n  #explicit_defaults_for_timestamp = off\n  sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n  #read_only=on\n  # MyISAM #\n  key_buffer_size                = 32M\n  #myisam_recover                 = FORCE,BACKUP\n  \n  # undo log #\n  innodb_undo_directory = /usr/local/mysql/undo\n  innodb_undo_tablespaces = 8\n  \n  # SAFETY #\n  max_allowed_packet             = 100M\n  max_connect_errors             = 1000000\n  sysdate_is_now                 = 1\n  #innodb = FORCE\n  #innodb_strict_mode = 1\n  secure-file-priv='/tmp'\n  default_authentication_plugin='mysql_native_password'\n  # Replice #\n   server-id = 1001\n   relay_log = mysqld-relay-bin\n   gtid_mode = on\n   enforce-gtid-consistency\n   log-slave-updates = on\n   master_info_repository =TABLE\n   relay_log_info_repository =TABLE\n  \n  \n  # DATA STORAGE #\n   datadir = /usr/local/mysql/data/\n   tmpdir = /tmp\n   \n  # BINARY LOGGING #\n   log_bin = /usr/local/mysql/sql_log/mysql-bin\n   max_binlog_size = 1000M\n   binlog_format = row\n   binlog_expire_logs_seconds=86400\n  # sync_binlog = 1\n  \n   # CACHES AND LIMITS #\n   tmp_table_size                 = 32M\n   max_heap_table_size            = 32M\n   max_connections                = 4000\n   thread_cache_size              = 2048\n   open_files_limit               = 65535\n   table_definition_cache         = 4096\n   table_open_cache               = 4096\n   sort_buffer_size               = 2M\n   read_buffer_size               = 2M\n   read_rnd_buffer_size           = 2M\n  # thread_concurrency             = 24\n   join_buffer_size = 1M\n  # table_cache = 32768\n   thread_stack = 512k\n   max_length_for_sort_data = 16k\n  \n  \n   # INNODB #\n   innodb_flush_method            = O_DIRECT\n   innodb_log_buffer_size = 16M\n   innodb_flush_log_at_trx_commit = 2\n   innodb_file_per_table          = 1\n   innodb_buffer_pool_size        = 256M\n   #innodb_buffer_pool_instances = 8\n   innodb_stats_on_metadata = off\n   innodb_open_files = 8192\n   innodb_read_io_threads = 16\n   innodb_write_io_threads = 16\n   innodb_io_capacity = 20000\n   innodb_thread_concurrency = 0\n   innodb_lock_wait_timeout = 60\n   innodb_old_blocks_time=1000\n   innodb_use_native_aio = 1\n   innodb_purge_threads=1\n   innodb_change_buffering=all\n   innodb_log_file_size = 64M\n   innodb_log_files_in_group = 2\n   innodb_data_file_path  = ibdata1:256M:autoextend\n   \n   innodb_rollback_on_timeout=on\n   # LOGGING #\n   log_error                      = /usr/local/mysql/sql_log/mysql-error.log\n   # log_queries_not_using_indexes  = 1\n   # slow_query_log                 = 1\n    slow_query_log_file            = /usr/local/mysql/sql_log/slowlog.log\n  \n   # TimeOut #\n   #interactive_timeout = 30\n   #wait_timeout        = 30\n   #net_read_timeout = 60\n  \n  [mysqldump]\n  quick\n  max_allowed_packet = 100M\n  \n  [mysql]\n  no-auto-rehash\n  # Remove the next comment character if you are not familiar with SQL\n  #safe-updates\n  \n  [myisamchk]\n  key_buffer_size = 256M\n  sort_buffer_size = 256M\n  read_buffer = 2M\n  write_buffer = 2M\n  \n  [mysqlhotcopy]\n  interactive-timeout\n  ```\n\n- 新建文件目录\n\n  ```shell\n  cd /usr/local/mysql/\n  \n  mkdir data sql_log undo\n  \n  chown mysql:mysql -R data/ sql_log/ undo/\n  ```\n\n- 环境变量配置\n\n  ```shell\n  vi /etc/profile\n  \n  # 添加下面这行代码\n  export PATH=$PATH:/usr/local/mysql/bin\n  \n  source /etc/profile\n  ```\n\n## 初始化与启动MySQL\n\n```=mysql --basedir=linux\n# 在mysql 5.7之后使用mysqld初始化mysql数据库，以及相关系统表，\n# mysqld --initialize 表示初始化\n# --user=mysql 启动用户\n# --basedir=/usr/local/mysql 安装目录\n# 数据目录 --datadir=/usr/local/mysql/data\n\nmysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data\n# 可能会有报错，根据报错信息修改即可\n\n# 初始化完成之后可以在data目录看到初始化好后的数据库系统文件/数据\n```\n\n- start\n\n  ```shell\n  # 进入/usr/local/mysql/support-files\n  cp mysql.server /etc/init.d/mysqld\n  \n  /etc/init.d/mysqld start\n  \n  # 查看mysql进程\n  ps -ef | grep mysql\n  ```\n\n- 修改密码\n\n  ```shell\n  cd sql_log/\n  \n  # 得到初始化密码\n  grep password mysql-error.log\n  \n  # 登录进入数据库后修改密码\n  alter user  user() identified by '111111';\n  ```\n\n# 数据库设计实战\n\n## 需求分析与设计\n\n- 宽表存在的问题\n  - 数据插入异常：部分数据由于缺失主键信息而无法写入表中\n  - 数据更新异常：修改一行中某列的值时，同时修改了多行数据\n  - 数据删除异常：删除某一数据时不得不删除另一数据\n  - 数据冗余：相同的数据在一个表中出现了多次\n- 宽表模式存在的问题\n  - 配合列存储的数据报表应用\n\n## 数据库设计三范式\n\n- 第一范式：要求有主键，并且要求每一个字段原子性不可再分\n\n- 第二范式：要求所有非主键字段完全依赖主键，不能产生部分依赖\n\n- 第三范式：非主键列之间不能相互依赖。所有非主键字段和主键字段之间不能产生传递依赖\n\n## 常用MySQL存储引擎\n\n<img width=\"800px\" src=\"WechatIMG165.png\" />\n\n<br>\n\n<img width=\"800px\" src=\"WechatIMG167.png\" />\n\n## 数据类型\n\n<img width=\"800px\" src=\"WechatIMG168.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG169.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG170.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG171.png\" />\n\n## 为数据选择合适的数据类型\n\n<img width=\"800px\" src=\"WechatIMG172.png\" />\n\n## 为表和列选择合适的名字\n\n<img width=\"800px\" src=\"WechatIMG176.png\" /><br>\n\n<img width=\"800px\" src=\"WechatIMG175.png\" />\n\n# 访问/连接MySQL\n\n- 命令行\n\n```mysql\nmysql -uroot -p -hlocalhost\n```\n\n- 设置mysql可以使用root账户远程登录\n\n```\nupdate user set host='%' where user='root';\nflush privileges;\n```\n\n## MySQL的常用权限\n\n| 权限名称 |         说明         |\n| :------: | :------------------: |\n|  insert  | 向表中插入数据的权限 |\n|  delete  |  删除表中数据的权限  |\n|  update  |  修改表中数据的权限  |\n|  select  |  查询表中数据的权限  |\n| execute  |  执行存储过程的权限  |\n\n# MySQL 数据类型\n\n## 数值类型\n\n| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |\n| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |\n| TINYINT      | 1 byte                                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |\n| SMALLINT     | 2 bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |\n| MEDIUMINT    | 3 bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |\n| INT或INTEGER | 4 bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |\n| BIGINT       | 8 bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |\n| FLOAT        | 4 bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |\n| DOUBLE       | 8 bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |\n| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |\n\n## 日期和时间类型\n\n| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |\n| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |\n| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |\n| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |\n| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |\n| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |\n| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |\n\n## 字符串类型\n\n| 类型       | 大小                  | 用途                            |\n| :--------- | :-------------------- | :------------------------------ |\n| CHAR       | 0-255 bytes           | 定长字符串                      |\n| VARCHAR    | 0-65535 bytes         | 变长字符串                      |\n| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |\n| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |\n| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |\n| TEXT       | 0-65 535 bytes        | 长文本数据                      |\n| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |\n| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |\n| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |\n| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |\n\n# SQL(structured query language)\n\n- RDBMS（关系型数据库管理系统，全称 Relational Database Management Syste）\n\n## 常用的SQL语言种类\n\n### DCL 数据库管理语句/访问控制语句\n\n```sql\n# 创建用户 `@'%'`访问控制列表，决定用户可以从哪些客户端访问。max_user_connections 最多的连接线程数\ncreate user mc_test@'%' identified by '111111' with max_user_connections 1;\n\n# 给账号授权\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION;\n\n# 查询权限列表\nshow PRIVILEGES；\n\n# 收回用户权限\nrevoke\n\n# 展示插件\nshow plugins;\n```\n\n- 给账号授权举例\n\n<img width=\"800px\" src=\"WechatIMG249.png\" />\n\n- 回收账户权限举例\n\n<img width=\"800px\" src=\"WechatIMG250.png\" />\n\n### DDL 数据定义\n\n```sql\ncreate/alter/drop database\n\ncreate/alter/drop table\n\ncreate/drop index\n\ntruncate table\n\nrename table\n\nCreate/alter/drop view\n\n\nCREATE DATABASE imc_db;\n\n# 速度快，不记录二进制信息\ntruncate table [table_name];\n\nrename table [table_name] to [table_name2];\n```\n\n```sql\nalter table table_name add col_name col_type comment 'xxx';\n```\n\n### DML 表操作\n\n```mysql\ninsert\ndelete\nupdate\nselect\n\nselect \"this is mysql course \" like \"%mysql%\";\n```\n\n```sql\ndrop table if exists imc_class;\nset character_set_client = utf8mb4;\n\ncreate table imc_class (\n    class_id smallint(5) unsigned not null auto_increment comment '课程分类id',\n    class_name varchar(10) not null default '' comment '分类名称',\n    add_time timestamp not null default current_timestamp comment '添加时间',\n    primary key (class_id)\n)\nengine=InnoDB auto_increment=14 default charset = utf8 comment='课程分类'\n```\n\n```sql\ninsert into imc_class (class_name) values (\"数据库\"),(\"java\");\n```\n\n\n\n### TCL 事物控制\n\n## 聚合函数\n\n| AVG()   | 求平均值     |\n| ------- | ------------ |\n| COUNT() | 统计行的数量 |\n| MAX()   | 求最大值     |\n| MIN()   | 求最小值     |\n| SUM()   | 求累加和     |\n\n## Limit子句限制返回行数\n\n```sql\n# 返回第a行起，后b行内容\nselect * from [table_name] order by [col_name] desc limit a,b;\n\nSELECT * FROM table LIMIT 5,10; // 检索记录行 6-15\n\nSELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last\n\nSELECT * FROM table LIMIT 5; //检索前 5 个记录行\n```\n\n## random\n\n```sql\n# 随机选择\nselect * from [table_name] order by rand() limit 5,10;\n```\n\n## date\n\n### 常用的时间函数\n\n|         函数名         |                说明                 |\n| :--------------------: | :---------------------------------: |\n|  curdate()/curtime()   |      返回当前日期/返回当前时间      |\n|         now()          |        返回当前的日期和时间         |\n| date_formate(date,fmt) | 按照fmt的格式，对日期date进行格式化 |\n|  sec_to_time(seconds)  |      把秒数转换为(小时:分:秒)       |\n|   time_to_sec(time)    |      把(小时:分:秒)转换为秒数       |\n\n## 公共表表达式\n\n\n\n\n\n# SQL优化\n\n## 步骤\n\n- 发现问题 > 分析执行计划 > 优化索引 > 改写SQL\n\n- （如果上面的步骤达不到优化效果，则采用：）数据库垂直切分、数据库水平切分\n\n## 发现有性能问题的SQL\n\n（1）用户主动上报应用性能问题\n\n（2）分析慢查询日志，发现存在问题的SQL\n\n（3）数据库实时监控长时间运行的SQL\n\n## 配置慢查询日志\n\n```mysql\n# 开启慢查询日志（on）\nset global slow_query_log = [on|off]\n\n# 配置慢查询日志目录/文件\nset global slow_query_log_file = /sql_log/slowlog.log\n\n# 超过这个执行时间的sql会被记录在日志中，如果记录所有的查询sql，则 参数设置为0即可\nset global long_query_time = xx.xxx 秒\n\n# 所有使未用到索引（on）的sql都会记录到日志中\nset global log_queries_not_using_indexes=[on|off]\n```\n\n## 分析MySQL慢查询日志的工具\n\n- mysqldumpslow\n\n- pt-query-digest\n\n- 下载安装工具\n\n```shell\n# 访问 https://www.percona.com/downloads/percona-toolkit/LATEST/\n\n# 下载 percona-toolkit-3.0.13-1.el7.x86_64.rpm\n\nwget https://downloads.percona.com/downloads/percona-toolkit/3.0.13/binary/redhat/7/x86_64/percona-toolkit-3.0.13-1.el7.x86_64.rpm\n\n# 安装相关依赖包\nyum install -y perl-DBD-MySQL.X86_64 perl-DBI.x86 perl-Time-HiRes.x86_64 perl-IO-Socket-SSL.noarch perl-TermReadKey.x86_64 perl-Digest-MD5\n\nrpm -ivh percona-toolkit-3.0.13-1.el7.x86_64.rpm\n```\n\n## 配置/启用慢查询日志\n\n```mysql\nshow variables like 'long_query_time';\n\nset global long_query_time=0;\n\nshow variables like 'slow_query_log';\n\nset global slow_query_log=on;\n\nshow variables like 'slow_query_log_file';\n```\n\n## 分析慢查询日志\n\n```mysql\nmysqldumpslow slowlog.log\n\npt-query-digest slowlog.log\n```\n\n## 实时监控sql\n\n<img src=\"WechatIMG831.png\" width=\"800px\" />\n\n## 分析SQL执行计划\n\n\n\n### 获取SQL执行计划\n\n\n\n# 事务与并发控制\n\n- 事务是数据库执行操作的最小逻辑单元\n- 事务可以由一个sql组成也可以由多个sql组成\n- 组成事务的sql要么全部成功要么全部失败\n\n```mysql\n# BEGIN 或 START TRANSACTION 显式地开启一个事务\n# COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；\n\n# ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；\n\nSTART TRANSACTION /BEGIN\n\n\tINSERT ...\n\tDELETE ...\n\tSELECT ...\n\t\nROLLBACK / COMMIT\n```\n\n## ACID\n\n- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n## 脏读\n\n<img width=\"800px\" src=\"WechatIMG191.png\" />\n\n## 不可重复读\n\n<img width=\"800px\" src=\"WechatIMG192.png\" />\n\n## 幻读\n\n<img width=\"800px\" src=\"WechatIMG193.png\" />\n\n## INNODB的事务隔离级别\n\n<img width=\"800px\" src=\"WechatIMG194.png\" />\n\n默认：可重复读\n\n- 设置InnoDB引擎的隔离级别\n\n```mysql\n# 设置innodb的事务级别方法是：set 作用域 transaction isolation level 事务隔离级别，例如~\n\nSET [SESSION | GLOBAL] TRANSACTION ] \n\tTRANSACTION ISOLATION LEVEL \n  {\n  \tREAD UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE\n  }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"MySQL study notes","url":"/2020/07/02/MySQL-study-notes/","content":"\n# MySQL基础\n\n## 基本概念\n\n### DB（DataBase）\n\n数据库， 实际上在硬盘上以文件的形似存在\n\n### DBMS（Database Management System）\n\n数据库管理系统，常见的有：MySQL, Oracle DB2 Sybase, SqlServer...\n\n### SQL（Structured Query Language）\n\n结构化查询语言， 是一门标准通用语言， 标准的sql语句适用于所有的数据库产品\n\n<br>\n\n> DBMS 负责执行 sql 语句， 通过执行 sql 语句来操作 db 中的数据\n> DBMS -（执行）-> SQL 语句 -（操作）-> DB\n\n### table\n\n表是数据库的基本组成单元， 所有的数据都以表格的格式组织\n一个表包括行和列：\n行： 被称为数据/记录\n列：被称为字段\n\n- 每个字段名包含哪些信息：字段名， 数据类型， 相关约束\n\n### sql 语句分类\n\nDQL（Data Query Language）（数据库查询语言）： 查询语句， 凡是 select 语句都是 DQL\nDML（Data Manipulation Language）（数据操作语言）：insert /delete /update 对表当中的数据进行增删改\nDDL（Data Defination Language）（数据定义语言）：create drop alter ， 对表结构的增删改\nTCL（Transaction Control Language）（事务控制语言）：commit 提交事务， rollback 回滚事务\nDCL（Data Control Language）（数据控制语言）：grant 授权， revoke 撤销权限等\n\n## 基本操作\n\n```mysql\n# 登录\nmysql -u用户名 -p密码\n\n# 查看有哪些数据库 (这个不是 SQL 语句，属于 mysql 的命令)\nshow database;\n\n# 创建数据库 (这个不是 SQL 语句，属于 mysql 的命令)\ncreate database [database_name];\n\n# 使用数据库 (这个不是 SQL 语句，属于 mysql 的命令)\nuse [databse_name]\n\n```\n\n","tags":["mysql","database"],"categories":["mysql","database"]},{"title":"《Web协议详解与抓包实战》study notes","url":"/2020/07/01/《Web协议详解与抓包实战》study-notes/","content":"\n\n\n# HTTP/1.1协议\n\n## 浏览器发起HTTP请求的典型场景\n\n<img width=\"700px\" src=\"WechatIMG326.png\" />\n\n## HTTP协议的定义\n\n<img width=\"700px\" src=\"WechatIMG327.png\" />\n\n- ABNF\n\n<img width=\"700px\" src=\"WechatIMG328.png\" /><br>\n\n<img width=\"700px\" src=\"WechatIMG329.png\" />\n\n- 基于ABNF描述的HTTP协议格式\n\n<img width=\"700px\" src=\"WechatIMG330.png\" />\n\n## OSI概念模型\n\n<img width=\"700px\" src=\"WechatIMG332.png\" />\n\n- OSI模型与TCP/IP模型对照\n\n<img width=\"700px\" src=\"WechatIMG331.png\" />\n\n## 评估web架构的关键属性\n\n<img width=\"700px\" src=\"WechatIMG1051.png\" />\n\n## URI\n\n<img width=\"700px\" src=\"WechatIMG1052.png\" />\n\nUniform resource identifier\n\n<img width=\"700px\" src=\"WechatIMG1053.png\" />\n\nURI 组成\n\n<img width=\"700px\" src=\"WechatIMG1054.png\" />\n\nURI 编码\n\n<img width=\"700px\" src=\"WechatIMG1055.png\" />\n\nURI 百分号编码\n\n<img width=\"700px\" src=\"WechatIMG1056.png\" />","tags":["http","network"],"categories":["http","network"]},{"title":"《透视HTTP协议》study notes","url":"/2020/06/24/《透视HTTP协议》study-notes/","content":"\n# 学习备注\n\n1. 好需要好好熟悉3次握手、四次挥手\n2. 需要对头字段进行整理\n3. 各种方法详解需要熟悉（熟悉自定义方法？）\n4. 安全幂等需要熟悉\n\n---\n\n# HTTP发展史（来龙去脉）\n\n## 来源\n\n1989 年，蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。\n\n> 1. URI：统一资源标识符，作为互联网上资源的唯一身份；\n> 2. HTML：即超文本标记语言，描述超文本文档；\n> 3. HTTP：即超文本传输协议，用来传输超文本。\n\n## HTTP/0.9\n\n​\t20 世纪 90 年代初期发布。\n\n​\t只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接\n\n## HTTP/1.0\n\n1996 年正式发布（确立了大部分现在使用的技术，但它不是正式标准）\n\n> 1. 增加了 HEAD、POST 等新方法；\n> 2. 增加了响应状态码，标记可能的错误原因；\n> 3. 引入了协议版本号概念；\n> 4. 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；\n> 5. 传输的数据不再仅限于文本。\n\n## HTTP/1.1\n\n1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616（它是一个“正式的标准”）\n\n> 1. 增加了 PUT、DELETE 等新的方法；\n> 2. 增加了缓存管理和控制；\n> 3. 明确了连接管理，允许持久连接；\n> 4. 允许响应数据分块（chunked），利于传输大文件；\n> 5. 强制要求 Host 头，让互联网主机托管成为可能。\n\n## HTTP/2\n\n- 连接慢，无法跟上迅猛发展的互联网\n- 2015 年发布了 HTTP/2，RFC 编号 7540\n- HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及（Google 顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议）\n- HTTP/2 的制定充分考虑了现今互联网的现状：**宽带、移动、不安全**，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：\n\n> 1. 二进制协议，不再是纯文本；\n> 2. 可发起多个请求，废弃了 1.1 里的管道；\n> 3. 使用专用算法压缩头部，减少数据传输量；\n> 4. 允许服务器主动向客户端推送数据；\n> 5. 增强了安全性，“事实上”要求加密通信。\n\n## HTTP/3\n\n- Google 又发明了一个新的协议，叫做 QUIC。\n- 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段\n- HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向\n\n# HTTP概念\n\n## HTTP（HyperText Transfer Protocol）超文本传输协议\n\n- 协议\n\n> 协：必须要有两个或多个参与者<br>\n>\n> 议：对参与者的一种行为约定和规范\n\n- 传输\n\n> 发起传输动作的叫做**请求方**<br>\n>\n> 后接到传输的叫做**应答方**或者**响应方**\n\n- 超文本\n\n> HTTP眼里的“文本”：图片、音频、视频、甚至是压缩包<br>\n>\n> 超文本：“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”\n\n## <font color=red >HTTP 是什么？</font>\n\n<font color=red>**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**</font>\n\n\n- HTTP 不是一个孤立的协议\n\n> <font color=red>HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。</font>此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位\n\n- <font color=red>**HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接**</font>\n\n## HTTP知识地图\n\n<img src=\"http-all.png\" width=\"650\"/>\n\n# 与HTTP相关的各种概念\n\n## 网络世界\n\n- 实际的互联网是由许许多多个规模略小的网络连接而成的\n\n> 这些“小网络”可能是:只有几百台电脑的局域网，可能是有几万、几十万台电脑的广域网，可能是用电缆、光纤构成的固定网络，也可能是用基站、热点构成的移动网络……\n\n- 互联网的正式名称是 Internet\n\n- 互联网的一个子集“万维网”（World Wide Web）(即：我们通常所说的“上网”)\n\n> 它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内\n\n- 万维网之外的资源\n\n> 电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等\n\n- 互联网上绝大部分资源都使用 HTTP 协议传输\n\n## 浏览器（Web Browser）\n\n> 检索、查看互联网上网页资源的应用程序，名字里的 Web，指“World Wide Web”（万维网）\n>\n> 本质上是一个 HTTP 协议中的**请求方**，使用 HTTP 协议获取网络上的各种资源<br>\n\n> 集成了很多额外的功能：HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，甚至还有开发者工具用来调试网页，以及五花八门的各种插件和扩展<br>\n\n> HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求\n\n- Linux上的wget、curl等命令工具基于HTTP，也是一种user agent\n\n## Web 服务器（Web Server）\n\n- HTTP 协议里响应请求的主体\n- 两个层面的含义：硬件和软件\n\n### 硬件\n\n> **硬件**含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。\n\n### 软件\n\n> 提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。\n\n- 常见Web Server\n\n> Apache\n>\n> Nginx：Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展\n>\n> Windows 上的 IIS、Java 的 Jetty/Tomcat 等\n\n## CDN（Content Delivery Network）\n\n- CDN：Content Delivery Network（内容分发网络）\n\n> 应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求\n\n- CDN 位于浏览器和服务器之间\n\n- CDN 的好处：缓存源站的数据\n\n> 除去网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分\n\n## 爬虫（Crawler）\n\n- 一种可以自动访问 Web 资源的应用程序\n\n- 爬虫来源？\n\n> 绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面\n\n- 爬虫不好的一面\n\n> 它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏\n\n- “反爬虫”技术\n\n> 通过各种手段来限制爬虫<br>\n>\n> “君子协定”robots.txt，约定哪些该爬，哪些不该爬\n\n- “爬虫”、“反爬虫”基本技术： HTTP、 HTML\n\n## HTML/WebService/WAF\n\n- **HTML**描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面\n\n- **Web Service**是一种由 W3C 定义的应用服务开发规范\n\n> **基于 Web（HTTP）的服务架构技术**\n\n- **WAF**（“网络应用防火墙”）\n\n> 应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术\n\n> WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx\n\n## TCP/IP\n\n- TCP/IP 协议是目前网络世界“事实上”的标准通信协议\n- TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是**TCP**和**IP**，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈\n- **TCP 属于“传输层”，IP 属于“网际层”**\n\n### IP协议（Internet Protocol）\n\n---\n\n- 主要解决寻址和路由问题，以及如何在两点间传送数据包\n- IP 协议使用“**IP 地址**”的概念来定位互联网上的每一台计算机\n\n### TCP 协议（Transmission Control Protocol）（传输控制协议）\n\n- 位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础\n\n> “可靠”是指保证数据不丢失<br>\n>\n> “字节流”是指保证数据完整\n\n> <font color=red>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收</font>\n\n## DNS（Domain Name System）（域名系统)\n\n- 在DNS中，“域名”（Domain Name）又称为“主机名”（Host）\n\n更多请参考：[DNS](#DNS)\n\n## URI/URL\n\n更多请参考：[URI](#URI)\n\n## HTTPS（HTTP over SSL/TLS）\n\n- 运行在 SSL/TLS 协议上的 HTTP\n- HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”\n\n### SSL/TLS\n\n- 负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层\n- SSL：（Secure Socket Layer）后改名（Transport Layer Security）\n- SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲\n\n##代理（Proxy）\n\n- HTTP 协议中请求方和应答方中间的一个环节，既可以转发客户端的请求，也可以转发服务器的应答\n\n- 常见代理\n\n> 1. 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；\n> 2. 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；\n> 3. 正向代理：靠近客户端，代表客户端向服务器发送请求；\n> 4. 反向代理：靠近服务器端，代表服务器响应客户端的请求；\n\n- 可以做：\n\n> 1. 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；\n> 2. 内容缓存：暂存上下行的数据，减轻后端的压力；\n> 3. 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；\n> 4. 数据处理：提供压缩、加密等额外的功能。\n\n# 网络分层模型\n\n## TCP/IP 网络分层模型\n\n<img src=\"h1.png\" width=\"650\"/>\n\n- 第一层叫“链接层”（link layer）\n\n> 负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。\n\n- 第二层叫“网际层”或者“网络互连层”（internet layer）\n\n> IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。\n\n- 第三层叫“传输层”（transport layer）\n\n> 这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。\n\n- 第四层叫“应用层”（application layer）\n\n> 由于下面的三层把基础打得非常好，所以在这一层就有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 、 HTTP\n\n<br>\n\n> MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包\n\n## OSI 网络分层模型\n\n- OSI：（Open System Interconnection Reference Model）开放式系统互联通信参考模型\n\n<img src=\"h2.png\" width=\"650\"/>\n\n- OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：\n\n> 1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；\n> 2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；\n> 3. 第三层：网络层，相当于 TCP/IP 里的网际层；\n> 4. 第四层：传输层，相当于 TCP/IP 里的传输层；\n> 5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；\n> 6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；\n> 7. 第七层：应用层，面向具体的应用传输数据。\n\n- OSI模型优点\n\n> TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整。\n\n## 两个分层模型的映射关系\n\n<img src=\"h3.png\" width=\"650\"/>\n\n> 1. 第一层：物理层，TCP/IP 里无对应；\n> 2. 第二层：数据链路层，对应 TCP/IP 的链接层；\n> 3. 第三层：网络层，对应 TCP/IP 的网际层；\n> 4. 第四层：传输层，对应 TCP/IP 的传输层；\n> 5. 第五、六、七层：统一对应到 TCP/IP 的应用层。\n\n- 四层负载均衡\n\n> 工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡\n\n- 七层负载均衡\n\n> 工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器\n\n## TCP/IP 协议栈的工作方式\n\n<img src=\"h4.png\" width=\"650\"/>\n\n- 凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。\n\n- 二层转发\n\n> 设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播\n\n- 三层路由\n\n> 设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关\n\n# DNS\n\n## 域名作用与形式\n\n> 1. 代替IP\n>\n> 2. 可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令\n\n- 本质上是一个名字空间系统\n\n- 域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低\n## 域名的解析\n\n- <font color=red>**DNS 的核心系统是一个三层的树状、分布式服务**</font>，基本对应域名的结构：\n\n> 1. 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；\n> 2. 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；\n> 3. 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。\n\n- 目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到\n- 访问“www.apple.com”，就要进行下面的三次查询：\n\n> 1. 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；\n> 2. 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；\n> 3. 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。\n\n## DNS缓存\n\n- 为了提高查询效率，外围有多级的缓存\n\n> 1. 许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理\n> 2. 操作系统里也会对 DNS 解析结果做缓存\n\n## 域名玩法\n\n> 1. 重定向（变更主机ip）\n> 2. 搭建内部DNS\n> 3. 基于域名实现的负载均衡（轮询 or 返回最近主机）\n> 4. 域名屏蔽、域名劫持（域名污染）\n\n## DNS解析过程\n\n> 浏览器缓存->操作系统缓存->hosts->dns\n\n# 搭建HTTP实验环境\n\n- 软件准备\n\n> Wireshark\n>\n> Chrome/Firefox\n>\n> Telnet\n>\n> OpenResty\n\n- 修改hosts文件，添加配置本机 IP 地址到测试域名的映射\n\n```linux\n127.0.0.1       www.chrono.com\n127.0.0.1       www.metroid.net\n127.0.0.1       origin.io\n```\n\n- Mac上 安装 OpenResty\n\n```linux\n# 使用homebrew安装OpenResty （ke能需要用梯子）\nbrew install openresty/brew/openresty\n\n# 执行上面命令 可能出现报错如下：\n    Error: The following directories are not writable by your user:\n    /usr/local/share/man/man8\n\n    You should change the ownership of these directories to your user.\n      sudo chown -R $(whoami) /usr/local/share/man/man8\n\n    And make sure that your user has write permission.\n      chmod u+w /usr/local/share/man/man8\n  \n# 解决方案：在终端执行下面命令\nsudo chown -R `whoami`:admin /usr/local/bin\nsudo chown -R `whoami`:admin /usr/local/share\n\n# 查看是否安装成功\nresty -v\n\n# 执行上面命令出现了下面内容就代表成功了\n    resty 0.23\n    nginx version: openresty/1.15.8.3\n    built by clang 11.0.3 (clang-1103.0.32.62)\n    built with OpenSSL 1.1.0l  10 Sep 2019\n\ngit clone https://github.com/chronolaw/http_study\n\ncd http_study/www/    #脚本必须在www目录下运行，才能找到nginx.conf\n./run.sh start        #启动实验环境\n./run.sh list         #列出实验环境的Nginx进程\n./run.sh reload       #重启实验环境\n./run.sh stop         #停止实验环境\n\n# 启动实验环境后访问 localhost，如果正常访问则环境搭建成功\n\n# 访问localhost 若出现403， 则在 conf/nginx.conf 文件的顶部添加 user xxxx staff，这个 xxxx 是自己的 mac 账户名，再重启实验环境即可\n```\n\n- 用浏览器或者 curl 来验证课程里的各个测试 URI\n\n```linux\ncurl -v \"http://127.0.0.1/\"\ncurl -v \"http://www.chrono.com/09-1\"\ncurl -k \"https://www.chrono.com/24-1?key=1234\"\ncurl -v \"http://www.chrono.com/41-1\"\n```\n\n<br>\n\n# 键入网址再按下回车，后面究竟发生了什么\n\n<img src=\"h5.png\" width=\"650\"/>\n\n- 最简单的浏览器 HTTP 请求过程：\n\n> 1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；\n> 2. 浏览器用 TCP 的三次握手与服务器建立连接；\n> 3. 浏览器向服务器发送拼好的报文；\n> 4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；\n> 5. 浏览器解析报文，渲染输出页面。\n\n\n\n- 当浏览器发现输入的url不是数字形式的IP地址（那就肯定是域名了）于是就会发起域名解析动作，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址\n\n- 域名解析过程\n\n> 操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析\n>\n> 会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址\n>\n> 缓存服务器\n>\n> 应用服务器\n\n\n\n> 1. HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；\n> 2. 如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败；\n> 3. 建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文；\n> 4. 为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现“短路”操作\n\n# HTTP报文\n\n## TCP报文\n\n<img src=\"h6.png\" width=\"650\"/>\n\n> 在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等\n\n## HTTP报文\n\n- 所以头数据都是 ASCII 码的文本\n- HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：\n\n> 1. 起始行（start line）：描述请求或响应的基本信息；\n> 2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；\n> 3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据h\n\n<img src=\"h7.png\" width=\"650\"/>\n\n### 请求行（request line）\n\n- 简要地描述了**客户端想要如何操作服务器端的资源**\n- 请求行由三部分构成\n\n> 1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；\n> 2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；\n> 3. 版本号：表示报文使用的 HTTP 协议版本\n\n三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束\n\n<img src=\"h8.png\" width=\"650\"/>\n\n### 状态行（status line）\n\n- **服务器响应的状态**\n- 状态行由三部分构成\n\n> 1. 版本号：表示报文使用的 HTTP 协议版本；\n> 2. 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；\n> 3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因\n\n<img src=\"h9.png\" width=\"650\"/>\n\n### 头部字段\n\n- 请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头\n\n<img src=\"h10.png\" width=\"650\"/>\n\n<img src=\"h11.png\" width=\"650\"/>\n\n- 头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束\n- HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能\n- 使用头字段需要注意下面几点：\n\n> 1. 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；\n> 2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；\n> 3. 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；\n> 4. 字段的顺序是没有意义的，可以任意排列不影响语义；\n> 5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie\n\n#### 常用头字段\n\n基本上可以分为四大类：\n\n> 1. 通用字段：在请求头和响应头里都可以出现；\n> 2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；\n> 3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；\n> 4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息\n\n\n\n|     头字段     |              类别              | 说明/备注                                                    |\n| :------------: | :----------------------------: | ------------------------------------------------------------ |\n|      Host      |            请求字段            | Host 字段告诉服务器这个请求应该由哪个主机来处理（唯一一个 HTTP/1.1 规范里要求**必须出现**的字段） |\n|   User-Agent   |   请求字段，只出现在请求头里   | 使用一个字符串来描述发起 HTTP 请求的客户端                   |\n|      Date      | 通用字段，但通常出现在响应头里 | 表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略 |\n|     Server     |            响应字段            | 告诉客户端当前正在提供 Web 服务的软件名称和版本号（非必须出现） |\n| Content-Length |            实体字段            | 它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输 |\n\n# HTTP方法\n\n- 为什么要有“请求方法”\n\n> 客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作\n\n- 目前 HTTP/1.1 规定了八种方法，单词**都必须是大写的形式**\n\n> 1. GET：获取资源，可以理解为读取或者下载数据；\n> 2. HEAD：获取资源的元信息；\n> 3. POST：向资源提交数据，相当于写入或上传数据；\n> 4. PUT：类似 POST；\n> 5. DELETE：删除资源；\n> 6. CONNECT：建立特殊的连接隧道；\n> 7. OPTIONS：列出可对资源实行的方法；\n> 8. TRACE：追踪请求 - 响应的传输路径。\n\n<img src=\"h12.png\" width=\"650\"/>\n\n## 安全、幂等\n\n- 幂等：多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”\n\n# URI\n\n- URL\n\n> 统一资源定位符（Uniform Resource Locator）\n\n- URI\n\n> 统一资源标识符（Uniform Resource Identifier）\n>\n> URI 本质上是一个字符串，这个字符串的作用是**唯一地标记资源的位置或者名字**\n>\n> 包含有 URL 和 URN 两个部分\n\n- URI 最常用的形式\n\n<img src=\"h13.png\" width=\"650\"/>\n\n- URI 的基本组成\n\n  > scheme:\t“方案名”或者“协议名”，表示**资源应该使用哪种协议**来访问。\n\n  > “://”之后:\t是被称为“**authority**”的部分，表示**资源所在的主机名**，通常的形式是“host:port”，即主机名加端口号\n\n- 客户端和服务器看到的 URI 是不一样的\n\n> 客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI。\n\n- URI 的查询参数\n\n> 多个“**key=value**”的字符串，这些 KV 值用字符“**&**”连接，浏览器和客户端都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。\n\n- URI 的完整格式\n\n<img src=\"h14.png\" width=\"650\"/>\n\n> **身份信息**“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患\n\n- **片段标识符**“#fragment”\n\n> 它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置\n\n> 片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段\n\n- URI 的编码\n\n> URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。\n\n> URI 转义的规则：直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”\n\n## 课后问题\n\n- URI 的查询参数和头字段很相似，都是 key-value 形式，都可以任意自定义，那么它们在使用时该如何区别呢？\n\n> query参数针对的是资源（uri），而字段针对的是本次请求，也就是报文。<br>\n>\n> 一个是长期、稳定的，一个是短期、临时的\n\n# HTTP响应状态码\n\n- 状态码（Status Code）\n\n> 它是一个十进制数字，以代码的形式表示服务器对请求的处理结果\n\n> 表达 HTTP 数据处理的“状态”，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思\n\n- RFC 标准把状态码分成了五类\n\n> - 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；\n> - 2××：成功，报文已经收到并被正确处理；\n> - 3××：重定向，资源位置发生变动，需要客户端重新发送请求；\n> - 4××：客户端错误，请求报文有误，服务器无法处理；\n> - 5××：服务器错误，服务器在处理请求时内部发生了错误。\n\n## 1××\n\n- **101 Switching Protocols**\n\n> 客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了\n\n## 2××\n\n- **200 OK**\n\n> 是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果\n\n- **204 No Content**\n\n> 含义与“200 OK”基本相同，但响应头后没有 body 数据\n\n- **206 Partial Content**\n\n> 是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分\n\n> 状态码 206 通常还会伴随着头字段“**Content-Range**”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节\n\n## 3××\n\n- **301 Moved Permanently**\n\n> 永久重定向\n\n- **302 Found**\n\n> 临时重定向\n\n**301 和 302 都会在响应头里使用字段**Location**指明后续要跳转的 URI**\n\n- **304 Not Modified**\n\n> 它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制<br>\n>\n> 可以理解成“重定向已到缓存的文件”（即“缓存重定向”）\n\n## 4××\n\n- **400 Bad Request**\n\n> 是一个通用的错误码，表示请求报文有错误\n\n- **403 Forbidden**\n\n> 实际上不是客户端的请求出错，而是表示服务器禁止访问资源\n\n- **404 Not Found**\n\n> 原意是资源在本服务器上未找到，所以无法提供给客户端\n\n\n\n> - 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；\n> - 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；\n> - 408 Request Timeout：请求超时，服务器等待了过长的时间；\n> - 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；\n> - 413 Request Entity Too Large：请求报文里的 body 太大；\n> - 414 Request-URI Too Long：请求行里的 URI 太大；\n> - 429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；\n> - 431 Request Header Fields Too Large：请求头某个字段或总体太大；\n\n## 5××\n\n- **500 Internal Server Error**\n\n> 服务器错误\n\n- **501 Not Implemented**\n\n> 表示客户端请求的功能还不支持\n\n- **502 Bad Gateway**\n\n> 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误\n\n- **503 Service Unavailable**\n\n> 服务器当前很忙，暂时无法响应服务<br>\n>\n> 503 响应报文里通常还会有一个“**Retry-After**”字段，指示客户端可以在多久以后再次尝试发送请求\n\n# HTTP特点\n\n- 灵活可扩展\n\n> 只规定了报文的基本格<br>\n>\n> 报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制\n\n- 可靠传输\n\n> HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议<br>\n>\n> 是对实际传输的数据（entity）做了一层包装，加上一个头，然后调用 Socket API，通过 TCP/IP 协议栈发送或者接收\n\n- 应用层协议\n- 请求 - 应答\n- 无状态\n- 其它特点\n\n> 传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等。但这些并不能算是 HTTP 的基本特点，因为这都是由第一个“灵活可扩展”的特点所衍生出来的\n\n# HTTP优缺点\n\n- 简单、灵活、易于扩展\n\n> 降低了学习和使用的门槛<br>\n>\n> 允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由<br>\n>\n> 不限制具体的下层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定\n\n- 应用广泛、环境成熟\n\n> 不限定某种编程语言或者操作系统，所以天然具有“**跨语言、跨平台**”的优越性<br>\n>\n> 有许多硬件基础设施支持\n\n- 无状态\n\n> 不需要额外的资源来记录状态信息<br>\n>\n> 不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务<br>\n>\n> 容易地组成集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使用“堆机器”的“笨办法”轻松实现高并发高可用\n\n> 无法支持需要连续多个步骤的“事务”操作，不仅麻烦，而且还增加了不必要的数据传输量\n\n- 明文\n\n> 不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利\n\n> 不安全\n\n- 不安全\n\n> 没有提供有效的手段来确认通信双方的真实身份<br>\n>\n> 不支持“完整性校验”，数据在传输过程中容易被窜改而无法验证真伪。\n\n- 性能\n\n> 不算差，不够好<br>\n>\n> 不能保证稳定的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好<br>\n>\n> “请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据\n\n# HTTP实体数据\n\n## 数据类型与编码\n\n- 请求头\n\n```nginx\n# 客户端告诉服务器，客户端可以接受什么样的数据，\nAccept: text/html,application/xml,image/webp,image/png\n\n# 字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示\nAccept-Charset: gbk, utf-8\n\n# 客户端支持的压缩格式\nAccept-Encoding: gzip,deflate,br\t# 如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；\n\n# 标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型\nAccept-Language: zh-CN, zh, en\n```\n\n> 1. gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；\n> 2. deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；\n> 3. br：一种专门为 HTTP 优化的新压缩算法（Brotli）。\n\n- 响应头\n\n```nginx\n# 服务器告诉客户端，实际传输的数据类型,\nContent-Type: text/html\n# 字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示\nContent-Type: text/html; charset=utf-8\n\n# 实际使用的压缩格式\nContent-Encoding: gzip\t# 如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。\n\n# 告诉客户端实体数据使用的实际语言类型\nContent-Language: zh-CN\n```\n\n> 现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段\n\n- 内容协商质量值\n\n> 权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。\n\n```nginx\nAccept: text/html,application/xml;q=0.9,*/*;q=0.8\n\n# 表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。\n```\n\n- 内容协商的结果\n\n> 内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个**Vary**字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：\n\n```nginx\nVary: Accept-Encoding,User-Agent,Accept\n# 这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文\n```\n\n# 分块传输\n\n```http\n# 报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送\nTransfer-Encoding: chunked\n```\n\n- 分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“**Content-Length**”里给出确切的长度，所以也只能用 chunked 方式分块发送\n- “Transfer-Encoding: chunked”和“Content-Length”这两个字段是**互斥的**，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked\n\n## 分块传输的编码规则\n\n<img src=\"h15.png\" width=\"650\"/>\n\n> 1. 每个分块包含两个部分，长度头和数据块；\n> 2. 长度头是以 CRLF（回车换行，即\\r\\n）结尾的一行明文，用 16 进制数字表示长度；\n> 3. 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；\n> 4. 最后用一个长度为 0 的块表示结束，即“0\\r\\n\\r\\n”。\n\n## 范围请求（range requests）\n\n- 允许客户端在请求头里使用专用字段来表示只获取文件的一部分\n- 非必须\n- 服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”\n- 服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能\n- 请求头**Range**是 HTTP 范围请求的专用字段，格式是“**bytes=x-y**”，其中的 x 和 y 是以字节为单位的数据范围\n- x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节\n- Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：\n\n> - “0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；\n> - “10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；\n> - “-1”是文档的最后一个字节，相当于“99-99”；\n> - “-10”是从文档末尾倒数 10 个字节，相当于“90-99”。\n\n- 服务器收到 Range 字段后，需要做四件事\n\n> 第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码**416**，意思是“你的范围请求有误，我无法处理，请再检查一下”。\n>\n> 第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“**206 Partial Content**”，和 200 的意思差不多，但表示 body 只是原数据的一部分。\n>\n> 第三，服务器要添加一个响应头字段**Content-Range**，告诉片段的实际偏移量和资源的总大小，格式是“**bytes x-y/length**”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。\n>\n> 最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。\n\n- 常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：\n\n> - 先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；\n> - 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；\n> - 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。\n\n## 多段数据\n\n- 一次性获取多个片段数据，这种情况需要使用一种特殊的 MIME 类型：“**multipart/byteranges**”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记\n\n<img src=\"h16.png\" width=\"650\"/>\n\n<br>\n\n- http交给tcp进行传输的时候本来就会分块，那http分块的意义是什么呢？\n\n> 在http层是看不到tcp的，它不知道下层协议是否会分块，下层是否分块对它来说没有意义，不关心。\n\n> 在http里一个报文必须是完整交付，在处理大文件的时候就很不方便，所以就要分块，在http层面方便处理。\n\n> chunked主要是在http的层次来解决问题。\n\n\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---","tags":["http","network"],"categories":["http","network"]},{"title":"《HTTP协议原理+实践》syudy notes","url":"/2020/06/13/《HTTP协议原理-实践》syudy-notes/","content":"\n# 学习备注\n\n1、缓存这块，后续可以再学习一遍，把实战的内容实践一遍。也可以深入研究一下\n\n2、缓存到之后的内容包括csp，理解的比较浅，后序遇到，可以深入理解一下\n\n---\n\n# 前言\n\n> 1. 学习了慕课网的《HTTP协议原理+实践》课程，本篇文章是学习笔记。以便温习\n> 2. 相关的基础知识讲解比较浅，可以参考其它文章\n\n# HTTP基础\n\n## 浏览器输入URL后HTTP请求的完整过程\n\n<img src=\"WechatIMG243.png\" />\n\n## 5层网络模型\n\n<img src=\"WechatIMG244.png\" />\n\n> 1. 物理层：定义物理设备如何传输数据\n> 2. 数据链路层：在通信的实体间建立数据链路连接\n> 3. 网络层：为数据在节点之间传输创建逻辑链路\n> 4. 传输层：向客户端提供可靠的端到端服务；向高层屏蔽了下层数据传输细节\n> 5. 应用层：为软件提供服务；构建于TCP协议之上；屏蔽网络传输细节\n\n## 三次握手时序图\n\n<img src=\"WechatIMG253.png\" />\n\n\n\n# HTTP各种特性总览 & 实践\n\n## 创建一个简单的web服务\n\n```javascript\n/* use node.js */\nconst http = require(\"http\");\n\nhttp.createServer((req,res) => {\n    console.log(\"req.url\",req.url);\n    res.end(\"test\");\n\n}).listen(9090);\n```\n\n\n\n## CORS\n\n- 浏览器 为了保证服务端安全（保证数据不被恶意篡改 ），默认不允许跨域\n\n### CORS演示\n\nserver-8001.js\n\n```javascript\nconst http = require(\"http\");\nconst fs = require(\"fs\");\n\nhttp.createServer((req,res) => {\n    console.log(\"request come\",req.url);\n\n    // read file\n    const html = fs.readFileSync(\"test.html\",\"utf8\");\n    res.writeHead(200,{\n        \"Content-Type\":\"text/html\"\n    });\n\n    res.end(html);\n}).listen(8001);\n\nconsole.log(\"server listening on 8001\");\n```\n\nserver-9001.js\n\n```javascript\nconst http = require('http')\n\nhttp.createServer(function (request, response) {\n  console.log('request come', request.url)\n\n  response.writeHead(200, {\n    // 'Access-Control-Allow-Origin': 'http://127.0.0.1:8888',\n    'Access-Control-Allow-Origin': '*',// 设置允许所有服务跨域\n    // 'Access-Control-Allow-Headers': 'X-Test-Cors', // 设置允许跨域的自定义头\n    // 'Access-Control-Allow-Methods': 'POST, PUT, DELETE',// 设置允许跨域的方法\n    // 'Access-Control-Max-Age': '1000'\n  })\n  response.end('123')\n}).listen(9001)\n\nconsole.log('server listening on 9001')\n```\n\ntest.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <script>\n        var xhr = new XMLHttpRequest()\n        xhr.open('GET', 'http://127.0.0.1:9001/')\n        xhr.send()\n      </script>\n</body>\n</html>\n```\n\n### 浏览器跨域限制\n\n- <font color=\"red\" >浏览器在发送请求的时候并不知道这个服务是否是跨域的，**还是会发送请求，接收内容**。在接收返回数据的时候会看到请求头部中没有 `'Access-Control-Allow-Origin'` 请求头,并且没有设置为允许的话，就会把请求内容忽略掉，并报错。</font>\n\n### CORS解决方案 \n\n#### jsonp\n\ntest.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n    \n</body>\n<!-- cors1 -->\n\t<script src=\"http://127.0.0.1:8887/\" ></script>\n</html>\n```\n\n- 原理\n\n> **利用了 link、script、img标签上面的src或ref是允许跨域的这个原理**\n\n#### Access-Control-Allow-Origin\n\n服务端添加请求头：Access-Control-Allow-Origin\n\n```javascript\n/*允许所有服务跨域*/\n'Access-Control-Allow-Origin':'*'\n\n/*只允许某个域名跨域，不能设置多个值，可以通过判断来实现*/\n'Access-Control-Allow-Origin':'http://www.baidu.com'\n```\n\n\n\n### CORS预请求\n\n- 浏览器默认不允许跨域，但是浏览器会发送请求，并且数据有返回。因为安全策略问题，把请求返回忽略了，并报错\n- CORS限制时，会发送`预请求`验证\n\n### CORS限制\n\n#### 请求`method`限制\n\n- 默认允许跨域的method：post、head、get（这三个方法不用发送预请求）。其它方法默认不允许跨域，且会发送`预请求`\n- 解决方案\n\n```javascript\n/* 添加请求头 'Access-Control-Allow-Methods'，填写对应的方法 如下 */\n'Access-Control-Allow-Methods': 'POST, PUT, DELETE'\n```\n\n#### `Content-Type`限制\n\n- 默认允许跨域的Content-Type：\n\n```javascript\ntext/plain\n\nmultipart/form-data\n\napplication/x-www-form-urlencoded\n```\n\n- 其它Content-Type需要预请求\n\n#### 请求头限制\n\n- 自定义请求头是不被允许的\n\n允许或不被允许的请求头，请参考 https://fetch.spec.whatwg.org/#cors-safelisted-request-header\n\n- 解决方案\n\n```javascript\n/* 允许我们自定义的请求头CORS */\n'Access-Control-Allow-Headers': 'X-Test-Cors'\n```\n\n####Access-Control-Max-Age \n\n```javascript\n/* 数字（单位：秒）代表 允许跨域的时间，在该时间内，不用发送预请求*/\n'Access-Control-Max-Age': '1000' \n```\n\n## 缓存\n\n- public：所经过的路径中的客户端、代理服务器、源服务器等（任何地方）都可以（对返回内容）进行缓存\n- private：发起请求的请求方可以缓存\n- no-cache：需要服务端验证\n- no-store：任何地方都不可以缓存\n- no-transform：告诉代理服务器，不要缓存\n\n### 缓存到期\n\n`max-age=<seconds>`缓存过期时间\n\n`s-maxage=<seconds>`\t代替 `max-age=<seconds>`，但只有在代理服务器中才可以生效。如果两者都设置了，则代替`max-age=<seconds>`\n\n`max-stale=<seconds>`在请求方使用，如果`max-age=<seconds>`到期，缓存过期了，依然可以在`max-stale=<seconds>`时间内使用过期缓存\n\n### 重新验证\n\n`must-revalidate`，用在客户端，`max-age=<seconds>`到期后，必须去源服务器重新获取数据\n\n`proxy-revalidate`，同上，只用在代理服务器上\n\n### 缓存流程\n\n<img src=\"WechatIMG286.png\" />\n\n### 缓存验证\n\n`last-modified` 上次修改时间，主要配合`if-modified-since` 和`if-unmodified-since`使用\n\n> 对比上次修改时间，以验证资源是否需要更新\n\n`Etag`数据签名，配合`if-match`和`if-non-match`\n\n> 对比资源签名，判断是否使用缓存\n\n## Cookie\n\n> 通过 `Set-Cookie`设置<br>\n>\n> 下次请求会自动带上<br>\n>\n> 健值对，可以设置多个\n>\n> `max-age`和`expires`设置过期时间\n>\n> secure只在https的时候发送\n>\n> HttpOnly无法通过document.cookie访问\n>\n> 可以设置二级域名下共享cookie\n\n### 代码演示\n\n- Server.js\n\n```javascript\nconst http = require('http')\nconst fs = require('fs')\n\nhttp.createServer(function (request, response) {\n  console.log('request come', request.url)\n\n  if (request.url === '/') {\n    const html = fs.readFileSync('test.html', 'utf8')\n    response.writeHead(200, {\n      'Content-Type': 'text/html',\n      'Set-Cookie': ['id=123; max-age=2', 'abc=456;HttpOnly']\n    })\n    response.end(html)\n  }\n\n}).listen(8888)\n\nconsole.log('server listening on 8888')\n```\n\n- Test.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <div>Content</div>\n</body>\n<script>\n  console.log(document.cookie)\n</script>\n</html>\n```\n\n\n\n## 长连接\n\n```javascript\nconnection:\"close\"\nconnection:\"keep-alive\"\n```\n\n## 数据协商\n\n- 客户端\n\n```javascript\nAccept\nAccept-Encoding\nAccept-Language\nUser-Agent\n```\n\n- 服务端\n\n```javascript\nContent-Type\nContent-Encoding\nContent-Language\n```\n\n## 跳转\n\n- 301 和 302 的区别\n\n> 302:客户端还是会访问原站\n>\n> 301:客户端会尽可能的缓存，不访问原站\n\n## 资源限制\n\n限制资源获取，制定资源类型\n\n`Content-Security-Policy`\n\n`Security-Policy-Report-Only`\n\n# 使用Nginx实战HTTP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n","tags":["http","network"],"categories":["http","network"]},{"title":"Linux common commands","url":"/2020/06/05/Linux-common-commands/","content":"\n```linxu\n# 查看防火墙状态\nsystemctl status firewalld\n\n# 开启防火墙\nsystemctl start firewalld\n\n# 关闭防火墙\nsystemctl stop firewalld.service\n\n# 重启网络\nservice network restart\n```\n\n\n\n","tags":["Linux","terminal"],"categories":["Linux","terminal"]},{"title":"Nginx common commands","url":"/2020/06/05/Nginx-common-commands/","content":"\n```linux\n# nginx修改配置文件后，检查配置文件是否正确\n# -t 验证配置文件是否正确 -c 指定配置文件的路径\nnginx -t -c /etc/nginx/nginx.conf\nnginx -tc /etc/nginx/nginx.conf\n\n# 重载Nginx服务\nnginx -s reload -c /etc/nginx/nginx.conf\n\nsystemctl start nginx.service\nsystemctl stop nginx.service\nsystemctl restart nginx.service\n```\n\n","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"mac terminal use","url":"/2020/06/05/mac-terminal-use/","content":"\n\n\n# mac terminal use\n\n```linux\n# mac use terminal upload file，上传文件夹到linux目录，需要添加参数 -p\nscp -r -P 22 /Users/sorozy/Documents/study/ root@192.168.2.243:/opt/app/code/\n\n# 上传文件到linux某个目录\nscp -P 22 /Users/sorozy/Documents/study/* root@192.168.2.243:/opt/app/code/\n\nscp -P 22 /Users/sorozy/Documents/study/access.txt root@192.168.2.243:/opt/app/code/\n```\n\n\n\n\n\n","tags":["terminal","mac"],"categories":["terminal"]},{"title":"《Nginx入门到实践－Nginx中间件》study notes","url":"/2020/05/30/《Nginx入门到实践－Nginx中间件》study-notes/","content":"\n> nginx特性这一块需要再复习且深入学习一下，重新做好笔记\n>\n> 了解io多路复用，epoll，io复用\n>\n> 再次熟悉 nginx.conf 的相关配置\n>\n> 目录、编译参数日后了解\n>\n> 实战的内容有空需要做一下\n>\n> 需要了解cdn\n>\n> \n>\n> 日志配置这一块还要动手实践一下\n>\n> 了解ab工具的使用\n>\n> 了解\n>\n> -  2-13 Nginx虚拟主机及实现方式 (09:35)\n> -  2-14 Nginx虚拟主机单网卡多IP配置演示 (15:41)\n> -  2-15 Nginx虚拟主机基于多端口的配置演示 (08:24)\n> -  2-16 Nginx虚拟主机基于host域名的配置演示 (09:50)\n>\n> 请求限制这一块需要深入了解一下，课程中对应的内容需要动手实践\n>\n> 访问控制 - http_acces_module 局限性 这部分的笔记需要补充上\n>\n> 基于用户的信任登录 http_auth_basic_module 需要再看一下\n>\n> 深入了解跨站访问\n>\n> 正向代理 需要动手实现一下\n\n---\n\n# Nginx简介及起步\n\n## Nginx简介\n\n高效、可靠的web服务中间件\n\n（1）高效：支持海量的并发请求\n\n（2）可靠：Nginx的服务是可靠运行的\n\n（3）开源\n\nNginx是一个开源且高性能、可靠的http中间件、代理服务。\n\n\n\n## Nginx特点（优势）\n\n（1）IO多路复用epoll\n\n（2）轻量级：功能模块少、代码模块化\n\n（3）cpu亲和\n\n（4）sendfile\n\n## 环境调试准备\n\n```shell\n# 一、环境 \n# Centos7\n\n\n# 二、四项确认\n\n# （1）确认系统网络（连接到公网）\nping www.baidu.com\n\n# （2）确认yum源可用\n# 列出gcc相关yum源\nyum list|grep gcc\n\n#（3）确认关闭iptables规则 （规则会对验证HTTP服务造成影响）\n# 查看是否有iptables规则\niptables -L\niptables -t nat -L\n# 关闭规则\niptables -F\niptables -t nat -L\n\n#（4）确认停用selinux\n# 查看SELinux状态，如果SELinux status参数为enabled即为开启状态\ngetenforce\n\n# 临时关闭（不用重启机器）\nsetenforce 0\n\n#设置SELinux 成为permissive模式\n#setenforce 1 设置SELinux 成为enforcing模式\n\n# 修改配置文件需要重启机器\n# 修改/etc/selinux/config 文件\n# 将SELINUX=enforcing改为SELINUX=disabled\n\n\n# 三、两项安装\n\n# -y 不需要确认\nyum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake wget httpd-tools vim\n\n# 四、一次初始化目录\n\n# cd /opt目录下\ncd /opt && mkdir app download logs work backup\n\napp\t\t# 软件、应用、代码\nbackup\t\t# 备份文件\ndownload\t# 下载内容\nlogs\t\t# 自定义日志\nwork\t\t# shell脚本\n```\n\n## Nginx install\n\n```shell\n# 基于yum源（这种方式不需要源码一个个编译，加入package参数。这种方式效率高）\ncd /etc/yum.repos.d && touch nginx.repo && vim /etc/yum.repos.d/nginx.repo\n\n# 添加如下内容 $releasever 换成centos版本\n[nginx-stable]\nname=nginx stable repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=1\nenabled=1\ngpgkey=https://nginx.org/keys/nginx_signing.key\nmodule_hotfixes=true\n\n\nyum list | grep nginx\n\nyum install nginx\n\n# 查看版本\nnginx -v\n\n# 查看编译参数\nnginx -V\n```\n\n## Nginx目录详解\n\n <img src=\"1.png\" width=\"650\"/><br>\n\n <img src=\"2.png\" width=\"650\"/><br>\n\n <img src=\"3.png\" width=\"650\"/><br>\n\n <img src=\"4.png\" width=\"650\"/><br>\n\n <img src=\"5.png\" width=\"650\"/><br>\n\n <img src=\"6.png\" width=\"650\"/><br>\n\n <img src=\"7.png\" width=\"650\"/><br>\n\n <img src=\"8.png\" width=\"650\"/><br>\n\n <img src=\"9.png\" width=\"650\"/><br>\n\n <img src=\"10.png\" width=\"650\"/><br>\n\n <img src=\"11.png\" width=\"650\"/><br>\n\n## Nginx安装编译参数\n\n<img src=\"WechatIMG84.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG85.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG86.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG87.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG88.png\" width=\"650\"/><br>\n\n## Nginx start/stop/resart\n\n```linux\nsystemctl start nginx.service\nsystemctl stop nginx.service\nsystemctl restart nginx.service\n```\n\n# Nginx基础\n\n## Nginx默认配置语法\n\n### nginx.conf（分三大块）\n\n```linux\nuser  nginx;\t# 设置nginx服务的系统使用用户\nworker_processes  1;\t# 工作进程数\n\nerror_log  /var/log/nginx/error.log warn;\t# nginx的错误日志\npid        /var/run/nginx.pid;\t# nginx服务启动时候pid\n# （1）以上是全局、服务模块配置\n\nevents {\n    worker_connections  1024;\t# 每个进程允许最大连接数\n    use  1;\t#\t工作进程数\n}\n# （2）以上是事件模块\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\t\t\n\t\t# 包含该文件\n    include /etc/nginx/conf.d/*.conf;\n}\n# （3）以上是http模块\n```\n\n### default.conf\n\n```linux\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log     main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```\n\n## Nginx日志\n\n- error.log\n\n处理HTTP请求的错误状态\n\n以及Nginx错误运行的状态 \n\n- access_log\n\n记录每一次请求的访问状态\n\n分析请求\n\n### log_formate\n\n- log_formate配置语法\n\n<img src=\"WechatIMG91.png\" width=\"650\"/><br>\n\n## Nginx变量\n\n<img src=\"WechatIMG92.png\" width=\"650\"/><br>\n\n## 常用命令\n\n```linux\n# -t 检查配置文件的正确与否\n# -c 路径检查\nnginx -t -c /etc/nginx/nginx.conf\nnginx -tc /etc/nginx/nginx.conf\n\n# 重载服务\nnginx -s reload -c /etc/nginx/nginx.conf\n\nps -aux|grep nginx\n\nsystemctl start nginx.service\nsystemctl stop nginx.service\nsystemctl restart nginx.service\n```\n\n## Nginx模块\n\nNginx官方模块\n\nNginx第三方模块\n\n---\n\n### http_stub_status_module\n\n- 展示nginx当前连接的状态和信息\n\n<img src=\"WechatIMG93.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG94.png\" width=\"650\"/><br>\n\n```linux\n# vim /etc/nginx/conf.d/default.conf 增加如下内容\nlocation /mystatus {\n   stub_status;\n}\n\n# 访问 http://192.168.2.243/mystatus\n\nActive connections: 3 \t# nginx当前活跃的连接数\nserver accepts handled requests\n 10 10 9 \t# nginx处理的握手次数 连接数 总的请求数\nReading: 0 Writing: 1 Waiting: 2 \t# 当前正在读的数量 正在写的数量 等待总数量（开启长连接时）\n```\n\n---\n\n### random_index_module\n\n<img src=\"WechatIMG95.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG96.png\" width=\"650\"/><br>\n\n- 实战\n\n```html\n# /opt/app/code 新建 1.html 2.html 3.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n</head>\n<body style=\"background-color: red;\">\n</body>\n</html>\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n</head>\n<body style=\"background-color: blue;\">\n</body>\n</html>\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n</head>\n<body style=\"background-color: pink;\">\n</body>\n</html>\n```\n\n```shell\n# vim /etc/nginx/conf.d/default.conf 修改增加如下内容\n\nlocation / {\n        root   /opt/app/code;\t# 不会展示隐藏文件\n        random_index on;\n       \t#index  index.html index.htm;\n}\n\n# 重载nginx服务\nsystemctl reload nginx.service\n\n# 访问 http://192.168.2.243 即可看到效果\n```\n\n---\n\n### http_sub_module\n\n<img src=\"WechatIMG97.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG98.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG99.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG100.png\" width=\"650\"/><br>\n\n```sh\nlocation / {\n        root   /opt/app/code;\n        index  index.html index.htm;\n\t\t\t\tsub_filter 'sorozy' 'isShelter';\t# 用后面的字符串替换前面的字符串\n\t\t\t\tsub_filter_once off;\t# 全局匹配，默认是 on 则只替换第一个匹配项目\n}\n\n```\n\n## Nginx请求限制\n\n### 连接频率限制 limit_conn_module\n\n<img src=\"WechatIMG161.png\" width=\"650\"/><br>\n\n### 请求频率限制 limit_req_module\n\n<img src=\"WechatIMG162.png\" width=\"650\"/><br>\n\n## Nginx的访问控制\n\n### 基于IP的访问控制 http_access_module\n\n<img src=\"WechatIMG166.png\" width=\"650\"/><br>\n\n```linux\nmv default.conf access_module.conf\n\nvim access_module.conf\n\n# 不允许本机ip访问\nlocation ~ ^/admin.html {\n  root   /opt/app/code;\n  deny 192.168.200;\n  allow all;\n  index  index.html index.htm;\n}\n\n# 只允许本机ip访问\nlocation ~ ^/admin.html {\n  root   /opt/app/code;\n  allow 192.168.2.200; # 这里也可以写成ip段\n  deny all;\n  index  index.html index.htm;\n}\n\n\n```\n\n- http_acces_module 局限性（后续再深入理解）\n\n### 基于用户的信任登录 http_auth_basic_module\n\n<img src=\"WechatIMG169.png\" width=\"650\"/><br>\n\n- 实战\n\n```linux\n# 需要安装 htpasswd\n[root@localhost nginx]# htpasswd -c ./auth_conf admin1\n\nlocation ~ ^/admin.html {\n  root   /opt/app/code;\n  auth_basic \"auth access test ! input your password\";\n  auth_basic_user_file /etc/nginx/auth_conf;\n  index  index.html index.htm;\n}\n```\n\n- http_auth_basic_module局限性（后续再深入了解）\n\n> 用户信息依赖文件方式\n>\n> 操作管理机械，效率低下\n\n解决方案\n\n<img src=\"WechatIMG170.png\" width=\"650\"/><br>\n\n# 基于Nginx的中间件架构\n\n> 1. 静态资源WEB服务\n> 2. 代理服务\n> 3. 负载均衡调度器SLB\n> 4. 动态缓存 \n\n## 静态资源web服务\n\n- 静态资源类型\n\n<img src=\"WechatIMG171.png\" width=\"650\"/><br>\n\n> 需要了解cdn\n\n### 静态资源\n\n<img src=\"WechatIMG173.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG174.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG175.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG176.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG177.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG178.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG179.png\" width=\"650\"/><br>\n\n- 实战\n\n```linux\nserver {\n    listen       80;\n    # server_name  116.62.103.228  ;\n    server_name 192.168.2.243 jeson.imooc.com;\n    sendfile on;\n    #charset koi8-r;\n    access_log  /var/log/nginx/log/static_access.log  main;\n\n    \n    location ~ .*\\.(jpg|gif|png)$ {\n        gzip on;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n        root  /opt/app/code/images;\n    }\n\n    location ~ .*\\.(txt|xml)$ {\n        gzip on;\n        gzip_http_version 1.1;\n        gzip_comp_level 1;\n        gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n        root  /opt/app/code/doc;\n    }\n\n    location ~ ^/download {\n        gzip_static on;\n        tcp_nopush on;\n        root /opt/app/code;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504 404  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```\n\n### 缓存\n\n<img src=\"WechatIMG180.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG181.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG182.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG183.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG184.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG185.png\" width=\"650\"/><br>\n\n### 跨站\n\n<img src=\"WechatIMG191.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG192.png\" width=\"650\"/><br>\n\n- 允许跨站\n\n```linux\nlocation ~ .*\\.(htm|html)$ {\n        add_header Access-Control-Allow-Origin *; \n        add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n        #expires 24h;\n        root  /opt/app/code;\n}\n```\n\n### 防盗链\n\n<img src=\"WechatIMG193.png\" width=\"650\"/><br>\n\n## 代理服务\n\n<img src=\"WechatIMG108.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG109.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG110.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG111.png\" width=\"650\"/><br>\n\n<img src=\"WechatIMG113.png\" width=\"650\"/><br>\n\n### 反向实战\n\n```linux\n# 环境准备\n# linux开启防火墙，关闭8080端口（8080端口不放行）开启80端口，80端口放行\n\n# /etc/nginx/conf.d 目录下 添加两个配置文件 fx_proxy.conf realserver.conf\n\n# fx_proxy.conf 配置\nserver {\n    listen       80;\n    server_name  localhost jeson.t.imooc.io;\n\n    #charset koi8-r;\n    access_log  /var/log/nginx/test_proxy.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n    \n    # 反向代理核心配置\n    location ~ /test_proxy.html$ {\n        proxy_pass http://127.0.0.1:8080;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\nserver {\n    listen       8080;\n    server_name  localhost jeson.t.imooc.io;\n\n    #charset koi8-r;\n    access_log  /var/log/nginx/server.access.log  main;\n\n\t\t# 注意在该目录下 /opt/app/code2 放入html文件\n    location / {\n        root   /opt/app/code2;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n# 结果\n# http://172.20.94.55:8080/test_proxy.html 不可访问\n# http://172.20.94.55/test_proxy.html 可访问\n```\n\n### 正向代理实战（待完成）\n\n## 负载均衡\n\n\n\n\n\n\n\n---\n\n","tags":["nginx","中间件"],"categories":["nginx","中间件"]},{"title":"hexo 常见操作","url":"/2020/05/26/hexo-常见操作/","content":"\n- hexo常用命令\n\n```shell\n# 建立文章草稿\nhexo new draft <title>\n\n# 本机预览草稿\nhexo S --draft\n\n# 将草稿发布为正式文章\nhexo P <filename>\n\n# 生成静态文件\nhexo generate\n\n# 部署\nhexo deploy\n\n# 生成后部署\nhexo g -d\n\n```\n\n<br>\n\n- hexo链接到站内文章指定锚点\n\n```markdown\n<a href=\"{% post_path 'hexo blog' %}#安装\">hexo 安装</a>\n\n<a href=\"{% post_path '《图解HTTP》read notes' %}#编码提升传输速率\">http的编码提升传输速率</a>\n```\n\n<a href=\"{% post_path '《图解HTTP》read notes' %}#编码提升传输速率\">http的编码提升传输速率</a>\n\n<br>\n\n- hexo添加多个categories\n\n```markdown\ncategories:\n\t- [algorithm]\n\t- [data-structure]\n```\n\n<br>\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"Nginx study notes","url":"/2020/05/25/Nginx-study-notes/","content":"\n\n\n# Nginx install & start\n\n## install dependencies\n\n- install pcre\n\n```shell\n# 这里我选择下载到 /usr/src\nwget https://ftp.pcre.org/pub/pcre/pcre-8.37.tar.gz\n\n# 解压\ntar -xvf pcre-8.37.tar.gz\n\n# 进入解压后的主目录（pcre-8.37）执行下面的命令\n./configure\n\n# 执行 ./configure时候，可能会报错（没有c、c++的支持），则安装相关依赖即可\n# 安装c依赖\nyum -y install gcc\n# 安装c++依赖\nyum install -y gcc gcc-c++\n\n# 进入主目录（pcre-8.37）执行下面命令\nmake && make install\n\n# 至此，安装完成，执行下面命令，查看版本\npcre-config --version\n```\n\n- install other dependencies\n\n```shell\n# zlib openssl\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n## install Nginx\n\n```shell\n# 准备好nginx包\n\n# 解压nginx-xx.tar.zg包\ntar -xvf [nginx-xx.tar.zg]\n\n# 进入解压目录，执行\n./configure\n\n# 进入解压目录，执行\nmake && make install\n```\n\n## start Nginx\n\n```shell\n# nginx安装完成后，会在 /usr/local/ 目录下生成一个nginx文件夹\n\n# 进入 /usr/local/nginx/sbin 执行\n./nginx\n\n# 至此，nginx启动，访问ip可以看到welcome页面，（注意开启端口，或关闭防火墙）\n```\n\n","tags":["Nginx","web-Server"],"categories":["Nginx","web-Server"]},{"title":"《图解HTTP》read notes","url":"/2020/05/22/《图解HTTP》read notes/","content":"\n[TOC]\n\n# 了解web及网络基础\n\n## HTTP\n\n（HyperText Transfer Protocol）\n\n- 通常使用的网络协议是TCP/IP 协议族上运作的，HTTP是其内部的一个子集\n-  TCP/IP 分层好处：把各层之间的接口设计好，其内部就可以自由改动\n\n\n\n##  TCP/IP协议分层\n\n|              分层               |                             作用                             |             备注              |\n| :-----------------------------: | :----------------------------------------------------------: | :---------------------------: |\n|             应用层              |             决定了向用户提供应用服务时通信的活动             |                               |\n|             传输层              |     对上层应用层，提供处于网络连接中两台计算机的数据传输     | 有两个性质不同的协议TCP、 UDP |\n|      网络层（网络互联层）       | 处理在网络上流动的数据包<br/>（数据包是网络传输的最小单位）<br/>规定了通过怎样的路径到达对方计算机，并把数据包传送给对方 |                               |\n| 链路层（数据链路层/网络接口层） |                    处理连接网络的硬件部分                    |                               |\n\n\n\n## IP（Internet Protocol）\n\n- 位于网络层\n- 作用：把各种数据包传送给对方\n- 重要条件\n\n> IP地址：指明了节点被分配到的地址\n>\n> MAC地址：指网卡所属的固定地址\n>\n> IP地址可以和MAC地址配对，IP可变换，MAC地址基本不会改变\n\n\n\n## ARP协议\n\nIP间的通信依赖MAC地址\n\nARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对方的MAC地址\n\n\n\n## TCP协议\n\n- 提供可靠的字节流服务\n\n> 为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理\n>\n> 能够把数据准确可靠的传送给对方\n\n- 为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否到达对方\n- 为了准确无误把数据送达对方，采用了三次握手策略\n\n\n\n## DNS（Domain Name System）\n\nDNs协议提供从域名查找IP，或逆向从IP反查域名的服务\n\n\n\n## URI（统一资源标识符）\n\n用字符串标识某一互联网资源\n\n\n\n### URI格式\n\n\n\n## URL\n\n> 表示资源的地点\n\n\n\n# 简单的HTTP协议\n\n## 请求报文构成\n\n<img src=\"tjhttp-req-bw.png\" width=\"650\"/>\n\n\n\n## 响应报文构成\n\n<img src=\"1590118989509-4d5d74da-3a96-4576-8000-18dfc9d51ffd.png\" width=\"650\"/>\n\n\n\n## HTTP是无状态协议\n\n> 对发送过的请求或响应不做持久化处理\n>\n> 为了期望保持状态功能，引入了cookie技术\n\n\n\n## HTTP方法\n\n<img src=\"1590123329116-9aaf96d8-f801-49c4-a844-210cb8f3063d.png\" width=\"650\"/>\n\n- HTTP/1.1的PUT/DELETE方法不带验证机制，任何人都可以上传文件，存在安全问题，一般网站不使用该方法，若配合web应用程序的验证机制，或架构设计采用REST标准的同类web网站，则可能开放使用PUT/DELETE方法\n\n\n\n## 持久连接（HTTP keep-alive）\n\n> 持久连接的好处在于：减少了tcp连接的重复建立和断开所造成的额外开销，减轻了服务器的负载\n>\n> 在HTTP/1.1中，默认都是持久连接\n>\n> 持久连接使得多数请求以管线化方式发送成为可能，不用等待响应亦可发送下一个请求。能够做到同时并行发送多个请求\n\n\n\n## 使用cookie的状态管理\n\n<img src=\"1590124489186-9d978bd8-67a8-44c0-aec8-a38d00bb277c.png\" width=\"650\"/>\n\n\n\n### cookie交互场景下，请求报文与响应报文\n\n<img src=\"1590124671111-ee605c31-15b1-4eef-9664-656829873298.png\" width=\"650\"/>\n\n<img src=\"1590124686480-814917fe-0d61-4ae3-8ed2-1618159890cd.png\" width=\"650\"/>\n\n\n\n### 编码提升传输速率\n\n- 常见的编码方式\n\n> - gzip\n> - compress\n> - deflate\n> - identity（不进行编码）\n\n\n\n### 获取部分内容的范围请求\n\n- 使用首部字段的Range来指定资源的byte范围\n\n- 5001 ～ 10000 字节\n\n```http\nRange: bytes=5001-10000\n```\n\n- 从5001字节之后全部的\n\n```http\nRange: bytes=5001-\n```\n\n- 从一开始3000字节和5000-7000字节的多重范围\n\n```http\nRange: bytes=-3000,5000-7000\n```\n\n\n\n## 内容协商返回最合适的内容\n\n- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源\n\n- 内容协商技术类型\n\n> 服务器驱动协商\n>\n> 客户端驱动协商\n>\n> 透明协商\n\n\n\n# 返回结果的HTTP状态码\n\n## 状态码分类\n\n| 状态码 |               类别               |          原因短语          |\n| :----: | :------------------------------: | :------------------------: |\n|  1xx   |  Informational（信息性状态码）   |     接收的请求正在处理     |\n|  2xx   |      Success（成功状态码）       |      请求正常处理完毕      |\n|  3xx   |   Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |\n|  4xx   | Client Error（客户端错误状态码） |     服务器无法处理请求     |\n|  5xx   | Server Error（服务器错误状态码） |     服务器处理请求出错     |\n\n\n\n### 2xx\n\n|   状态码 原因短语   |           简单说明            |\n| :-----------------: | :---------------------------: |\n|       200 OK        | Informational（信息性状态码） |\n|   204 No Content    | 请求处理成功，但没有资源返回  |\n| 206 Partial Content |  Redirection（重定向状态码）  |\n\n\n\n### 3xx\n\n|    状态码 原因短语     |           简单说明            |\n| :--------------------: | :---------------------------: |\n| 301 Moved Permanently  |        资源URL已经更行        |\n|       302 Found        | 请求处理成功，但没有资源返回  |\n|     303 See Other      | 客户端应当采用GET方法获取资源 |\n|    304 Not Modified    | 资源已找到，但未符合条件请求  |\n| 307 Temporary Redirect |          临时重定向           |\n\n\n\n### 4xx\n\n| 状态码 原因短语  |             简单说明             |\n| :--------------: | :------------------------------: |\n| 400 Bad Request  |      请求报文中存在语法错误      |\n| 401 Unauthorized | 请求需要有通过HTTP认证的认证信息 |\n|  403 Forbidden   |         访问被服务器拒绝         |\n|  404 Not Found   |        服务器上未找到资源        |\n\n\n\n### 5xx\n\n|      状态码 原因短语      |                   简单说明                   |\n| :-----------------------: | :------------------------------------------: |\n| 500 Internal Server Error |         服务器在执行请求时发生了错误         |\n|  503 Service Unavailable  | 服务器处于超负荷或停机维护状态，无法处理请求 |\n\n# HTTP 协作的web服务器\n\n## 代理\n\n- 使用代理服务器的理由\n\n> 利用缓存技术，减少网络带宽的流量\n>\n> 组织内部对特定网站的访问控制\n>\n> 以获取访问日志为主要目的\n\n- 代理按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文\n\n- 缓存代理\n\n> 预先将资源缓存在代理服务器上\n\n- 透明代理\n\n> 不对报文做任何加工\n\n\n\n## 网关\n\n- 使通信线路上的服务器提供非http协议服务\n- 提高通信安全性，在客户端和网关的通信线路上加密以确保连接安全\n\n\n\n## 隧道\n\n- 建立起与其它服务器的通信线路\n\n\n\n# HTTP首部\n\n- 首部内容较多\n- 后续学习会补上相关笔记\n\n\n\n# 确保安全的HTTPS\n\n## HTTP的缺点和不足\n\n> 通信使用明文（不加密），内容可能会被窃听\n>\n> 不验证通信方的身份，因此有可能遭遇伪装\n>\n> 无法证明报文的完整性，所以有可能已遭篡改\n\n- TCP/IP是可能被窃听的网络\n\n## 防窃听保护信息的几种对策\n\n- 通信的加密\n\n  > 通过和SSL或TSL的组合使用（HTTPS），加密HTTP的通信内容\n\n- 内容的加密\n\n- HTTPS是身披SSL外壳的HTTP\n\n  > HTTPS:只是HTTP通信接口部分用SSL和TSL协议代替而已\n\n\n\n### HTTP安全通信机制\n\n- 待整理完成\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<br>\n\n<br>\n\n\n\n\n\n","tags":["http","network","read-notes"],"categories":["http","network","read-notes"]},{"title":"DataStructure & Algorithm - Array","url":"/2020/05/04/DataStructure-Algorithm-Array/","content":"\n# Array介绍\n\n- <font color=red >数组（Array）是一种**线性表**数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据</font>\n- 数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”\n\n\n\n- 连续的内存空间和相同类型的数据\n\n> **根据下标随机访问的时间复杂度为 O(1)**\n>\n> 要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作\n\n\n\n- 低效的“插入”和“删除”\n\n> O(n)\n>\n> 插入改进：直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置\n>\n> 删除改进：记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移\n\n\n\n# 与ArrayList比较\n\n（1）最大的优势就是可以将很多数组操作的细节封装起来，支持动态扩容\n\n（2）完全不需要关心底层的扩容逻辑\n\n（3）扩容操作涉及内存申请和数据搬移，比较耗时，最好在创建 ArrayList 的时候事先指定数据大小\n\n（4）Java ArrayList 无法存储基本类型\n\n\n\n# 为何数组从0开始编号\n\n> “下标”最确切的定义应该是“偏移（offset）”\n>\n> a[0]就是偏移为 0 的位置，也就是首地址\n>\n> 原因：减少一次减法指令\n\n```java\na[i]_address = base_address + i * data_type_size\n```\n\n\n\n# 线性表与非线性表\n\n- 线性表（Linear List）\n\n> 数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向\n>\n> 线性表数据结构：数组，链表、队列、栈等\n\n- 非线性表\n\n> 二叉树、堆、图等\n>\n> 在非线性表中，数据之间并不是简单的前后关系\n\n# implement dynamic array\n\n```java\npublic class Array<E> {\n\n    private E[] data;\n    private int size;\n\n    // 构造函数，传入数组的容量capacity构造Array\n    public Array(int capacity){\n        data = (E[])new Object[capacity];\n        size = 0;\n    }\n\n    // 无参数的构造函数，默认数组的容量capacity=10\n    public Array(){\n        this(10);\n    }\n\n    // 获取数组的容量\n    public int getCapacity(){\n        return data.length;\n    }\n\n    // 获取数组中的元素个数\n    public int getSize(){\n        return size;\n    }\n\n    // 返回数组是否为空\n    public boolean isEmpty(){\n        return size == 0;\n    }\n\n    // 在index索引的位置插入一个新元素e\n    public void add(int index, E e){\n\n        if(index < 0 || index > size)\n            throw new IllegalArgumentException(\"Add failed. Require index >= 0 and index <= size.\");\n\n        if(size == data.length)\n            resize(2 * data.length);\n\n        for(int i = size - 1; i >= index ; i --)\n            data[i + 1] = data[i];\n\n        data[index] = e;\n\n        size ++;\n    }\n\n    // 向所有元素后添加一个新元素\n    public void addLast(E e){\n        add(size, e);\n    }\n\n    // 在所有元素前添加一个新元素\n    public void addFirst(E e){\n        add(0, e);\n    }\n\n    // 获取index索引位置的元素\n    public E get(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Get failed. Index is illegal.\");\n        return data[index];\n    }\n\n    public E getLast(){\n        return get(size-1);\n    }\n    \n    public E getFirst(){\n        return get(0);\n    }\n    \n    // 修改index索引位置的元素为e\n    public void set(int index, E e){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Set failed. Index is illegal.\");\n        data[index] = e;\n    }\n\n    // 查找数组中是否有元素e\n    public boolean contains(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return true;\n        }\n        return false;\n    }\n\n    // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1\n    public int find(E e){\n        for(int i = 0 ; i < size ; i ++){\n            if(data[i].equals(e))\n                return i;\n        }\n        return -1;\n    }\n\n    // 从数组中删除index位置的元素, 返回删除的元素\n    public E remove(int index){\n        if(index < 0 || index >= size)\n            throw new IllegalArgumentException(\"Remove failed. Index is illegal.\");\n\n        E ret = data[index];\n        for(int i = index + 1 ; i < size ; i ++)\n            data[i - 1] = data[i];\n        size --;\n        data[size] = null; // loitering objects != memory leak\n\n        if(size == data.length / 4 && data.length / 2 != 0)\n            resize(data.length / 2);\n        return ret;\n    }\n\n    // 从数组中删除第一个元素, 返回删除的元素\n    public E removeFirst(){\n        return remove(0);\n    }\n\n    // 从数组中删除最后一个元素, 返回删除的元素\n    public E removeLast(){\n        return remove(size - 1);\n    }\n\n    // 从数组中删除元素e\n    public void removeElement(E e){\n        int index = find(e);\n        if(index != -1)\n            remove(index);\n    }\n\n    @Override\n    public String toString(){\n\n        StringBuilder res = new StringBuilder();\n        res.append(String.format(\"Array: size = %d , capacity = %d\\n\", size, data.length));\n        res.append('[');\n        for(int i = 0 ; i < size ; i ++){\n            res.append(data[i]);\n            if(i != size - 1)\n                res.append(\", \");\n        }\n        res.append(']');\n        return res.toString();\n    }\n\n    // 将数组空间的容量变成newCapacity大小\n    private void resize(int newCapacity){\n\n        E[] newData = (E[])new Object[newCapacity];\n        for(int i = 0 ; i < size ; i ++)\n            newData[i] = data[i];\n        data = newData;\n    }\n}\n```\n\n","tags":["algorithm","data-structure"],"categories":["algorithm","data-structure"]},{"title":"DataStructure & Algorithm - complexity analysis","url":"/2020/05/04/DataStructure-Algorithm-complexity-analysis/","content":"\n- 复杂度分析是整个算法学习的精髓\n\n# 为什么需要复杂度分析？\n\n（1）测试结果非常依赖测试环境\n\n（2）测试结果受数据规模的影响很大\n\n> 我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。\n>\n> 时间、空间复杂度分析方法\n\n# 大 O 复杂度表示法\n\n（1）<font color=red>**代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**</font>\n\n```shell\nT(n)=O(f(n))\n```\n\n（2）<font color=red>**大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度**</font>\n\n（3）在采用大 O 标记复杂度的时候，可以忽略系数，即 `O(Cf(n)) = O(f(n))`\n\n# 时间复杂度分析\n\n（1）只关注循环执行次数最多的一段代码\n\n（2）加法法则：总复杂度等于量级最大的那段代码的复杂度\n\n（3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n> 并不用刻意去记忆。复杂度分析这个东西关键在于“熟练”。你只要多看案例，多分析，就能做到“无招胜有招”\n\n# 几种常见时间复杂度实例分析\n\n- 粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2^n) 和 O(n!)\n\n- 时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题\n\n|   复杂度量级   |          | 说明                                                         |\n| :------------: | :------: | :----------------------------------------------------------- |\n|   常数复杂度   |   O(1)   | 代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1) <br>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1) |\n|   对数复杂度   | O(log n) | O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn) |\n| 线性时间复杂度 |   O(n)   |                                                              |\n|      平⽅      |  O(n^2)  |                                                              |\n|      ⽴方      |  O(n^3)  |                                                              |\n|      指数      |  O(2^n)  |                                                              |\n|      阶乘      |  O(n!)   |                                                              |\n\n## O(logn)、O(nlogn)\n\n```java\n i=1;\n while (i <= n)  {\n   i = i * 2;\n }\n```\n\n## O(m+n)、O(m*n)\n\n- 代码的复杂度由两个数据的规模来决定\n\n```java\nint cal(int m, int n) {\n  int sum_1 = 0;\n  int i = 1;\n  for (; i < m; ++i) {\n    sum_1 = sum_1 + i;\n  }\n\n  int sum_2 = 0;\n  int j = 1;\n  for (; j < n; ++j) {\n    sum_2 = sum_2 + j;\n  }\n\n  return sum_1 + sum_2;\n}\n```\n\n# 空间复杂度分析\n\n- 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系\n- 常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多，掌握以上即可\n\n```java\n// 整段代码的空间复杂度就是 O(n)\n\nvoid print(int n) {\n  int i = 0;\n  int[] a = new int[n];\n  for (i; i <n; ++i) {\n    a[i] = i * i;\n  }\n\n  for (i = n-1; i >= 0; --i) {\n    print out a[i]\n  }\n}\n```\n\n# 大O 复杂度曲线\n\n<img src=\"big_O_chart.png\" width=\"650\"/>\n\n# 时间复杂度分析方法\n\n## 代码在不同情况下的不同时间复杂度\n\n- 最好情况时间复杂度（best case time complexity）<br>\n\n- 最坏情况时间复杂度（worst case time complexity）<br>\n\n- 平均情况时间复杂度（average case time complexity）<br>\n\n- 均摊时间复杂度（amortized time complexity）\n\n\n\n- 均摊时间复杂度\n\n> 对应的分析方法，摊还分析（或者叫平摊分析）<br>\n>\n> 摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度<br>\n>\n> 均摊时间复杂度就是一种特殊的平均时间复杂度<br>\n\n> 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度\n","tags":["algorithm","data-structure"],"categories":["algorithm","data-structure"]}]