<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="聂小涛的博客">
    <meta name="keyword" content="腾讯">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        《透视HTTP协议》study notes - AirCloud的博客 | AirCloud&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> sometimes code， sometimes design </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Xiaotao Nie</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#学习备注"><span class="toc-text">学习备注</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP发展史（来龙去脉）"><span class="toc-text">HTTP发展史（来龙去脉）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#来源"><span class="toc-text">来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-0-9"><span class="toc-text">HTTP/0.9</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-0"><span class="toc-text">HTTP/1.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP/1.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2"><span class="toc-text">HTTP/2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-3"><span class="toc-text">HTTP/3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP概念"><span class="toc-text">HTTP概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP（HyperText-Transfer-Protocol）超文本传输协议"><span class="toc-text">HTTP（HyperText Transfer Protocol）超文本传输协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-是什么？"><span class="toc-text">HTTP 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP知识地图"><span class="toc-text">HTTP知识地图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#与HTTP相关的各种概念"><span class="toc-text">与HTTP相关的各种概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#网络世界"><span class="toc-text">网络世界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器（Web-Browser）"><span class="toc-text">浏览器（Web Browser）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-服务器（Web-Server）"><span class="toc-text">Web 服务器（Web Server）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件"><span class="toc-text">硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软件"><span class="toc-text">软件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN（Content-Delivery-Network）"><span class="toc-text">CDN（Content Delivery Network）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#爬虫（Crawler）"><span class="toc-text">爬虫（Crawler）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-WebService-WAF"><span class="toc-text">HTML/WebService/WAF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP"><span class="toc-text">TCP/IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP协议（Internet-Protocol）"><span class="toc-text">IP协议（Internet Protocol）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-协议（Transmission-Control-Protocol）（传输控制协议）"><span class="toc-text">TCP 协议（Transmission Control Protocol）（传输控制协议）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS（Domain-Name-System）（域名系统"><span class="toc-text">DNS（Domain Name System）（域名系统)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URI-URL"><span class="toc-text">URI/URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS（HTTP-over-SSL-TLS）"><span class="toc-text">HTTPS（HTTP over SSL/TLS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-TLS"><span class="toc-text">SSL/TLS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络分层模型"><span class="toc-text">网络分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-网络分层模型"><span class="toc-text">TCP/IP 网络分层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI-网络分层模型"><span class="toc-text">OSI 网络分层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个分层模型的映射关系"><span class="toc-text">两个分层模型的映射关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-协议栈的工作方式"><span class="toc-text">TCP/IP 协议栈的工作方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DNS"><span class="toc-text">DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#域名作用与形式"><span class="toc-text">域名作用与形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#域名的解析"><span class="toc-text">域名的解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS缓存"><span class="toc-text">DNS缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#域名玩法"><span class="toc-text">域名玩法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS解析过程"><span class="toc-text">DNS解析过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#搭建HTTP实验环境"><span class="toc-text">搭建HTTP实验环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#键入网址再按下回车，后面究竟发生了什么"><span class="toc-text">键入网址再按下回车，后面究竟发生了什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP报文"><span class="toc-text">HTTP报文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP报文"><span class="toc-text">TCP报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP报文-1"><span class="toc-text">HTTP报文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#请求行（request-line）"><span class="toc-text">请求行（request line）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态行（status-line）"><span class="toc-text">状态行（status line）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#头部字段"><span class="toc-text">头部字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用头字段"><span class="toc-text">常用头字段</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP方法"><span class="toc-text">HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安全、幂等"><span class="toc-text">安全、幂等</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#URI"><span class="toc-text">URI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#课后问题"><span class="toc-text">课后问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP响应状态码"><span class="toc-text">HTTP响应状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1××"><span class="toc-text">1××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2××"><span class="toc-text">2××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3××"><span class="toc-text">3××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4××"><span class="toc-text">4××</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5××"><span class="toc-text">5××</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP特点"><span class="toc-text">HTTP特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP优缺点"><span class="toc-text">HTTP优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP实体数据"><span class="toc-text">HTTP实体数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型与编码"><span class="toc-text">数据类型与编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分块传输"><span class="toc-text">分块传输</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分块传输的编码规则"><span class="toc-text">分块传输的编码规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#范围请求（range-requests）"><span class="toc-text">范围请求（range requests）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多段数据"><span class="toc-text">多段数据</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> sometimes code， sometimes design </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        《透视HTTP协议》study notes
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-06-24 15:24:06</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#http" title="http">http</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#network" title="network">network</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><ol>
<li>好需要好好熟悉3次握手、四次挥手</li>
<li>需要对头字段进行整理</li>
<li>各种方法详解需要熟悉（熟悉自定义方法？）</li>
<li>安全幂等需要熟悉</li>
</ol>
<hr>
<h1 id="HTTP发展史（来龙去脉）"><a href="#HTTP发展史（来龙去脉）" class="headerlink" title="HTTP发展史（来龙去脉）"></a>HTTP发展史（来龙去脉）</h1><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>1989 年，蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。</p>
<blockquote>
<ol>
<li>URI：统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML：即超文本标记语言，描述超文本文档；</li>
<li>HTTP：即超文本传输协议，用来传输超文本。</li>
</ol>
</blockquote>
<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>20 世纪 90 年代初期发布。</p>
<p>只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接</p>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>1996 年正式发布（确立了大部分现在使用的技术，但它不是正式标准）</p>
<blockquote>
<ol>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ol>
</blockquote>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616（它是一个“正式的标准”）</p>
<blockquote>
<ol>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ol>
</blockquote>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><ul>
<li>连接慢，无法跟上迅猛发展的互联网</li>
<li>2015 年发布了 HTTP/2，RFC 编号 7540</li>
<li>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及（Google 顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议）</li>
<li>HTTP/2 的制定充分考虑了现今互联网的现状：<strong>宽带、移动、不安全</strong>，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</li>
</ul>
<blockquote>
<ol>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ol>
</blockquote>
<h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h2><ul>
<li>Google 又发明了一个新的协议，叫做 QUIC。</li>
<li>2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段</li>
<li>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向</li>
</ul>
<h1 id="HTTP概念"><a href="#HTTP概念" class="headerlink" title="HTTP概念"></a>HTTP概念</h1><h2 id="HTTP（HyperText-Transfer-Protocol）超文本传输协议"><a href="#HTTP（HyperText-Transfer-Protocol）超文本传输协议" class="headerlink" title="HTTP（HyperText Transfer Protocol）超文本传输协议"></a>HTTP（HyperText Transfer Protocol）超文本传输协议</h2><ul>
<li>协议</li>
</ul>
<blockquote>
<p>协：必须要有两个或多个参与者<br></p>
<p>议：对参与者的一种行为约定和规范</p>
</blockquote>
<ul>
<li>传输</li>
</ul>
<blockquote>
<p>发起传输动作的叫做<strong>请求方</strong><br></p>
<p>后接到传输的叫做<strong>应答方</strong>或者<strong>响应方</strong></p>
</blockquote>
<ul>
<li>超文本</li>
</ul>
<blockquote>
<p>HTTP眼里的“文本”：图片、音频、视频、甚至是压缩包<br></p>
<p>超文本：“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”</p>
</blockquote>
<h2 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a><font color="red">HTTP 是什么？</font></h2><font color="red"><strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></font>

<p><br></p>
<ul>
<li>HTTP 不是一个孤立的协议</li>
</ul>
<blockquote>
<p><font color="red">HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。</font>此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位</p>
</blockquote>
<ul>
<li><font color="red"><strong>HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接</strong></font>

</li>
</ul>
<h2 id="HTTP知识地图"><a href="#HTTP知识地图" class="headerlink" title="HTTP知识地图"></a>HTTP知识地图</h2><p><img src="http-all.png" width="650"></p>
<h1 id="与HTTP相关的各种概念"><a href="#与HTTP相关的各种概念" class="headerlink" title="与HTTP相关的各种概念"></a>与HTTP相关的各种概念</h1><h2 id="网络世界"><a href="#网络世界" class="headerlink" title="网络世界"></a>网络世界</h2><ul>
<li>实际的互联网是由许许多多个规模略小的网络连接而成的</li>
</ul>
<blockquote>
<p>这些“小网络”可能是:只有几百台电脑的局域网，可能是有几万、几十万台电脑的广域网，可能是用电缆、光纤构成的固定网络，也可能是用基站、热点构成的移动网络……</p>
</blockquote>
<ul>
<li><p>互联网的正式名称是 Internet</p>
</li>
<li><p>互联网的一个子集“万维网”（World Wide Web）(即：我们通常所说的“上网”)</p>
</li>
</ul>
<blockquote>
<p>它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内</p>
</blockquote>
<ul>
<li>万维网之外的资源</li>
</ul>
<blockquote>
<p>电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等</p>
</blockquote>
<ul>
<li>互联网上绝大部分资源都使用 HTTP 协议传输</li>
</ul>
<h2 id="浏览器（Web-Browser）"><a href="#浏览器（Web-Browser）" class="headerlink" title="浏览器（Web Browser）"></a>浏览器（Web Browser）</h2><blockquote>
<p>检索、查看互联网上网页资源的应用程序，名字里的 Web，指“World Wide Web”（万维网）</p>
<p>本质上是一个 HTTP 协议中的<strong>请求方</strong>，使用 HTTP 协议获取网络上的各种资源<br></p>
</blockquote>
<blockquote>
<p>集成了很多额外的功能：HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，甚至还有开发者工具用来调试网页，以及五花八门的各种插件和扩展<br></p>
</blockquote>
<blockquote>
<p>HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求</p>
</blockquote>
<ul>
<li>Linux上的wget、curl等命令工具基于HTTP，也是一种user agent</li>
</ul>
<h2 id="Web-服务器（Web-Server）"><a href="#Web-服务器（Web-Server）" class="headerlink" title="Web 服务器（Web Server）"></a>Web 服务器（Web Server）</h2><ul>
<li>HTTP 协议里响应请求的主体</li>
<li>两个层面的含义：硬件和软件</li>
</ul>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><blockquote>
<p><strong>硬件</strong>含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。</p>
</blockquote>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><blockquote>
<p>提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。</p>
</blockquote>
<ul>
<li>常见Web Server</li>
</ul>
<blockquote>
<p>Apache</p>
<p>Nginx：Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展</p>
<p>Windows 上的 IIS、Java 的 Jetty/Tomcat 等</p>
</blockquote>
<h2 id="CDN（Content-Delivery-Network）"><a href="#CDN（Content-Delivery-Network）" class="headerlink" title="CDN（Content Delivery Network）"></a>CDN（Content Delivery Network）</h2><ul>
<li>CDN：Content Delivery Network（内容分发网络）</li>
</ul>
<blockquote>
<p>应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求</p>
</blockquote>
<ul>
<li><p>CDN 位于浏览器和服务器之间</p>
</li>
<li><p>CDN 的好处：缓存源站的数据</p>
</li>
</ul>
<blockquote>
<p>除去网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分</p>
</blockquote>
<h2 id="爬虫（Crawler）"><a href="#爬虫（Crawler）" class="headerlink" title="爬虫（Crawler）"></a>爬虫（Crawler）</h2><ul>
<li><p>一种可以自动访问 Web 资源的应用程序</p>
</li>
<li><p>爬虫来源？</p>
</li>
</ul>
<blockquote>
<p>绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面</p>
</blockquote>
<ul>
<li>爬虫不好的一面</li>
</ul>
<blockquote>
<p>它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏</p>
</blockquote>
<ul>
<li>“反爬虫”技术</li>
</ul>
<blockquote>
<p>通过各种手段来限制爬虫<br></p>
<p>“君子协定”robots.txt，约定哪些该爬，哪些不该爬</p>
</blockquote>
<ul>
<li>“爬虫”、“反爬虫”基本技术： HTTP、 HTML</li>
</ul>
<h2 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML/WebService/WAF"></a>HTML/WebService/WAF</h2><ul>
<li><p><strong>HTML</strong>描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面</p>
</li>
<li><p><strong>Web Service</strong>是一种由 W3C 定义的应用服务开发规范</p>
</li>
</ul>
<blockquote>
<p><strong>基于 Web（HTTP）的服务架构技术</strong></p>
</blockquote>
<ul>
<li><strong>WAF</strong>（“网络应用防火墙”）</li>
</ul>
<blockquote>
<p>应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术</p>
</blockquote>
<blockquote>
<p>WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx</p>
</blockquote>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul>
<li>TCP/IP 协议是目前网络世界“事实上”的标准通信协议</li>
<li>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是<strong>TCP</strong>和<strong>IP</strong>，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈</li>
<li><strong>TCP 属于“传输层”，IP 属于“网际层”</strong></li>
</ul>
<h3 id="IP协议（Internet-Protocol）"><a href="#IP协议（Internet-Protocol）" class="headerlink" title="IP协议（Internet Protocol）"></a>IP协议（Internet Protocol）</h3><hr>
<ul>
<li>主要解决寻址和路由问题，以及如何在两点间传送数据包</li>
<li>IP 协议使用“<strong>IP 地址</strong>”的概念来定位互联网上的每一台计算机</li>
</ul>
<h3 id="TCP-协议（Transmission-Control-Protocol）（传输控制协议）"><a href="#TCP-协议（Transmission-Control-Protocol）（传输控制协议）" class="headerlink" title="TCP 协议（Transmission Control Protocol）（传输控制协议）"></a>TCP 协议（Transmission Control Protocol）（传输控制协议）</h3><ul>
<li>位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础</li>
</ul>
<blockquote>
<p>“可靠”是指保证数据不丢失<br></p>
<p>“字节流”是指保证数据完整</p>
</blockquote>
<blockquote>
<font color="red">TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收</font>
</blockquote>
<h2 id="DNS（Domain-Name-System）（域名系统"><a href="#DNS（Domain-Name-System）（域名系统" class="headerlink" title="DNS（Domain Name System）（域名系统)"></a>DNS（Domain Name System）（域名系统)</h2><ul>
<li>在DNS中，“域名”（Domain Name）又称为“主机名”（Host）</li>
</ul>
<p>更多请参考：<a href="#DNS">DNS</a></p>
<h2 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h2><p>更多请参考：<a href="#URI">URI</a></p>
<h2 id="HTTPS（HTTP-over-SSL-TLS）"><a href="#HTTPS（HTTP-over-SSL-TLS）" class="headerlink" title="HTTPS（HTTP over SSL/TLS）"></a>HTTPS（HTTP over SSL/TLS）</h2><ul>
<li>运行在 SSL/TLS 协议上的 HTTP</li>
<li>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”</li>
</ul>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><ul>
<li>负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层</li>
<li>SSL：（Secure Socket Layer）后改名（Transport Layer Security）</li>
<li>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲</li>
</ul>
<p>##代理（Proxy）</p>
<ul>
<li><p>HTTP 协议中请求方和应答方中间的一个环节，既可以转发客户端的请求，也可以转发服务器的应答</p>
</li>
<li><p>常见代理</p>
</li>
</ul>
<blockquote>
<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求；</li>
<li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li>
</ol>
</blockquote>
<ul>
<li>可以做：</li>
</ul>
<blockquote>
<ol>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩、加密等额外的功能。</li>
</ol>
</blockquote>
<h1 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h1><h2 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h2><p><img src="h1.png" width="650"></p>
<ul>
<li>第一层叫“链接层”（link layer）</li>
</ul>
<blockquote>
<p>负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>
</blockquote>
<ul>
<li>第二层叫“网际层”或者“网络互连层”（internet layer）</li>
</ul>
<blockquote>
<p>IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>
</blockquote>
<ul>
<li>第三层叫“传输层”（transport layer）</li>
</ul>
<blockquote>
<p>这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>
</blockquote>
<ul>
<li>第四层叫“应用层”（application layer）</li>
</ul>
<blockquote>
<p>由于下面的三层把基础打得非常好，所以在这一层就有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 、 HTTP</p>
</blockquote>
<p><br></p>
<blockquote>
<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包</p>
</blockquote>
<h2 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h2><ul>
<li>OSI：（Open System Interconnection Reference Model）开放式系统互联通信参考模型</li>
</ul>
<p><img src="h2.png" width="650"></p>
<ul>
<li>OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</li>
</ul>
<blockquote>
<ol>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。</li>
</ol>
</blockquote>
<ul>
<li>OSI模型优点</li>
</ul>
<blockquote>
<p>TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整。</p>
</blockquote>
<h2 id="两个分层模型的映射关系"><a href="#两个分层模型的映射关系" class="headerlink" title="两个分层模型的映射关系"></a>两个分层模型的映射关系</h2><p><img src="h3.png" width="650"></p>
<blockquote>
<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>
</blockquote>
<ul>
<li>四层负载均衡</li>
</ul>
<blockquote>
<p>工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡</p>
</blockquote>
<ul>
<li>七层负载均衡</li>
</ul>
<blockquote>
<p>工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器</p>
</blockquote>
<h2 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h2><p><img src="h4.png" width="650"></p>
<ul>
<li><p>凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。</p>
</li>
<li><p>二层转发</p>
</li>
</ul>
<blockquote>
<p>设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播</p>
</blockquote>
<ul>
<li>三层路由</li>
</ul>
<blockquote>
<p>设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关</p>
</blockquote>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="域名作用与形式"><a href="#域名作用与形式" class="headerlink" title="域名作用与形式"></a>域名作用与形式</h2><blockquote>
<ol>
<li><p>代替IP</p>
</li>
<li><p>可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令</p>
</li>
</ol>
</blockquote>
<ul>
<li><p>本质上是一个名字空间系统</p>
</li>
<li><p>域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低</p>
<h2 id="域名的解析"><a href="#域名的解析" class="headerlink" title="域名的解析"></a>域名的解析</h2></li>
<li><p><font color="red"><strong>DNS 的核心系统是一个三层的树状、分布式服务</strong></font>，基本对应域名的结构：</p>
</li>
</ul>
<blockquote>
<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com" target="_blank" rel="noopener">www.apple.com</a> 的 IP 地址。</li>
</ol>
</blockquote>
<ul>
<li>目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到</li>
<li>访问“<a href="http://www.apple.com”，就要进行下面的三次查询：" target="_blank" rel="noopener">www.apple.com”，就要进行下面的三次查询：</a></li>
</ul>
<blockquote>
<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“<a href="http://www.apple.com”的地址。" target="_blank" rel="noopener">www.apple.com”的地址。</a></li>
</ol>
</blockquote>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><ul>
<li>为了提高查询效率，外围有多级的缓存</li>
</ul>
<blockquote>
<ol>
<li>许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理</li>
<li>操作系统里也会对 DNS 解析结果做缓存</li>
</ol>
</blockquote>
<h2 id="域名玩法"><a href="#域名玩法" class="headerlink" title="域名玩法"></a>域名玩法</h2><blockquote>
<ol>
<li>重定向（变更主机ip）</li>
<li>搭建内部DNS</li>
<li>基于域名实现的负载均衡（轮询 or 返回最近主机）</li>
<li>域名屏蔽、域名劫持（域名污染）</li>
</ol>
</blockquote>
<h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><blockquote>
<p>浏览器缓存-&gt;操作系统缓存-&gt;hosts-&gt;dns</p>
</blockquote>
<h1 id="搭建HTTP实验环境"><a href="#搭建HTTP实验环境" class="headerlink" title="搭建HTTP实验环境"></a>搭建HTTP实验环境</h1><ul>
<li>软件准备</li>
</ul>
<blockquote>
<p>Wireshark</p>
<p>Chrome/Firefox</p>
<p>Telnet</p>
<p>OpenResty</p>
</blockquote>
<ul>
<li>修改hosts文件，添加配置本机 IP 地址到测试域名的映射</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       www.chrono.com</span><br><span class="line">127.0.0.1       www.metroid.net</span><br><span class="line">127.0.0.1       origin.io</span><br></pre></td></tr></table></figure>
<ul>
<li>Mac上 安装 OpenResty</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 使用homebrew安装OpenResty （ke能需要用梯子）</span><br><span class="line">brew install openresty/brew/openresty</span><br><span class="line"></span><br><span class="line"># 执行上面命令 可能出现报错如下：</span><br><span class="line">    Error: The following directories are not writable by your user:</span><br><span class="line">    /usr/local/share/man/man8</span><br><span class="line"></span><br><span class="line">    You should change the ownership of these directories to your user.</span><br><span class="line">      sudo chown -R $(whoami) /usr/local/share/man/man8</span><br><span class="line"></span><br><span class="line">    And make sure that your user has write permission.</span><br><span class="line">      chmod u+w /usr/local/share/man/man8</span><br><span class="line">  </span><br><span class="line"># 解决方案：在终端执行下面命令</span><br><span class="line">sudo chown -R `whoami`:admin /usr/local/bin</span><br><span class="line">sudo chown -R `whoami`:admin /usr/local/share</span><br><span class="line"></span><br><span class="line"># 查看是否安装成功</span><br><span class="line">resty -v</span><br><span class="line"></span><br><span class="line"># 执行上面命令出现了下面内容就代表成功了</span><br><span class="line">    resty 0.23</span><br><span class="line">    nginx version: openresty/1.15.8.3</span><br><span class="line">    built by clang 11.0.3 (clang-1103.0.32.62)</span><br><span class="line">    built with OpenSSL 1.1.0l  10 Sep 2019</span><br><span class="line"></span><br><span class="line">git clone https://github.com/chronolaw/http_study</span><br><span class="line"></span><br><span class="line">cd http_study/www/    #脚本必须在www目录下运行，才能找到nginx.conf</span><br><span class="line">./run.sh start        #启动实验环境</span><br><span class="line">./run.sh list         #列出实验环境的Nginx进程</span><br><span class="line">./run.sh reload       #重启实验环境</span><br><span class="line">./run.sh stop         #停止实验环境</span><br><span class="line"></span><br><span class="line"># 启动实验环境后访问 localhost，如果正常访问则环境搭建成功</span><br><span class="line"></span><br><span class="line"># 访问localhost 若出现403， 则在 conf/nginx.conf 文件的顶部添加 user xxxx staff，这个 xxxx 是自己的 mac 账户名，再重启实验环境即可</span><br></pre></td></tr></table></figure>
<ul>
<li>用浏览器或者 curl 来验证课程里的各个测试 URI</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1/&quot;</span><br><span class="line">curl -v &quot;http://www.chrono.com/09-1&quot;</span><br><span class="line">curl -k &quot;https://www.chrono.com/24-1?key=1234&quot;</span><br><span class="line">curl -v &quot;http://www.chrono.com/41-1&quot;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="键入网址再按下回车，后面究竟发生了什么"><a href="#键入网址再按下回车，后面究竟发生了什么" class="headerlink" title="键入网址再按下回车，后面究竟发生了什么"></a>键入网址再按下回车，后面究竟发生了什么</h1><p><img src="h5.png" width="650"></p>
<ul>
<li>最简单的浏览器 HTTP 请求过程：</li>
</ul>
<blockquote>
<ol>
<li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；</li>
<li>浏览器用 TCP 的三次握手与服务器建立连接；</li>
<li>浏览器向服务器发送拼好的报文；</li>
<li>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</li>
<li>浏览器解析报文，渲染输出页面。</li>
</ol>
</blockquote>
<ul>
<li><p>当浏览器发现输入的url不是数字形式的IP地址（那就肯定是域名了）于是就会发起域名解析动作，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址</p>
</li>
<li><p>域名解析过程</p>
</li>
</ul>
<blockquote>
<p>操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析</p>
<p>会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址</p>
<p>缓存服务器</p>
<p>应用服务器</p>
</blockquote>
<blockquote>
<ol>
<li>HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；</li>
<li>如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败；</li>
<li>建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文；</li>
<li>为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现“短路”操作</li>
</ol>
</blockquote>
<h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p><img src="h6.png" width="650"></p>
<blockquote>
<p>在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等</p>
</blockquote>
<h2 id="HTTP报文-1"><a href="#HTTP报文-1" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><ul>
<li>所以头数据都是 ASCII 码的文本</li>
<li>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</li>
</ul>
<blockquote>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据h</li>
</ol>
</blockquote>
<p><img src="h7.png" width="650"></p>
<h3 id="请求行（request-line）"><a href="#请求行（request-line）" class="headerlink" title="请求行（request line）"></a>请求行（request line）</h3><ul>
<li>简要地描述了<strong>客户端想要如何操作服务器端的资源</strong></li>
<li>请求行由三部分构成</li>
</ul>
<blockquote>
<ol>
<li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本</li>
</ol>
</blockquote>
<p>三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束</p>
<p><img src="h8.png" width="650"></p>
<h3 id="状态行（status-line）"><a href="#状态行（status-line）" class="headerlink" title="状态行（status line）"></a>状态行（status line）</h3><ul>
<li><strong>服务器响应的状态</strong></li>
<li>状态行由三部分构成</li>
</ul>
<blockquote>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因</li>
</ol>
</blockquote>
<p><img src="h9.png" width="650"></p>
<h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><ul>
<li>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头</li>
</ul>
<p><img src="h10.png" width="650"></p>
<p><img src="h11.png" width="650"></p>
<ul>
<li>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束</li>
<li>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能</li>
<li>使用头字段需要注意下面几点：</li>
</ul>
<blockquote>
<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie</li>
</ol>
</blockquote>
<h4 id="常用头字段"><a href="#常用头字段" class="headerlink" title="常用头字段"></a>常用头字段</h4><p>基本上可以分为四大类：</p>
<blockquote>
<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">头字段</th>
<th style="text-align:center">类别</th>
<th>说明/备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求字段</td>
<td>Host 字段告诉服务器这个请求应该由哪个主机来处理（唯一一个 HTTP/1.1 规范里要求<strong>必须出现</strong>的字段）</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">请求字段，只出现在请求头里</td>
<td>使用一个字符串来描述发起 HTTP 请求的客户端</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">通用字段，但通常出现在响应头里</td>
<td>表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">响应字段</td>
<td>告诉客户端当前正在提供 Web 服务的软件名称和版本号（非必须出现）</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">实体字段</td>
<td>它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输</td>
</tr>
</tbody>
</table>
<h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><ul>
<li>为什么要有“请求方法”</li>
</ul>
<blockquote>
<p>客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作</p>
</blockquote>
<ul>
<li>目前 HTTP/1.1 规定了八种方法，单词<strong>都必须是大写的形式</strong></li>
</ul>
<blockquote>
<ol>
<li>GET：获取资源，可以理解为读取或者下载数据；</li>
<li>HEAD：获取资源的元信息；</li>
<li>POST：向资源提交数据，相当于写入或上传数据；</li>
<li>PUT：类似 POST；</li>
<li>DELETE：删除资源；</li>
<li>CONNECT：建立特殊的连接隧道；</li>
<li>OPTIONS：列出可对资源实行的方法；</li>
<li>TRACE：追踪请求 - 响应的传输路径。</li>
</ol>
</blockquote>
<p><img src="h12.png" width="650"></p>
<h2 id="安全、幂等"><a href="#安全、幂等" class="headerlink" title="安全、幂等"></a>安全、幂等</h2><ul>
<li>幂等：多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”</li>
</ul>
<h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><ul>
<li>URL</li>
</ul>
<blockquote>
<p>统一资源定位符（Uniform Resource Locator）</p>
</blockquote>
<ul>
<li>URI</li>
</ul>
<blockquote>
<p>统一资源标识符（Uniform Resource Identifier）</p>
<p>URI 本质上是一个字符串，这个字符串的作用是<strong>唯一地标记资源的位置或者名字</strong></p>
<p>包含有 URL 和 URN 两个部分</p>
</blockquote>
<ul>
<li>URI 最常用的形式</li>
</ul>
<p><img src="h13.png" width="650"></p>
<ul>
<li><p>URI 的基本组成</p>
<blockquote>
<p>scheme:    “方案名”或者“协议名”，表示<strong>资源应该使用哪种协议</strong>来访问。</p>
</blockquote>
<blockquote>
<p>“://”之后:    是被称为“<strong>authority</strong>”的部分，表示<strong>资源所在的主机名</strong>，通常的形式是“host:port”，即主机名加端口号</p>
</blockquote>
</li>
<li><p>客户端和服务器看到的 URI 是不一样的</p>
</li>
</ul>
<blockquote>
<p>客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI。</p>
</blockquote>
<ul>
<li>URI 的查询参数</li>
</ul>
<blockquote>
<p>多个“<strong>key=value</strong>”的字符串，这些 KV 值用字符“<strong>&amp;</strong>”连接，浏览器和客户端都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。</p>
</blockquote>
<ul>
<li>URI 的完整格式</li>
</ul>
<p><img src="h14.png" width="650"></p>
<blockquote>
<p><strong>身份信息</strong>“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患</p>
</blockquote>
<ul>
<li><strong>片段标识符</strong>“#fragment”</li>
</ul>
<blockquote>
<p>它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置</p>
</blockquote>
<blockquote>
<p>片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段</p>
</blockquote>
<ul>
<li>URI 的编码</li>
</ul>
<blockquote>
<p>URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。</p>
</blockquote>
<blockquote>
<p>URI 转义的规则：直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”</p>
</blockquote>
<h2 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h2><ul>
<li>URI 的查询参数和头字段很相似，都是 key-value 形式，都可以任意自定义，那么它们在使用时该如何区别呢？</li>
</ul>
<blockquote>
<p>query参数针对的是资源（uri），而字段针对的是本次请求，也就是报文。<br></p>
<p>一个是长期、稳定的，一个是短期、临时的</p>
</blockquote>
<h1 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h1><ul>
<li>状态码（Status Code）</li>
</ul>
<blockquote>
<p>它是一个十进制数字，以代码的形式表示服务器对请求的处理结果</p>
</blockquote>
<blockquote>
<p>表达 HTTP 数据处理的“状态”，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思</p>
</blockquote>
<ul>
<li>RFC 标准把状态码分成了五类</li>
</ul>
<blockquote>
<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>
</ul>
</blockquote>
<h2 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h2><ul>
<li><strong>101 Switching Protocols</strong></li>
</ul>
<blockquote>
<p>客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了</p>
</blockquote>
<h2 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h2><ul>
<li><strong>200 OK</strong></li>
</ul>
<blockquote>
<p>是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果</p>
</blockquote>
<ul>
<li><strong>204 No Content</strong></li>
</ul>
<blockquote>
<p>含义与“200 OK”基本相同，但响应头后没有 body 数据</p>
</blockquote>
<ul>
<li><strong>206 Partial Content</strong></li>
</ul>
<blockquote>
<p>是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分</p>
</blockquote>
<blockquote>
<p>状态码 206 通常还会伴随着头字段“<strong>Content-Range</strong>”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节</p>
</blockquote>
<h2 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h2><ul>
<li><strong>301 Moved Permanently</strong></li>
</ul>
<blockquote>
<p>永久重定向</p>
</blockquote>
<ul>
<li><strong>302 Found</strong></li>
</ul>
<blockquote>
<p>临时重定向</p>
</blockquote>
<p><strong>301 和 302 都会在响应头里使用字段</strong>Location<strong>指明后续要跳转的 URI</strong></p>
<ul>
<li><strong>304 Not Modified</strong></li>
</ul>
<blockquote>
<p>它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制<br></p>
<p>可以理解成“重定向已到缓存的文件”（即“缓存重定向”）</p>
</blockquote>
<h2 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h2><ul>
<li><strong>400 Bad Request</strong></li>
</ul>
<blockquote>
<p>是一个通用的错误码，表示请求报文有错误</p>
</blockquote>
<ul>
<li><strong>403 Forbidden</strong></li>
</ul>
<blockquote>
<p>实际上不是客户端的请求出错，而是表示服务器禁止访问资源</p>
</blockquote>
<ul>
<li><strong>404 Not Found</strong></li>
</ul>
<blockquote>
<p>原意是资源在本服务器上未找到，所以无法提供给客户端</p>
</blockquote>
<blockquote>
<ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
</blockquote>
<h2 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h2><ul>
<li><strong>500 Internal Server Error</strong></li>
</ul>
<blockquote>
<p>服务器错误</p>
</blockquote>
<ul>
<li><strong>501 Not Implemented</strong></li>
</ul>
<blockquote>
<p>表示客户端请求的功能还不支持</p>
</blockquote>
<ul>
<li><strong>502 Bad Gateway</strong></li>
</ul>
<blockquote>
<p>通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误</p>
</blockquote>
<ul>
<li><strong>503 Service Unavailable</strong></li>
</ul>
<blockquote>
<p>服务器当前很忙，暂时无法响应服务<br></p>
<p>503 响应报文里通常还会有一个“<strong>Retry-After</strong>”字段，指示客户端可以在多久以后再次尝试发送请求</p>
</blockquote>
<h1 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h1><ul>
<li>灵活可扩展</li>
</ul>
<blockquote>
<p>只规定了报文的基本格<br></p>
<p>报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制</p>
</blockquote>
<ul>
<li>可靠传输</li>
</ul>
<blockquote>
<p>HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议<br></p>
<p>是对实际传输的数据（entity）做了一层包装，加上一个头，然后调用 Socket API，通过 TCP/IP 协议栈发送或者接收</p>
</blockquote>
<ul>
<li>应用层协议</li>
<li>请求 - 应答</li>
<li>无状态</li>
<li>其它特点</li>
</ul>
<blockquote>
<p>传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等。但这些并不能算是 HTTP 的基本特点，因为这都是由第一个“灵活可扩展”的特点所衍生出来的</p>
</blockquote>
<h1 id="HTTP优缺点"><a href="#HTTP优缺点" class="headerlink" title="HTTP优缺点"></a>HTTP优缺点</h1><ul>
<li>简单、灵活、易于扩展</li>
</ul>
<blockquote>
<p>降低了学习和使用的门槛<br></p>
<p>允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由<br></p>
<p>不限制具体的下层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定</p>
</blockquote>
<ul>
<li>应用广泛、环境成熟</li>
</ul>
<blockquote>
<p>不限定某种编程语言或者操作系统，所以天然具有“<strong>跨语言、跨平台</strong>”的优越性<br></p>
<p>有许多硬件基础设施支持</p>
</blockquote>
<ul>
<li>无状态</li>
</ul>
<blockquote>
<p>不需要额外的资源来记录状态信息<br></p>
<p>不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务<br></p>
<p>容易地组成集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使用“堆机器”的“笨办法”轻松实现高并发高可用</p>
</blockquote>
<blockquote>
<p>无法支持需要连续多个步骤的“事务”操作，不仅麻烦，而且还增加了不必要的数据传输量</p>
</blockquote>
<ul>
<li>明文</li>
</ul>
<blockquote>
<p>不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利</p>
</blockquote>
<blockquote>
<p>不安全</p>
</blockquote>
<ul>
<li>不安全</li>
</ul>
<blockquote>
<p>没有提供有效的手段来确认通信双方的真实身份<br></p>
<p>不支持“完整性校验”，数据在传输过程中容易被窜改而无法验证真伪。</p>
</blockquote>
<ul>
<li>性能</li>
</ul>
<blockquote>
<p>不算差，不够好<br></p>
<p>不能保证稳定的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好<br></p>
<p>“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据</p>
</blockquote>
<h1 id="HTTP实体数据"><a href="#HTTP实体数据" class="headerlink" title="HTTP实体数据"></a>HTTP实体数据</h1><h2 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h2><ul>
<li>请求头</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端告诉服务器，客户端可以接受什么样的数据，</span></span><br><span class="line">Accept: text/html,application/xml,image/webp,image/png</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示</span></span><br><span class="line">Accept-Charset: gbk, utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端支持的压缩格式</span></span><br><span class="line">Accept-Encoding: gzip,deflate,br	# 如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型</span></span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</li>
</ol>
</blockquote>
<ul>
<li>响应头</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器告诉客户端，实际传输的数据类型,</span></span><br><span class="line">Content-Type: text/html</span><br><span class="line"><span class="comment"># 字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示</span></span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际使用的压缩格式</span></span><br><span class="line">Content-Encoding: gzip	# 如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 告诉客户端实体数据使用的实际语言类型</span></span><br><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段</p>
</blockquote>
<ul>
<li>内容协商质量值</li>
</ul>
<blockquote>
<p>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>内容协商的结果</li>
</ul>
<blockquote>
<p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个<strong>Vary</strong>字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Encoding,User-Agent,Accept</span><br><span class="line"><span class="comment"># 这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文</span></span><br></pre></td></tr></table></figure>
<h1 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h1><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>
<ul>
<li>分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“<strong>Content-Length</strong>”里给出确切的长度，所以也只能用 chunked 方式分块发送</li>
<li>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是<strong>互斥的</strong>，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked</li>
</ul>
<h2 id="分块传输的编码规则"><a href="#分块传输的编码规则" class="headerlink" title="分块传输的编码规则"></a>分块传输的编码规则</h2><p><img src="h15.png" width="650"></p>
<blockquote>
<ol>
<li>每个分块包含两个部分，长度头和数据块；</li>
<li>长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；</li>
<li>数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；</li>
<li>最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。</li>
</ol>
</blockquote>
<h2 id="范围请求（range-requests）"><a href="#范围请求（range-requests）" class="headerlink" title="范围请求（range requests）"></a>范围请求（range requests）</h2><ul>
<li>允许客户端在请求头里使用专用字段来表示只获取文件的一部分</li>
<li>非必须</li>
<li>服务器必须在响应头里使用字段“<strong>Accept-Ranges: bytes</strong>”明确告知客户端：“我是支持范围请求的”</li>
<li>服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能</li>
<li>请求头<strong>Range</strong>是 HTTP 范围请求的专用字段，格式是“<strong>bytes=x-y</strong>”，其中的 x 和 y 是以字节为单位的数据范围</li>
<li>x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节</li>
<li>Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：</li>
</ul>
<blockquote>
<ul>
<li>“0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；</li>
<li>“10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；</li>
<li>“-1”是文档的最后一个字节，相当于“99-99”；</li>
<li>“-10”是从文档末尾倒数 10 个字节，相当于“90-99”。</li>
</ul>
</blockquote>
<ul>
<li>服务器收到 Range 字段后，需要做四件事</li>
</ul>
<blockquote>
<p>第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码<strong>416</strong>，意思是“你的范围请求有误，我无法处理，请再检查一下”。</p>
<p>第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“<strong>206 Partial Content</strong>”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</p>
<p>第三，服务器要添加一个响应头字段<strong>Content-Range</strong>，告诉片段的实际偏移量和资源的总大小，格式是“<strong>bytes x-y/length</strong>”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。</p>
<p>最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。</p>
</blockquote>
<ul>
<li>常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</li>
</ul>
<blockquote>
<ul>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ul>
</blockquote>
<h2 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h2><ul>
<li>一次性获取多个片段数据，这种情况需要使用一种特殊的 MIME 类型：“<strong>multipart/byteranges</strong>”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“<strong>boundary=xxx</strong>”给出段之间的分隔标记</li>
</ul>
<p><img src="h16.png" width="650"></p>
<p><br></p>
<ul>
<li>http交给tcp进行传输的时候本来就会分块，那http分块的意义是什么呢？</li>
</ul>
<blockquote>
<p>在http层是看不到tcp的，它不知道下层协议是否会分块，下层是否分块对它来说没有意义，不关心。</p>
</blockquote>
<blockquote>
<p>在http里一个报文必须是完整交付，在处理大文件的时候就很不方便，所以就要分块，在http层面方便处理。</p>
</blockquote>
<blockquote>
<p>chunked主要是在http的层次来解决问题。</p>
</blockquote>
<hr>
<hr>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        <li>
            <a target="_blank" href="https://twitter.com/iconie_alloy">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-twitter"></i>
                            </span>
            </a>
        </li>
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/ai-er-lan-xue-da">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="http://weibo.com/3286578617">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="https://www.facebook.com/xiaotao.nie.5">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-facebook"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://github.com/AirCloud">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://www.linkedin.com/in/小涛-聂-80964aba">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-linkedin"></i>
                            </span>
            </a>
        </li>
        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.10000h.top">10000H</a></span>
        <span>/</span>
        
        <span><a href="https://niexiaotao.com">Xiaotao&#39;s Page</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://airclouds-blog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>
